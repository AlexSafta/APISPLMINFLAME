"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ioredis";
exports.ids = ["vendor-chunks/ioredis"];
exports.modules = {

/***/ "(rsc)/./node_modules/ioredis/built/Command.js":
/*!***********************************************!*\
  !*** ./node_modules/ioredis/built/Command.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/./node_modules/cluster-key-slot/lib/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst argumentParsers_1 = __webpack_require__(/*! ./utils/argumentParsers */ \"(rsc)/./node_modules/ioredis/built/utils/argumentParsers.js\");\n/**\n * Command instance\n *\n * It's rare that you need to create a Command instance yourself.\n *\n * ```js\n * var infoCommand = new Command('info', null, function (err, result) {\n *   console.log('result', result);\n * });\n *\n * redis.sendCommand(infoCommand);\n *\n * // When no callback provided, Command instance will have a `promise` property,\n * // which will resolve/reject with the result of the command.\n * var getCommand = new Command('get', ['foo']);\n * getCommand.promise.then(function (result) {\n *   console.log('result', result);\n * });\n * ```\n */ class Command {\n    /**\n     * Creates an instance of Command.\n     * @param name Command name\n     * @param args An array of command arguments\n     * @param options\n     * @param callback The callback that handles the response.\n     * If omit, the response will be handled via Promise\n     */ constructor(name, args = [], options = {}, callback){\n        this.name = name;\n        this.inTransaction = false;\n        this.isResolved = false;\n        this.transformed = false;\n        this.replyEncoding = options.replyEncoding;\n        this.errorStack = options.errorStack;\n        this.args = args.flat();\n        this.callback = callback;\n        this.initPromise();\n        if (options.keyPrefix) {\n            // @ts-expect-error\n            const isBufferKeyPrefix = options.keyPrefix instanceof Buffer;\n            // @ts-expect-error\n            let keyPrefixBuffer = isBufferKeyPrefix ? options.keyPrefix : null;\n            this._iterateKeys((key)=>{\n                if (key instanceof Buffer) {\n                    if (keyPrefixBuffer === null) {\n                        keyPrefixBuffer = Buffer.from(options.keyPrefix);\n                    }\n                    return Buffer.concat([\n                        keyPrefixBuffer,\n                        key\n                    ]);\n                } else if (isBufferKeyPrefix) {\n                    // @ts-expect-error\n                    return Buffer.concat([\n                        options.keyPrefix,\n                        Buffer.from(String(key))\n                    ]);\n                }\n                return options.keyPrefix + key;\n            });\n        }\n        if (options.readOnly) {\n            this.isReadOnly = true;\n        }\n    }\n    /**\n     * Check whether the command has the flag\n     */ static checkFlag(flagName, commandName) {\n        commandName = commandName.toLowerCase();\n        return !!this.getFlagMap()[flagName][commandName];\n    }\n    static setArgumentTransformer(name, func) {\n        this._transformer.argument[name] = func;\n    }\n    static setReplyTransformer(name, func) {\n        this._transformer.reply[name] = func;\n    }\n    static getFlagMap() {\n        if (!this.flagMap) {\n            this.flagMap = Object.keys(Command.FLAGS).reduce((map, flagName)=>{\n                map[flagName] = {};\n                Command.FLAGS[flagName].forEach((commandName)=>{\n                    map[flagName][commandName] = true;\n                });\n                return map;\n            }, {});\n        }\n        return this.flagMap;\n    }\n    getSlot() {\n        if (typeof this.slot === \"undefined\") {\n            const key = this.getKeys()[0];\n            this.slot = key == null ? null : calculateSlot(key);\n        }\n        return this.slot;\n    }\n    getKeys() {\n        return this._iterateKeys();\n    }\n    /**\n     * Convert command to writable buffer or string\n     */ toWritable(_socket) {\n        let result;\n        const commandStr = \"*\" + (this.args.length + 1) + \"\\r\\n$\" + Buffer.byteLength(this.name) + \"\\r\\n\" + this.name + \"\\r\\n\";\n        if (this.bufferMode) {\n            const buffers = new MixedBuffers();\n            buffers.push(commandStr);\n            for(let i = 0; i < this.args.length; ++i){\n                const arg = this.args[i];\n                if (arg instanceof Buffer) {\n                    if (arg.length === 0) {\n                        buffers.push(\"$0\\r\\n\\r\\n\");\n                    } else {\n                        buffers.push(\"$\" + arg.length + \"\\r\\n\");\n                        buffers.push(arg);\n                        buffers.push(\"\\r\\n\");\n                    }\n                } else {\n                    buffers.push(\"$\" + Buffer.byteLength(arg) + \"\\r\\n\" + arg + \"\\r\\n\");\n                }\n            }\n            result = buffers.toBuffer();\n        } else {\n            result = commandStr;\n            for(let i = 0; i < this.args.length; ++i){\n                const arg = this.args[i];\n                result += \"$\" + Buffer.byteLength(arg) + \"\\r\\n\" + arg + \"\\r\\n\";\n            }\n        }\n        return result;\n    }\n    stringifyArguments() {\n        for(let i = 0; i < this.args.length; ++i){\n            const arg = this.args[i];\n            if (typeof arg === \"string\") {\n            // buffers and strings don't need any transformation\n            } else if (arg instanceof Buffer) {\n                this.bufferMode = true;\n            } else {\n                this.args[i] = (0, utils_1.toArg)(arg);\n            }\n        }\n    }\n    /**\n     * Convert buffer/buffer[] to string/string[],\n     * and apply reply transformer.\n     */ transformReply(result) {\n        if (this.replyEncoding) {\n            result = (0, utils_1.convertBufferToString)(result, this.replyEncoding);\n        }\n        const transformer = Command._transformer.reply[this.name];\n        if (transformer) {\n            result = transformer(result);\n        }\n        return result;\n    }\n    /**\n     * Set the wait time before terminating the attempt to execute a command\n     * and generating an error.\n     */ setTimeout(ms) {\n        if (!this._commandTimeoutTimer) {\n            this._commandTimeoutTimer = setTimeout(()=>{\n                if (!this.isResolved) {\n                    this.reject(new Error(\"Command timed out\"));\n                }\n            }, ms);\n        }\n    }\n    /**\n     * Set a timeout for blocking commands.\n     * When the timeout expires, the command resolves with null (matching Redis behavior).\n     * This handles the case of undetectable network failures (e.g., docker network disconnect)\n     * where the TCP connection becomes a zombie and no close event fires.\n     */ setBlockingTimeout(ms) {\n        if (ms <= 0) {\n            return;\n        }\n        // Clear existing timer if any (can happen when command moves from offline to command queue)\n        if (this._blockingTimeoutTimer) {\n            clearTimeout(this._blockingTimeoutTimer);\n            this._blockingTimeoutTimer = undefined;\n        }\n        const now = Date.now();\n        // First call: establish absolute deadline\n        if (this._blockingDeadline === undefined) {\n            this._blockingDeadline = now + ms;\n        }\n        // Check if we've already exceeded the deadline\n        const remaining = this._blockingDeadline - now;\n        if (remaining <= 0) {\n            // Resolve with null to indicate timeout (same as Redis behavior)\n            this.resolve(null);\n            return;\n        }\n        this._blockingTimeoutTimer = setTimeout(()=>{\n            if (this.isResolved) {\n                this._blockingTimeoutTimer = undefined;\n                return;\n            }\n            this._blockingTimeoutTimer = undefined;\n            // Timeout expired - resolve with null (same as Redis behavior when blocking command times out)\n            this.resolve(null);\n        }, remaining);\n    }\n    /**\n     * Extract the blocking timeout from the command arguments.\n     *\n     * @returns The timeout in seconds, null for indefinite blocking (timeout of 0),\n     *          or undefined if this is not a blocking command\n     */ extractBlockingTimeout() {\n        const args = this.args;\n        if (!args || args.length === 0) {\n            return undefined;\n        }\n        const name = this.name.toLowerCase();\n        if (Command.checkFlag(\"LAST_ARG_TIMEOUT_COMMANDS\", name)) {\n            return (0, argumentParsers_1.parseSecondsArgument)(args[args.length - 1]);\n        }\n        if (Command.checkFlag(\"FIRST_ARG_TIMEOUT_COMMANDS\", name)) {\n            return (0, argumentParsers_1.parseSecondsArgument)(args[0]);\n        }\n        if (Command.checkFlag(\"BLOCK_OPTION_COMMANDS\", name)) {\n            return (0, argumentParsers_1.parseBlockOption)(args);\n        }\n        return undefined;\n    }\n    /**\n     * Clear the command and blocking timers\n     */ _clearTimers() {\n        const existingTimer = this._commandTimeoutTimer;\n        if (existingTimer) {\n            clearTimeout(existingTimer);\n            delete this._commandTimeoutTimer;\n        }\n        const blockingTimer = this._blockingTimeoutTimer;\n        if (blockingTimer) {\n            clearTimeout(blockingTimer);\n            delete this._blockingTimeoutTimer;\n        }\n    }\n    initPromise() {\n        const promise = new Promise((resolve, reject)=>{\n            if (!this.transformed) {\n                this.transformed = true;\n                const transformer = Command._transformer.argument[this.name];\n                if (transformer) {\n                    this.args = transformer(this.args);\n                }\n                this.stringifyArguments();\n            }\n            this.resolve = this._convertValue(resolve);\n            this.reject = (err)=>{\n                this._clearTimers();\n                if (this.errorStack) {\n                    reject((0, utils_1.optimizeErrorStack)(err, this.errorStack.stack, __dirname));\n                } else {\n                    reject(err);\n                }\n            };\n        });\n        this.promise = (0, standard_as_callback_1.default)(promise, this.callback);\n    }\n    /**\n     * Iterate through the command arguments that are considered keys.\n     */ _iterateKeys(transform = (key)=>key) {\n        if (typeof this.keys === \"undefined\") {\n            this.keys = [];\n            if ((0, commands_1.exists)(this.name, {\n                caseInsensitive: true\n            })) {\n                // @ts-expect-error\n                const keyIndexes = (0, commands_1.getKeyIndexes)(this.name, this.args, {\n                    nameCaseInsensitive: true\n                });\n                for (const index of keyIndexes){\n                    this.args[index] = transform(this.args[index]);\n                    this.keys.push(this.args[index]);\n                }\n            }\n        }\n        return this.keys;\n    }\n    /**\n     * Convert the value from buffer to the target encoding.\n     */ _convertValue(resolve) {\n        return (value)=>{\n            try {\n                this._clearTimers();\n                resolve(this.transformReply(value));\n                this.isResolved = true;\n            } catch (err) {\n                this.reject(err);\n            }\n            return this.promise;\n        };\n    }\n}\nexports[\"default\"] = Command;\nCommand.FLAGS = {\n    VALID_IN_SUBSCRIBER_MODE: [\n        \"subscribe\",\n        \"psubscribe\",\n        \"unsubscribe\",\n        \"punsubscribe\",\n        \"ssubscribe\",\n        \"sunsubscribe\",\n        \"ping\",\n        \"quit\"\n    ],\n    VALID_IN_MONITOR_MODE: [\n        \"monitor\",\n        \"auth\"\n    ],\n    ENTER_SUBSCRIBER_MODE: [\n        \"subscribe\",\n        \"psubscribe\",\n        \"ssubscribe\"\n    ],\n    EXIT_SUBSCRIBER_MODE: [\n        \"unsubscribe\",\n        \"punsubscribe\",\n        \"sunsubscribe\"\n    ],\n    WILL_DISCONNECT: [\n        \"quit\"\n    ],\n    HANDSHAKE_COMMANDS: [\n        \"auth\",\n        \"select\",\n        \"client\",\n        \"readonly\",\n        \"info\"\n    ],\n    IGNORE_RECONNECT_ON_ERROR: [\n        \"client\"\n    ],\n    BLOCKING_COMMANDS: [\n        \"blpop\",\n        \"brpop\",\n        \"brpoplpush\",\n        \"blmove\",\n        \"bzpopmin\",\n        \"bzpopmax\",\n        \"bzmpop\",\n        \"blmpop\",\n        \"xread\",\n        \"xreadgroup\"\n    ],\n    LAST_ARG_TIMEOUT_COMMANDS: [\n        \"blpop\",\n        \"brpop\",\n        \"brpoplpush\",\n        \"blmove\",\n        \"bzpopmin\",\n        \"bzpopmax\"\n    ],\n    FIRST_ARG_TIMEOUT_COMMANDS: [\n        \"bzmpop\",\n        \"blmpop\"\n    ],\n    BLOCK_OPTION_COMMANDS: [\n        \"xread\",\n        \"xreadgroup\"\n    ]\n};\nCommand._transformer = {\n    argument: {},\n    reply: {}\n};\nconst msetArgumentTransformer = function(args) {\n    if (args.length === 1) {\n        if (args[0] instanceof Map) {\n            return (0, utils_1.convertMapToArray)(args[0]);\n        }\n        if (typeof args[0] === \"object\" && args[0] !== null) {\n            return (0, utils_1.convertObjectToArray)(args[0]);\n        }\n    }\n    return args;\n};\nconst hsetArgumentTransformer = function(args) {\n    if (args.length === 2) {\n        if (args[1] instanceof Map) {\n            return [\n                args[0]\n            ].concat((0, utils_1.convertMapToArray)(args[1]));\n        }\n        if (typeof args[1] === \"object\" && args[1] !== null) {\n            return [\n                args[0]\n            ].concat((0, utils_1.convertObjectToArray)(args[1]));\n        }\n    }\n    return args;\n};\nCommand.setArgumentTransformer(\"mset\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"msetnx\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"hset\", hsetArgumentTransformer);\nCommand.setArgumentTransformer(\"hmset\", hsetArgumentTransformer);\nCommand.setReplyTransformer(\"hgetall\", function(result) {\n    if (Array.isArray(result)) {\n        const obj = {};\n        for(let i = 0; i < result.length; i += 2){\n            const key = result[i];\n            const value = result[i + 1];\n            if (key in obj) {\n                // can only be truthy if the property is special somehow, like '__proto__' or 'constructor'\n                // https://github.com/luin/ioredis/issues/1267\n                Object.defineProperty(obj, key, {\n                    value,\n                    configurable: true,\n                    enumerable: true,\n                    writable: true\n                });\n            } else {\n                obj[key] = value;\n            }\n        }\n        return obj;\n    }\n    return result;\n});\nclass MixedBuffers {\n    constructor(){\n        this.length = 0;\n        this.items = [];\n    }\n    push(x) {\n        this.length += Buffer.byteLength(x);\n        this.items.push(x);\n    }\n    toBuffer() {\n        const result = Buffer.allocUnsafe(this.length);\n        let offset = 0;\n        for (const item of this.items){\n            const length = Buffer.byteLength(item);\n            Buffer.isBuffer(item) ? item.copy(result, offset) : result.write(item, offset, length);\n            offset += length;\n        }\n        return result;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9Db21tYW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGFBQWFDLG1CQUFPQSxDQUFDLGdGQUFtQjtBQUM5QyxNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDLDRFQUFrQjtBQUNoRCxNQUFNRSx5QkFBeUJGLG1CQUFPQSxDQUFDLHNGQUFzQjtBQUM3RCxNQUFNRyxVQUFVSCxtQkFBT0EsQ0FBQyxrRUFBUztBQUNqQyxNQUFNSSxvQkFBb0JKLG1CQUFPQSxDQUFDLDRGQUF5QjtBQUMzRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELE1BQU1LO0lBQ0Y7Ozs7Ozs7S0FPQyxHQUNEQyxZQUFZQyxJQUFJLEVBQUVDLE9BQU8sRUFBRSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFQyxRQUFRLENBQUU7UUFDakQsSUFBSSxDQUFDSCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDSSxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUdMLFFBQVFLLGFBQWE7UUFDMUMsSUFBSSxDQUFDQyxVQUFVLEdBQUdOLFFBQVFNLFVBQVU7UUFDcEMsSUFBSSxDQUFDUCxJQUFJLEdBQUdBLEtBQUtRLElBQUk7UUFDckIsSUFBSSxDQUFDTixRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ08sV0FBVztRQUNoQixJQUFJUixRQUFRUyxTQUFTLEVBQUU7WUFDbkIsbUJBQW1CO1lBQ25CLE1BQU1DLG9CQUFvQlYsUUFBUVMsU0FBUyxZQUFZRTtZQUN2RCxtQkFBbUI7WUFDbkIsSUFBSUMsa0JBQWtCRixvQkFDaEJWLFFBQVFTLFNBQVMsR0FDakI7WUFDTixJQUFJLENBQUNJLFlBQVksQ0FBQyxDQUFDQztnQkFDZixJQUFJQSxlQUFl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QUNqQzVHLE9BQU82RyxRQUFRLENBQUNELFFBQ1ZBLEtBQUtFLElBQUksQ0FBQy9FLFFBQVE0RSxVQUNsQjVFLE9BQU9nRixLQUFLLENBQUNILE1BQU1ELFFBQVExRTtZQUNqQzBFLFVBQVUxRTtRQUNkO1FBQ0EsT0FBT0Y7SUFDWDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvZHVjdC1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9Db21tYW5kLmpzPzIxNTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb21tYW5kc18xID0gcmVxdWlyZShcIkBpb3JlZGlzL2NvbW1hbmRzXCIpO1xuY29uc3QgY2FsY3VsYXRlU2xvdCA9IHJlcXVpcmUoXCJjbHVzdGVyLWtleS1zbG90XCIpO1xuY29uc3Qgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMSA9IHJlcXVpcmUoXCJzdGFuZGFyZC1hcy1jYWxsYmFja1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGFyZ3VtZW50UGFyc2Vyc18xID0gcmVxdWlyZShcIi4vdXRpbHMvYXJndW1lbnRQYXJzZXJzXCIpO1xuLyoqXG4gKiBDb21tYW5kIGluc3RhbmNlXG4gKlxuICogSXQncyByYXJlIHRoYXQgeW91IG5lZWQgdG8gY3JlYXRlIGEgQ29tbWFuZCBpbnN0YW5jZSB5b3Vyc2VsZi5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGluZm9Db21tYW5kID0gbmV3IENvbW1hbmQoJ2luZm8nLCBudWxsLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgY29uc29sZS5sb2coJ3Jlc3VsdCcsIHJlc3VsdCk7XG4gKiB9KTtcbiAqXG4gKiByZWRpcy5zZW5kQ29tbWFuZChpbmZvQ29tbWFuZCk7XG4gKlxuICogLy8gV2hlbiBubyBjYWxsYmFjayBwcm92aWRlZCwgQ29tbWFuZCBpbnN0YW5jZSB3aWxsIGhhdmUgYSBgcHJvbWlzZWAgcHJvcGVydHksXG4gKiAvLyB3aGljaCB3aWxsIHJlc29sdmUvcmVqZWN0IHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgY29tbWFuZC5cbiAqIHZhciBnZXRDb21tYW5kID0gbmV3IENvbW1hbmQoJ2dldCcsIFsnZm9vJ10pO1xuICogZ2V0Q29tbWFuZC5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICogICBjb25zb2xlLmxvZygncmVzdWx0JywgcmVzdWx0KTtcbiAqIH0pO1xuICogYGBgXG4gKi9cbmNsYXNzIENvbW1hbmQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ29tbWFuZC5cbiAgICAgKiBAcGFyYW0gbmFtZSBDb21tYW5kIG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyBBbiBhcnJheSBvZiBjb21tYW5kIGFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0aGF0IGhhbmRsZXMgdGhlIHJlc3BvbnNlLlxuICAgICAqIElmIG9taXQsIHRoZSByZXNwb25zZSB3aWxsIGJlIGhhbmRsZWQgdmlhIFByb21pc2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhcmdzID0gW10sIG9wdGlvbnMgPSB7fSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVwbHlFbmNvZGluZyA9IG9wdGlvbnMucmVwbHlFbmNvZGluZztcbiAgICAgICAgdGhpcy5lcnJvclN0YWNrID0gb3B0aW9ucy5lcnJvclN0YWNrO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzLmZsYXQoKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmluaXRQcm9taXNlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmtleVByZWZpeCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgY29uc3QgaXNCdWZmZXJLZXlQcmVmaXggPSBvcHRpb25zLmtleVByZWZpeCBpbnN0YW5jZW9mIEJ1ZmZlcjtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGxldCBrZXlQcmVmaXhCdWZmZXIgPSBpc0J1ZmZlcktleVByZWZpeFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5rZXlQcmVmaXhcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9pdGVyYXRlS2V5cygoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UHJlZml4QnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlQcmVmaXhCdWZmZXIgPSBCdWZmZXIuZnJvbShvcHRpb25zLmtleVByZWZpeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2tleVByZWZpeEJ1ZmZlciwga2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZmVyS2V5UHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW29wdGlvbnMua2V5UHJlZml4LCBCdWZmZXIuZnJvbShTdHJpbmcoa2V5KSldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMua2V5UHJlZml4ICsga2V5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSZWFkT25seSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgY29tbWFuZCBoYXMgdGhlIGZsYWdcbiAgICAgKi9cbiAgICBzdGF0aWMgY2hlY2tGbGFnKGZsYWdOYW1lLCBjb21tYW5kTmFtZSkge1xuICAgICAgICBjb21tYW5kTmFtZSA9IGNvbW1hbmROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0RmxhZ01hcCgpW2ZsYWdOYW1lXVtjb21tYW5kTmFtZV07XG4gICAgfVxuICAgIHN0YXRpYyBzZXRBcmd1bWVudFRyYW5zZm9ybWVyKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZXIuYXJndW1lbnRbbmFtZV0gPSBmdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0UmVwbHlUcmFuc2Zvcm1lcihuYW1lLCBmdW5jKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVyLnJlcGx5W25hbWVdID0gZnVuYztcbiAgICB9XG4gICAgc3RhdGljIGdldEZsYWdNYXAoKSB7XG4gICAgICAgIGlmICghdGhpcy5mbGFnTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmZsYWdNYXAgPSBPYmplY3Qua2V5cyhDb21tYW5kLkZMQUdTKS5yZWR1Y2UoKG1hcCwgZmxhZ05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBtYXBbZmxhZ05hbWVdID0ge307XG4gICAgICAgICAgICAgICAgQ29tbWFuZC5GTEFHU1tmbGFnTmFtZV0uZm9yRWFjaCgoY29tbWFuZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW2ZsYWdOYW1lXVtjb21tYW5kTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ01hcDtcbiAgICB9XG4gICAgZ2V0U2xvdCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNsb3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5cygpWzBdO1xuICAgICAgICAgICAgdGhpcy5zbG90ID0ga2V5ID09IG51bGwgPyBudWxsIDogY2FsY3VsYXRlU2xvdChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNsb3Q7XG4gICAgfVxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVyYXRlS2V5cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGNvbW1hbmQgdG8gd3JpdGFibGUgYnVmZmVyIG9yIHN0cmluZ1xuICAgICAqL1xuICAgIHRvV3JpdGFibGUoX3NvY2tldCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBjb25zdCBjb21tYW5kU3RyID0gXCIqXCIgK1xuICAgICAgICAgICAgKHRoaXMuYXJncy5sZW5ndGggKyAxKSArXG4gICAgICAgICAgICBcIlxcclxcbiRcIiArXG4gICAgICAgICAgICBCdWZmZXIuYnl0ZUxlbmd0aCh0aGlzLm5hbWUpICtcbiAgICAgICAgICAgIFwiXFxyXFxuXCIgK1xuICAgICAgICAgICAgdGhpcy5uYW1lICtcbiAgICAgICAgICAgIFwiXFxyXFxuXCI7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlck1vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBuZXcgTWl4ZWRCdWZmZXJzKCk7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goY29tbWFuZFN0cik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IHRoaXMuYXJnc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goXCIkMFxcclxcblxcclxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChcIiRcIiArIGFyZy5sZW5ndGggKyBcIlxcclxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKFwiXFxyXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goXCIkXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgoYXJnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcclxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcclxcblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBidWZmZXJzLnRvQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb21tYW5kU3RyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLmFyZ3NbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9XG4gICAgICAgICAgICAgICAgICAgIFwiJFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKGFyZykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHJcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdHJpbmdpZnlBcmd1bWVudHMoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLmFyZ3NbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlcnMgYW5kIHN0cmluZ3MgZG9uJ3QgbmVlZCBhbnkgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyTW9kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3NbaV0gPSAoMCwgdXRpbHNfMS50b0FyZykoYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGJ1ZmZlci9idWZmZXJbXSB0byBzdHJpbmcvc3RyaW5nW10sXG4gICAgICogYW5kIGFwcGx5IHJlcGx5IHRyYW5zZm9ybWVyLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybVJlcGx5KHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy5yZXBseUVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoMCwgdXRpbHNfMS5jb252ZXJ0QnVmZmVyVG9TdHJpbmcpKHJlc3VsdCwgdGhpcy5yZXBseUVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IENvbW1hbmQuX3RyYW5zZm9ybWVyLnJlcGx5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gdHJhbnNmb3JtZXIocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHdhaXQgdGltZSBiZWZvcmUgdGVybWluYXRpbmcgdGhlIGF0dGVtcHQgdG8gZXhlY3V0ZSBhIGNvbW1hbmRcbiAgICAgKiBhbmQgZ2VuZXJhdGluZyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBzZXRUaW1lb3V0KG1zKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29tbWFuZFRpbWVvdXRUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5fY29tbWFuZFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KG5ldyBFcnJvcihcIkNvbW1hbmQgdGltZWQgb3V0XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgdGltZW91dCBmb3IgYmxvY2tpbmcgY29tbWFuZHMuXG4gICAgICogV2hlbiB0aGUgdGltZW91dCBleHBpcmVzLCB0aGUgY29tbWFuZCByZXNvbHZlcyB3aXRoIG51bGwgKG1hdGNoaW5nIFJlZGlzIGJlaGF2aW9yKS5cbiAgICAgKiBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugb2YgdW5kZXRlY3RhYmxlIG5ldHdvcmsgZmFpbHVyZXMgKGUuZy4sIGRvY2tlciBuZXR3b3JrIGRpc2Nvbm5lY3QpXG4gICAgICogd2hlcmUgdGhlIFRDUCBjb25uZWN0aW9uIGJlY29tZXMgYSB6b21iaWUgYW5kIG5vIGNsb3NlIGV2ZW50IGZpcmVzLlxuICAgICAqL1xuICAgIHNldEJsb2NraW5nVGltZW91dChtcykge1xuICAgICAgICBpZiAobXMgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGV4aXN0aW5nIHRpbWVyIGlmIGFueSAoY2FuIGhhcHBlbiB3aGVuIGNvbW1hbmQgbW92ZXMgZnJvbSBvZmZsaW5lIHRvIGNvbW1hbmQgcXVldWUpXG4gICAgICAgIGlmICh0aGlzLl9ibG9ja2luZ1RpbWVvdXRUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Jsb2NraW5nVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NraW5nVGltZW91dFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIC8vIEZpcnN0IGNhbGw6IGVzdGFibGlzaCBhYnNvbHV0ZSBkZWFkbGluZVxuICAgICAgICBpZiAodGhpcy5fYmxvY2tpbmdEZWFkbGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9ibG9ja2luZ0RlYWRsaW5lID0gbm93ICsgbXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UndmUgYWxyZWFkeSBleGNlZWRlZCB0aGUgZGVhZGxpbmVcbiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5fYmxvY2tpbmdEZWFkbGluZSAtIG5vdztcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIHdpdGggbnVsbCB0byBpbmRpY2F0ZSB0aW1lb3V0IChzYW1lIGFzIFJlZGlzIGJlaGF2aW9yKVxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Jsb2NraW5nVGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tpbmdUaW1lb3V0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYmxvY2tpbmdUaW1lb3V0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBUaW1lb3V0IGV4cGlyZWQgLSByZXNvbHZlIHdpdGggbnVsbCAoc2FtZSBhcyBSZWRpcyBiZWhhdmlvciB3aGVuIGJsb2NraW5nIGNvbW1hbmQgdGltZXMgb3V0KVxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9LCByZW1haW5pbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHRoZSBibG9ja2luZyB0aW1lb3V0IGZyb20gdGhlIGNvbW1hbmQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHRpbWVvdXQgaW4gc2Vjb25kcywgbnVsbCBmb3IgaW5kZWZpbml0ZSBibG9ja2luZyAodGltZW91dCBvZiAwKSxcbiAgICAgKiAgICAgICAgICBvciB1bmRlZmluZWQgaWYgdGhpcyBpcyBub3QgYSBibG9ja2luZyBjb21tYW5kXG4gICAgICovXG4gICAgZXh0cmFjdEJsb2NraW5nVGltZW91dCgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuYXJncztcbiAgICAgICAgaWYgKCFhcmdzIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKENvbW1hbmQuY2hlY2tGbGFnKFwiTEFTVF9BUkdfVElNRU9VVF9DT01NQU5EU1wiLCBuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBhcmd1bWVudFBhcnNlcnNfMS5wYXJzZVNlY29uZHNBcmd1bWVudCkoYXJnc1thcmdzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ29tbWFuZC5jaGVja0ZsYWcoXCJGSVJTVF9BUkdfVElNRU9VVF9DT01NQU5EU1wiLCBuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBhcmd1bWVudFBhcnNlcnNfMS5wYXJzZVNlY29uZHNBcmd1bWVudCkoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbW1hbmQuY2hlY2tGbGFnKFwiQkxPQ0tfT1BUSU9OX0NPTU1BTkRTXCIsIG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGFyZ3VtZW50UGFyc2Vyc18xLnBhcnNlQmxvY2tPcHRpb24pKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjb21tYW5kIGFuZCBibG9ja2luZyB0aW1lcnNcbiAgICAgKi9cbiAgICBfY2xlYXJUaW1lcnMoKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVGltZXIgPSB0aGlzLl9jb21tYW5kVGltZW91dFRpbWVyO1xuICAgICAgICBpZiAoZXhpc3RpbmdUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nVGltZXIpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbW1hbmRUaW1lb3V0VGltZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2tpbmdUaW1lciA9IHRoaXMuX2Jsb2NraW5nVGltZW91dFRpbWVyO1xuICAgICAgICBpZiAoYmxvY2tpbmdUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGJsb2NraW5nVGltZXIpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Jsb2NraW5nVGltZW91dFRpbWVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRQcm9taXNlKCkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSBDb21tYW5kLl90cmFuc2Zvcm1lci5hcmd1bWVudFt0aGlzLm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3MgPSB0cmFuc2Zvcm1lcih0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0cmluZ2lmeUFyZ3VtZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gdGhpcy5fY29udmVydFZhbHVlKHJlc29sdmUpO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lcnJvclN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgoMCwgdXRpbHNfMS5vcHRpbWl6ZUVycm9yU3RhY2spKGVyciwgdGhpcy5lcnJvclN0YWNrLnN0YWNrLCBfX2Rpcm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb21pc2UgPSAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShwcm9taXNlLCB0aGlzLmNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSB0aHJvdWdoIHRoZSBjb21tYW5kIGFyZ3VtZW50cyB0aGF0IGFyZSBjb25zaWRlcmVkIGtleXMuXG4gICAgICovXG4gICAgX2l0ZXJhdGVLZXlzKHRyYW5zZm9ybSA9IChrZXkpID0+IGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMua2V5cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgICAgICAgICBpZiAoKDAsIGNvbW1hbmRzXzEuZXhpc3RzKSh0aGlzLm5hbWUsIHsgY2FzZUluc2Vuc2l0aXZlOiB0cnVlIH0pKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUluZGV4ZXMgPSAoMCwgY29tbWFuZHNfMS5nZXRLZXlJbmRleGVzKSh0aGlzLm5hbWUsIHRoaXMuYXJncywge1xuICAgICAgICAgICAgICAgICAgICBuYW1lQ2FzZUluc2Vuc2l0aXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2Yga2V5SW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3NbaW5kZXhdID0gdHJhbnNmb3JtKHRoaXMuYXJnc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmtleXMucHVzaCh0aGlzLmFyZ3NbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgdmFsdWUgZnJvbSBidWZmZXIgdG8gdGhlIHRhcmdldCBlbmNvZGluZy5cbiAgICAgKi9cbiAgICBfY29udmVydFZhbHVlKHJlc29sdmUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhclRpbWVycygpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy50cmFuc2Zvcm1SZXBseSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tbWFuZDtcbkNvbW1hbmQuRkxBR1MgPSB7XG4gICAgVkFMSURfSU5fU1VCU0NSSUJFUl9NT0RFOiBbXG4gICAgICAgIFwic3Vic2NyaWJlXCIsXG4gICAgICAgIFwicHN1YnNjcmliZVwiLFxuICAgICAgICBcInVuc3Vic2NyaWJlXCIsXG4gICAgICAgIFwicHVuc3Vic2NyaWJlXCIsXG4gICAgICAgIFwic3N1YnNjcmliZVwiLFxuICAgICAgICBcInN1bnN1YnNjcmliZVwiLFxuICAgICAgICBcInBpbmdcIixcbiAgICAgICAgXCJxdWl0XCIsXG4gICAgXSxcbiAgICBWQUxJRF9JTl9NT05JVE9SX01PREU6IFtcIm1vbml0b3JcIiwgXCJhdXRoXCJdLFxuICAgIEVOVEVSX1NVQlNDUklCRVJfTU9ERTogW1wic3Vic2NyaWJlXCIsIFwicHN1YnNjcmliZVwiLCBcInNzdWJzY3JpYmVcIl0sXG4gICAgRVhJVF9TVUJTQ1JJQkVSX01PREU6IFtcInVuc3Vic2NyaWJlXCIsIFwicHVuc3Vic2NyaWJlXCIsIFwic3Vuc3Vic2NyaWJlXCJdLFxuICAgIFdJTExfRElTQ09OTkVDVDogW1wicXVpdFwiXSxcbiAgICBIQU5EU0hBS0VfQ09NTUFORFM6IFtcImF1dGhcIiwgXCJzZWxlY3RcIiwgXCJjbGllbnRcIiwgXCJyZWFkb25seVwiLCBcImluZm9cIl0sXG4gICAgSUdOT1JFX1JFQ09OTkVDVF9PTl9FUlJPUjogW1wiY2xpZW50XCJdLFxuICAgIEJMT0NLSU5HX0NPTU1BTkRTOiBbXG4gICAgICAgIFwiYmxwb3BcIixcbiAgICAgICAgXCJicnBvcFwiLFxuICAgICAgICBcImJycG9wbHB1c2hcIixcbiAgICAgICAgXCJibG1vdmVcIixcbiAgICAgICAgXCJienBvcG1pblwiLFxuICAgICAgICBcImJ6cG9wbWF4XCIsXG4gICAgICAgIFwiYnptcG9wXCIsXG4gICAgICAgIFwiYmxtcG9wXCIsXG4gICAgICAgIFwieHJlYWRcIixcbiAgICAgICAgXCJ4cmVhZGdyb3VwXCIsXG4gICAgXSxcbiAgICBMQVNUX0FSR19USU1FT1VUX0NPTU1BTkRTOiBbXG4gICAgICAgIFwiYmxwb3BcIixcbiAgICAgICAgXCJicnBvcFwiLFxuICAgICAgICBcImJycG9wbHB1c2hcIixcbiAgICAgICAgXCJibG1vdmVcIixcbiAgICAgICAgXCJienBvcG1pblwiLFxuICAgICAgICBcImJ6cG9wbWF4XCIsXG4gICAgXSxcbiAgICBGSVJTVF9BUkdfVElNRU9VVF9DT01NQU5EUzogW1wiYnptcG9wXCIsIFwiYmxtcG9wXCJdLFxuICAgIEJMT0NLX09QVElPTl9DT01NQU5EUzogW1wieHJlYWRcIiwgXCJ4cmVhZGdyb3VwXCJdLFxufTtcbkNvbW1hbmQuX3RyYW5zZm9ybWVyID0ge1xuICAgIGFyZ3VtZW50OiB7fSxcbiAgICByZXBseToge30sXG59O1xuY29uc3QgbXNldEFyZ3VtZW50VHJhbnNmb3JtZXIgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbnZlcnRNYXBUb0FycmF5KShhcmdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwib2JqZWN0XCIgJiYgYXJnc1swXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbnZlcnRPYmplY3RUb0FycmF5KShhcmdzWzBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJncztcbn07XG5jb25zdCBoc2V0QXJndW1lbnRUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGlmIChhcmdzWzFdIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gW2FyZ3NbMF1dLmNvbmNhdCgoMCwgdXRpbHNfMS5jb252ZXJ0TWFwVG9BcnJheSkoYXJnc1sxXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gXCJvYmplY3RcIiAmJiBhcmdzWzFdICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW2FyZ3NbMF1dLmNvbmNhdCgoMCwgdXRpbHNfMS5jb252ZXJ0T2JqZWN0VG9BcnJheSkoYXJnc1sxXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xufTtcbkNvbW1hbmQuc2V0QXJndW1lbnRUcmFuc2Zvcm1lcihcIm1zZXRcIiwgbXNldEFyZ3VtZW50VHJhbnNmb3JtZXIpO1xuQ29tbWFuZC5zZXRBcmd1bWVudFRyYW5zZm9ybWVyKFwibXNldG54XCIsIG1zZXRBcmd1bWVudFRyYW5zZm9ybWVyKTtcbkNvbW1hbmQuc2V0QXJndW1lbnRUcmFuc2Zvcm1lcihcImhzZXRcIiwgaHNldEFyZ3VtZW50VHJhbnNmb3JtZXIpO1xuQ29tbWFuZC5zZXRBcmd1bWVudFRyYW5zZm9ybWVyKFwiaG1zZXRcIiwgaHNldEFyZ3VtZW50VHJhbnNmb3JtZXIpO1xuQ29tbWFuZC5zZXRSZXBseVRyYW5zZm9ybWVyKFwiaGdldGFsbFwiLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHJlc3VsdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdWx0W2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuIG9ubHkgYmUgdHJ1dGh5IGlmIHRoZSBwcm9wZXJ0eSBpcyBzcGVjaWFsIHNvbWVob3csIGxpa2UgJ19fcHJvdG9fXycgb3IgJ2NvbnN0cnVjdG9yJ1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sdWluL2lvcmVkaXMvaXNzdWVzLzEyNjdcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59KTtcbmNsYXNzIE1peGVkQnVmZmVycyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIH1cbiAgICBwdXNoKHgpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgoeCk7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCh4KTtcbiAgICB9XG4gICAgdG9CdWZmZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0aGlzLmxlbmd0aCk7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoaXRlbSk7XG4gICAgICAgICAgICBCdWZmZXIuaXNCdWZmZXIoaXRlbSlcbiAgICAgICAgICAgICAgICA/IGl0ZW0uY29weShyZXN1bHQsIG9mZnNldClcbiAgICAgICAgICAgICAgICA6IHJlc3VsdC53cml0ZShpdGVtLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY29tbWFuZHNfMSIsInJlcXVpcmUiLCJjYWxjdWxhdGVTbG90Iiwic3RhbmRhcmRfYXNfY2FsbGJhY2tfMSIsInV0aWxzXzEiLCJhcmd1bWVudFBhcnNlcnNfMSIsIkNvbW1hbmQiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJhcmdzIiwib3B0aW9ucyIsImNhbGxiYWNrIiwiaW5UcmFuc2FjdGlvbiIsImlzUmVzb2x2ZWQiLCJ0cmFuc2Zvcm1lZCIsInJlcGx5RW5jb2RpbmciLCJlcnJvclN0YWNrIiwiZmxhdCIsImluaXRQcm9taXNlIiwia2V5UHJlZml4IiwiaXNCdWZmZXJLZXlQcmVmaXgiLCJCdWZmZXIiLCJrZXlQcmVmaXhCdWZmZXIiLCJfaXRlcmF0ZUtleXMiLCJrZXkiLCJmcm9tIiwiY29uY2F0IiwiU3RyaW5nIiwicmVhZE9ubHkiLCJpc1JlYWRPbmx5IiwiY2hlY2tGbGFnIiwiZmxhZ05hbWUiLCJjb21tYW5kTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0RmxhZ01hcCIsInNldEFyZ3VtZW50VHJhbnNmb3JtZXIiLCJmdW5jIiwiX3RyYW5zZm9ybWVyIiwiYXJndW1lbnQiLCJzZXRSZXBseVRyYW5zZm9ybWVyIiwicmVwbHkiLCJmbGFnTWFwIiwia2V5cyIsIkZMQUdTIiwicmVkdWNlIiwibWFwIiwiZm9yRWFjaCIsImdldFNsb3QiLCJzbG90IiwiZ2V0S2V5cyIsInRvV3JpdGFibGUiLCJfc29ja2V0IiwicmVzdWx0IiwiY29tbWFuZFN0ciIsImxlbmd0aCIsImJ5dGVMZW5ndGgiLCJidWZmZXJNb2RlIiwiYnVmZmVycyIsIk1peGVkQnVmZmVycyIsInB1c2giLCJpIiwiYXJnIiwidG9CdWZmZXIiLCJzdHJpbmdpZnlBcmd1bWVudHMiLCJ0b0FyZyIsInRyYW5zZm9ybVJlcGx5IiwiY29udmVydEJ1ZmZlclRvU3RyaW5nIiwidHJhbnNmb3JtZXIiLCJzZXRUaW1lb3V0IiwibXMiLCJfY29tbWFuZFRpbWVvdXRUaW1lciIsInJlamVjdCIsIkVycm9yIiwic2V0QmxvY2tpbmdUaW1lb3V0IiwiX2Jsb2NraW5nVGltZW91dFRpbWVyIiwiY2xlYXJUaW1lb3V0IiwidW5kZWZpbmVkIiwibm93IiwiRGF0ZSIsIl9ibG9ja2luZ0RlYWRsaW5lIiwicmVtYWluaW5nIiwicmVzb2x2ZSIsImV4dHJhY3RCbG9ja2luZ1RpbWVvdXQiLCJwYXJzZVNlY29uZHNBcmd1bWVudCIsInBhcnNlQmxvY2tPcHRpb24iLCJfY2xlYXJUaW1lcnMiLCJleGlzdGluZ1RpbWVyIiwiYmxvY2tpbmdUaW1lciIsInByb21pc2UiLCJQcm9taXNlIiwiX2NvbnZlcnRWYWx1ZSIsImVyciIsIm9wdGltaXplRXJyb3JTdGFjayIsInN0YWNrIiwiX19kaXJuYW1lIiwiZGVmYXVsdCIsInRyYW5zZm9ybSIsImV4aXN0cyIsImNhc2VJbnNlbnNpdGl2ZSIsImtleUluZGV4ZXMiLCJnZXRLZXlJbmRleGVzIiwibmFtZUNhc2VJbnNlbnNpdGl2ZSIsImluZGV4IiwiVkFMSURfSU5fU1VCU0NSSUJFUl9NT0RFIiwiVkFMSURfSU5fTU9OSVRPUl9NT0RFIiwiRU5URVJfU1VCU0NSSUJFUl9NT0RFIiwiRVhJVF9TVUJTQ1JJQkVSX01PREUiLCJXSUxMX0RJU0NPTk5FQ1QiLCJIQU5EU0hBS0VfQ09NTUFORFMiLCJJR05PUkVfUkVDT05ORUNUX09OX0VSUk9SIiwiQkxPQ0tJTkdfQ09NTUFORFMiLCJMQVNUX0FSR19USU1FT1VUX0NPTU1BTkRTIiwiRklSU1RfQVJHX1RJTUVPVVRfQ09NTUFORFMiLCJCTE9DS19PUFRJT05fQ09NTUFORFMiLCJtc2V0QXJndW1lbnRUcmFuc2Zvcm1lciIsIk1hcCIsImNvbnZlcnRNYXBUb0FycmF5IiwiY29udmVydE9iamVjdFRvQXJyYXkiLCJoc2V0QXJndW1lbnRUcmFuc2Zvcm1lciIsIkFycmF5IiwiaXNBcnJheSIsIm9iaiIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIml0ZW1zIiwieCIsImFsbG9jVW5zYWZlIiwib2Zmc2V0IiwiaXRlbSIsImlzQnVmZmVyIiwiY29weSIsIndyaXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/Command.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/DataHandler.js":
/*!***************************************************!*\
  !*** ./node_modules/ioredis/built/DataHandler.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst RedisParser = __webpack_require__(/*! redis-parser */ \"(rsc)/./node_modules/redis-parser/index.js\");\nconst SubscriptionSet_1 = __webpack_require__(/*! ./SubscriptionSet */ \"(rsc)/./node_modules/ioredis/built/SubscriptionSet.js\");\nconst debug = (0, utils_1.Debug)(\"dataHandler\");\nclass DataHandler {\n    constructor(redis, parserOptions){\n        this.redis = redis;\n        const parser = new RedisParser({\n            stringNumbers: parserOptions.stringNumbers,\n            returnBuffers: true,\n            returnError: (err)=>{\n                this.returnError(err);\n            },\n            returnFatalError: (err)=>{\n                this.returnFatalError(err);\n            },\n            returnReply: (reply)=>{\n                this.returnReply(reply);\n            }\n        });\n        // prependListener ensures the parser receives and processes data before socket timeout checks are performed\n        redis.stream.prependListener(\"data\", (data)=>{\n            parser.execute(data);\n        });\n        // prependListener() doesn't enable flowing mode automatically - we need to resume the stream manually\n        redis.stream.resume();\n    }\n    returnFatalError(err) {\n        err.message += \". Please report this.\";\n        this.redis.recoverFromFatalError(err, err, {\n            offlineQueue: false\n        });\n    }\n    returnError(err) {\n        const item = this.shiftCommand(err);\n        if (!item) {\n            return;\n        }\n        err.command = {\n            name: item.command.name,\n            args: item.command.args\n        };\n        if (item.command.name == \"ssubscribe\" && err.message.includes(\"MOVED\")) {\n            this.redis.emit(\"moved\");\n            return;\n        }\n        this.redis.handleReconnection(err, item);\n    }\n    returnReply(reply) {\n        if (this.handleMonitorReply(reply)) {\n            return;\n        }\n        if (this.handleSubscriberReply(reply)) {\n            return;\n        }\n        const item = this.shiftCommand(reply);\n        if (!item) {\n            return;\n        }\n        if (Command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", item.command.name)) {\n            this.redis.condition.subscriber = new SubscriptionSet_1.default();\n            this.redis.condition.subscriber.add(item.command.name, reply[1].toString());\n            if (!fillSubCommand(item.command, reply[2])) {\n                this.redis.commandQueue.unshift(item);\n            }\n        } else if (Command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", item.command.name)) {\n            if (!fillUnsubCommand(item.command, reply[2])) {\n                this.redis.commandQueue.unshift(item);\n            }\n        } else {\n            item.command.resolve(reply);\n        }\n    }\n    handleSubscriberReply(reply) {\n        if (!this.redis.condition.subscriber) {\n            return false;\n        }\n        const replyType = Array.isArray(reply) ? reply[0].toString() : null;\n        debug('receive reply \"%s\" in subscriber mode', replyType);\n        switch(replyType){\n            case \"message\":\n                if (this.redis.listeners(\"message\").length > 0) {\n                    // Check if there're listeners to avoid unnecessary `toString()`.\n                    this.redis.emit(\"message\", reply[1].toString(), reply[2] ? reply[2].toString() : \"\");\n                }\n                this.redis.emit(\"messageBuffer\", reply[1], reply[2]);\n                break;\n            case \"pmessage\":\n                {\n                    const pattern = reply[1].toString();\n                    if (this.redis.listeners(\"pmessage\").length > 0) {\n                        this.redis.emit(\"pmessage\", pattern, reply[2].toString(), reply[3].toString());\n                    }\n                    this.redis.emit(\"pmessageBuffer\", pattern, reply[2], reply[3]);\n                    break;\n                }\n            case \"smessage\":\n                {\n                    if (this.redis.listeners(\"smessage\").length > 0) {\n                        this.redis.emit(\"smessage\", reply[1].toString(), reply[2] ? reply[2].toString() : \"\");\n                    }\n                    this.redis.emit(\"smessageBuffer\", reply[1], reply[2]);\n                    break;\n                }\n            case \"ssubscribe\":\n            case \"subscribe\":\n            case \"psubscribe\":\n                {\n                    const channel = reply[1].toString();\n                    this.redis.condition.subscriber.add(replyType, channel);\n                    const item = this.shiftCommand(reply);\n                    if (!item) {\n                        return;\n                    }\n                    if (!fillSubCommand(item.command, reply[2])) {\n                        this.redis.commandQueue.unshift(item);\n                    }\n                    break;\n                }\n            case \"sunsubscribe\":\n            case \"unsubscribe\":\n            case \"punsubscribe\":\n                {\n                    const channel = reply[1] ? reply[1].toString() : null;\n                    if (channel) {\n                        this.redis.condition.subscriber.del(replyType, channel);\n                    }\n                    const count = reply[2];\n                    if (Number(count) === 0) {\n                        this.redis.condition.subscriber = false;\n                    }\n                    const item = this.shiftCommand(reply);\n                    if (!item) {\n                        return;\n                    }\n                    if (!fillUnsubCommand(item.command, count)) {\n                        this.redis.commandQueue.unshift(item);\n                    }\n                    break;\n                }\n            default:\n                {\n                    const item = this.shiftCommand(reply);\n                    if (!item) {\n                        return;\n                    }\n                    item.command.resolve(reply);\n                }\n        }\n        return true;\n    }\n    handleMonitorReply(reply) {\n        if (this.redis.status !== \"monitoring\") {\n            return false;\n        }\n        const replyStr = reply.toString();\n        if (replyStr === \"OK\") {\n            // Valid commands in the monitoring mode are AUTH and MONITOR,\n            // both of which always reply with 'OK'.\n            // So if we got an 'OK', we can make certain that\n            // the reply is made to AUTH & MONITOR.\n            return false;\n        }\n        // Since commands sent in the monitoring mode will trigger an exception,\n        // any replies we received in the monitoring mode should consider to be\n        // realtime monitor data instead of result of commands.\n        const len = replyStr.indexOf(\" \");\n        const timestamp = replyStr.slice(0, len);\n        const argIndex = replyStr.indexOf('\"');\n        const args = replyStr.slice(argIndex + 1, -1).split('\" \"').map((elem)=>elem.replace(/\\\\\"/g, '\"'));\n        const dbAndSource = replyStr.slice(len + 2, argIndex - 2).split(\" \");\n        this.redis.emit(\"monitor\", timestamp, args, dbAndSource[1], dbAndSource[0]);\n        return true;\n    }\n    shiftCommand(reply) {\n        const item = this.redis.commandQueue.shift();\n        if (!item) {\n            const message = \"Command queue state error. If you can reproduce this, please report it.\";\n            const error = new Error(message + (reply instanceof Error ? ` Last error: ${reply.message}` : ` Last reply: ${reply.toString()}`));\n            this.redis.emit(\"error\", error);\n            return null;\n        }\n        return item;\n    }\n}\nexports[\"default\"] = DataHandler;\nconst remainingRepliesMap = new WeakMap();\nfunction fillSubCommand(command, count) {\n    let remainingReplies = remainingRepliesMap.has(command) ? remainingRepliesMap.get(command) : command.args.length;\n    remainingReplies -= 1;\n    if (remainingReplies <= 0) {\n        command.resolve(count);\n        remainingRepliesMap.delete(command);\n        return true;\n    }\n    remainingRepliesMap.set(command, remainingReplies);\n    return false;\n}\nfunction fillUnsubCommand(command, count) {\n    let remainingReplies = remainingRepliesMap.has(command) ? remainingRepliesMap.get(command) : command.args.length;\n    if (remainingReplies === 0) {\n        if (Number(count) === 0) {\n            remainingRepliesMap.delete(command);\n            command.resolve(count);\n            return true;\n        }\n        return false;\n    }\n    remainingReplies -= 1;\n    if (remainingReplies <= 0) {\n        command.resolve(count);\n        return true;\n    }\n    remainingRepliesMap.set(command, remainingReplies);\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9EYXRhSGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxZQUFZQyxtQkFBT0EsQ0FBQyxnRUFBVztBQUNyQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyxrRUFBUztBQUNqQyxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyxnRUFBYztBQUMxQyxNQUFNRyxvQkFBb0JILG1CQUFPQSxDQUFDLGdGQUFtQjtBQUNyRCxNQUFNSSxRQUFRLENBQUMsR0FBR0gsUUFBUUksS0FBSyxFQUFFO0FBQ2pDLE1BQU1DO0lBQ0ZDLFlBQVlDLEtBQUssRUFBRUMsYUFBYSxDQUFFO1FBQzlCLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNiLE1BQU1FLFNBQVMsSUFBSVIsWUFBWTtZQUMzQlMsZUFBZUYsY0FBY0UsYUFBYTtZQUMxQ0MsZUFBZTtZQUNmQyxhQUFhLENBQUNDO2dCQUNWLElBQUksQ0FBQ0QsV0FBVyxDQUFDQztZQUNyQjtZQUNBQyxrQkFBa0IsQ0FBQ0Q7Z0JBQ2YsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0Q7WUFDMUI7WUFDQUUsYUFBYSxDQUFDQztnQkFDVixJQUFJLENBQUNELFdBQVcsQ0FBQ0M7WUFDckI7UUFDSjtRQUNBLDRHQUE0RztRQUM1R1QsTUFBTVUsTUFBTSxDQUFDQyxlQUFlLENBQUMsUUFBUSxDQUFDQztZQUNsQ1YsT0FBT1csT0FBTyxDQUFDRDtRQUNuQjtRQUNBLHNHQUFzRztRQUN0R1osTUFBTVUsTUFBTSxDQUFDSSxNQUFNO0lBQ3ZCO0lBQ0FQLGlCQUFpQkQsR0FBRyxFQUFFO1FBQ2xCQSxJQUFJUyxPQUFPLElBQUk7UUFDZixJQUFJLENBQUNmLEtBQUssQ0FBQ2dCLHFCQUFxQixDQUFDVixLQUFLQSxLQUFLO1lBQUVXLGNBQWM7UUFBTTtJQUNyRTtJQUNBWixZQUFZQyxHQUFHLEVBQUU7UUFDYixN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LEVBQUUyQixLQUFLO0lBQ2xDLElBQUltQixtQkFBbUJGLG9CQUFvQkcsR0FBRyxDQUFDL0MsV0FDekM0QyxvQkFBb0JJLEdBQUcsQ0FBQ2hELFdBQ3hCQSxRQUFRRSxJQUFJLENBQUNxQixNQUFNO0lBQ3pCdUIsb0JBQW9CO0lBQ3BCLElBQUlBLG9CQUFvQixHQUFHO1FBQ3ZCOUMsUUFBUWtCLE9BQU8sQ0FBQ1M7UUFDaEJpQixvQkFBb0JLLE1BQU0sQ0FBQ2pEO1FBQzNCLE9BQU87SUFDWDtJQUNBNEMsb0JBQW9CTSxHQUFHLENBQUNsRCxTQUFTOEM7SUFDakMsT0FBTztBQUNYO0FBQ0EsU0FBUzdCLGlCQUFpQmpCLE9BQU8sRUFBRTJCLEtBQUs7SUFDcEMsSUFBSW1CLG1CQUFtQkYsb0JBQW9CRyxHQUFHLENBQUMvQyxXQUN6QzRDLG9CQUFvQkksR0FBRyxDQUFDaEQsV0FDeEJBLFFBQVFFLElBQUksQ0FBQ3FCLE1BQU07SUFDekIsSUFBSXVCLHFCQUFxQixHQUFHO1FBQ3hCLElBQUlsQixPQUFPRCxXQUFXLEdBQUc7WUFDckJpQixvQkFBb0JLLE1BQU0sQ0FBQ2pEO1lBQzNCQSxRQUFRa0IsT0FBTyxDQUFDUztZQUNoQixPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQW1CLG9CQUFvQjtJQUNwQixJQUFJQSxvQkFBb0IsR0FBRztRQUN2QjlDLFFBQVFrQixPQUFPLENBQUNTO1FBQ2hCLE9BQU87SUFDWDtJQUNBaUIsb0JBQW9CTSxHQUFHLENBQUNsRCxTQUFTOEM7SUFDakMsT0FBTztBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvZHVjdC1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9EYXRhSGFuZGxlci5qcz9lMzg2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29tbWFuZFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IFJlZGlzUGFyc2VyID0gcmVxdWlyZShcInJlZGlzLXBhcnNlclwiKTtcbmNvbnN0IFN1YnNjcmlwdGlvblNldF8xID0gcmVxdWlyZShcIi4vU3Vic2NyaXB0aW9uU2V0XCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJkYXRhSGFuZGxlclwiKTtcbmNsYXNzIERhdGFIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZWRpcywgcGFyc2VyT3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlZGlzID0gcmVkaXM7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBSZWRpc1BhcnNlcih7XG4gICAgICAgICAgICBzdHJpbmdOdW1iZXJzOiBwYXJzZXJPcHRpb25zLnN0cmluZ051bWJlcnMsXG4gICAgICAgICAgICByZXR1cm5CdWZmZXJzOiB0cnVlLFxuICAgICAgICAgICAgcmV0dXJuRXJyb3I6IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVybkVycm9yKGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0dXJuRmF0YWxFcnJvcjogKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuRmF0YWxFcnJvcihlcnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHVyblJlcGx5OiAocmVwbHkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVyblJlcGx5KHJlcGx5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBwcmVwZW5kTGlzdGVuZXIgZW5zdXJlcyB0aGUgcGFyc2VyIHJlY2VpdmVzIGFuZCBwcm9jZXNzZXMgZGF0YSBiZWZvcmUgc29ja2V0IHRpbWVvdXQgY2hlY2tzIGFyZSBwZXJmb3JtZWRcbiAgICAgICAgcmVkaXMuc3RyZWFtLnByZXBlbmRMaXN0ZW5lcihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHBhcnNlci5leGVjdXRlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcHJlcGVuZExpc3RlbmVyKCkgZG9lc24ndCBlbmFibGUgZmxvd2luZyBtb2RlIGF1dG9tYXRpY2FsbHkgLSB3ZSBuZWVkIHRvIHJlc3VtZSB0aGUgc3RyZWFtIG1hbnVhbGx5XG4gICAgICAgIHJlZGlzLnN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gICAgcmV0dXJuRmF0YWxFcnJvcihlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgKz0gXCIuIFBsZWFzZSByZXBvcnQgdGhpcy5cIjtcbiAgICAgICAgdGhpcy5yZWRpcy5yZWNvdmVyRnJvbUZhdGFsRXJyb3IoZXJyLCBlcnIsIHsgb2ZmbGluZVF1ZXVlOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuRXJyb3IoZXJyKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLnNoaWZ0Q29tbWFuZChlcnIpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlcnIuY29tbWFuZCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGl0ZW0uY29tbWFuZC5uYW1lLFxuICAgICAgICAgICAgYXJnczogaXRlbS5jb21tYW5kLmFyZ3MsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpdGVtLmNvbW1hbmQubmFtZSA9PSBcInNzdWJzY3JpYmVcIiAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcyhcIk1PVkVEXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnJlZGlzLmVtaXQoXCJtb3ZlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZGlzLmhhbmRsZVJlY29ubmVjdGlvbihlcnIsIGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm5SZXBseShyZXBseSkge1xuICAgICAgICBpZiAodGhpcy5oYW5kbGVNb25pdG9yUmVwbHkocmVwbHkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlU3Vic2NyaWJlclJlcGx5KHJlcGx5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLnNoaWZ0Q29tbWFuZChyZXBseSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDb21tYW5kXzEuZGVmYXVsdC5jaGVja0ZsYWcoXCJFTlRFUl9TVUJTQ1JJQkVSX01PREVcIiwgaXRlbS5jb21tYW5kLm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlZGlzLmNvbmRpdGlvbi5zdWJzY3JpYmVyID0gbmV3IFN1YnNjcmlwdGlvblNldF8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMucmVkaXMuY29uZGl0aW9uLnN1YnNjcmliZXIuYWRkKGl0ZW0uY29tbWFuZC5uYW1lLCByZXBseVsxXS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmICghZmlsbFN1YkNvbW1hbmQoaXRlbS5jb21tYW5kLCByZXBseVsyXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmNvbW1hbmRRdWV1ZS51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIkVYSVRfU1VCU0NSSUJFUl9NT0RFXCIsIGl0ZW0uY29tbWFuZC5uYW1lKSkge1xuICAgICAgICAgICAgaWYgKCFmaWxsVW5zdWJDb21tYW5kKGl0ZW0uY29tbWFuZCwgcmVwbHlbMl0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5jb21tYW5kUXVldWUudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5yZXNvbHZlKHJlcGx5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVTdWJzY3JpYmVyUmVwbHkocmVwbHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZGlzLmNvbmRpdGlvbi5zdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVwbHlUeXBlID0gQXJyYXkuaXNBcnJheShyZXBseSkgPyByZXBseVswXS50b1N0cmluZygpIDogbnVsbDtcbiAgICAgICAgZGVidWcoJ3JlY2VpdmUgcmVwbHkgXCIlc1wiIGluIHN1YnNjcmliZXIgbW9kZScsIHJlcGx5VHlwZSk7XG4gICAgICAgIHN3aXRjaCAocmVwbHlUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZGlzLmxpc3RlbmVycyhcIm1lc3NhZ2VcIikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdyZSBsaXN0ZW5lcnMgdG8gYXZvaWQgdW5uZWNlc3NhcnkgYHRvU3RyaW5nKClgLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmVtaXQoXCJtZXNzYWdlXCIsIHJlcGx5WzFdLnRvU3RyaW5nKCksIHJlcGx5WzJdID8gcmVwbHlbMl0udG9TdHJpbmcoKSA6IFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmVtaXQoXCJtZXNzYWdlQnVmZmVyXCIsIHJlcGx5WzFdLCByZXBseVsyXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicG1lc3NhZ2VcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSByZXBseVsxXS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZGlzLmxpc3RlbmVycyhcInBtZXNzYWdlXCIpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5lbWl0KFwicG1lc3NhZ2VcIiwgcGF0dGVybiwgcmVwbHlbMl0udG9TdHJpbmcoKSwgcmVwbHlbM10udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuZW1pdChcInBtZXNzYWdlQnVmZmVyXCIsIHBhdHRlcm4sIHJlcGx5WzJdLCByZXBseVszXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic21lc3NhZ2VcIjoge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZGlzLmxpc3RlbmVycyhcInNtZXNzYWdlXCIpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5lbWl0KFwic21lc3NhZ2VcIiwgcmVwbHlbMV0udG9TdHJpbmcoKSwgcmVwbHlbMl0gPyByZXBseVsyXS50b1N0cmluZygpIDogXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuZW1pdChcInNtZXNzYWdlQnVmZmVyXCIsIHJlcGx5WzFdLCByZXBseVsyXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3N1YnNjcmliZVwiOlxuICAgICAgICAgICAgY2FzZSBcInN1YnNjcmliZVwiOlxuICAgICAgICAgICAgY2FzZSBcInBzdWJzY3JpYmVcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSByZXBseVsxXS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuY29uZGl0aW9uLnN1YnNjcmliZXIuYWRkKHJlcGx5VHlwZSwgY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuc2hpZnRDb21tYW5kKHJlcGx5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxTdWJDb21tYW5kKGl0ZW0uY29tbWFuZCwgcmVwbHlbMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuY29tbWFuZFF1ZXVlLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInN1bnN1YnNjcmliZVwiOlxuICAgICAgICAgICAgY2FzZSBcInVuc3Vic2NyaWJlXCI6XG4gICAgICAgICAgICBjYXNlIFwicHVuc3Vic2NyaWJlXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gcmVwbHlbMV0gPyByZXBseVsxXS50b1N0cmluZygpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmNvbmRpdGlvbi5zdWJzY3JpYmVyLmRlbChyZXBseVR5cGUsIGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IHJlcGx5WzJdO1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIoY291bnQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuY29uZGl0aW9uLnN1YnNjcmliZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuc2hpZnRDb21tYW5kKHJlcGx5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxVbnN1YkNvbW1hbmQoaXRlbS5jb21tYW5kLCBjb3VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5jb21tYW5kUXVldWUudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuc2hpZnRDb21tYW5kKHJlcGx5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtLmNvbW1hbmQucmVzb2x2ZShyZXBseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGhhbmRsZU1vbml0b3JSZXBseShyZXBseSkge1xuICAgICAgICBpZiAodGhpcy5yZWRpcy5zdGF0dXMgIT09IFwibW9uaXRvcmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVwbHlTdHIgPSByZXBseS50b1N0cmluZygpO1xuICAgICAgICBpZiAocmVwbHlTdHIgPT09IFwiT0tcIikge1xuICAgICAgICAgICAgLy8gVmFsaWQgY29tbWFuZHMgaW4gdGhlIG1vbml0b3JpbmcgbW9kZSBhcmUgQVVUSCBhbmQgTU9OSVRPUixcbiAgICAgICAgICAgIC8vIGJvdGggb2Ygd2hpY2ggYWx3YXlzIHJlcGx5IHdpdGggJ09LJy5cbiAgICAgICAgICAgIC8vIFNvIGlmIHdlIGdvdCBhbiAnT0snLCB3ZSBjYW4gbWFrZSBjZXJ0YWluIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSByZXBseSBpcyBtYWRlIHRvIEFVVEggJiBNT05JVE9SLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIGNvbW1hbmRzIHNlbnQgaW4gdGhlIG1vbml0b3JpbmcgbW9kZSB3aWxsIHRyaWdnZXIgYW4gZXhjZXB0aW9uLFxuICAgICAgICAvLyBhbnkgcmVwbGllcyB3ZSByZWNlaXZlZCBpbiB0aGUgbW9uaXRvcmluZyBtb2RlIHNob3VsZCBjb25zaWRlciB0byBiZVxuICAgICAgICAvLyByZWFsdGltZSBtb25pdG9yIGRhdGEgaW5zdGVhZCBvZiByZXN1bHQgb2YgY29tbWFuZHMuXG4gICAgICAgIGNvbnN0IGxlbiA9IHJlcGx5U3RyLmluZGV4T2YoXCIgXCIpO1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSByZXBseVN0ci5zbGljZSgwLCBsZW4pO1xuICAgICAgICBjb25zdCBhcmdJbmRleCA9IHJlcGx5U3RyLmluZGV4T2YoJ1wiJyk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSByZXBseVN0clxuICAgICAgICAgICAgLnNsaWNlKGFyZ0luZGV4ICsgMSwgLTEpXG4gICAgICAgICAgICAuc3BsaXQoJ1wiIFwiJylcbiAgICAgICAgICAgIC5tYXAoKGVsZW0pID0+IGVsZW0ucmVwbGFjZSgvXFxcXFwiL2csICdcIicpKTtcbiAgICAgICAgY29uc3QgZGJBbmRTb3VyY2UgPSByZXBseVN0ci5zbGljZShsZW4gKyAyLCBhcmdJbmRleCAtIDIpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgdGhpcy5yZWRpcy5lbWl0KFwibW9uaXRvclwiLCB0aW1lc3RhbXAsIGFyZ3MsIGRiQW5kU291cmNlWzFdLCBkYkFuZFNvdXJjZVswXSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzaGlmdENvbW1hbmQocmVwbHkpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMucmVkaXMuY29tbWFuZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwiQ29tbWFuZCBxdWV1ZSBzdGF0ZSBlcnJvci4gSWYgeW91IGNhbiByZXByb2R1Y2UgdGhpcywgcGxlYXNlIHJlcG9ydCBpdC5cIjtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UgK1xuICAgICAgICAgICAgICAgIChyZXBseSBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgICAgICAgICAgID8gYCBMYXN0IGVycm9yOiAke3JlcGx5Lm1lc3NhZ2V9YFxuICAgICAgICAgICAgICAgICAgICA6IGAgTGFzdCByZXBseTogJHtyZXBseS50b1N0cmluZygpfWApKTtcbiAgICAgICAgICAgIHRoaXMucmVkaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERhdGFIYW5kbGVyO1xuY29uc3QgcmVtYWluaW5nUmVwbGllc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBmaWxsU3ViQ29tbWFuZChjb21tYW5kLCBjb3VudCkge1xuICAgIGxldCByZW1haW5pbmdSZXBsaWVzID0gcmVtYWluaW5nUmVwbGllc01hcC5oYXMoY29tbWFuZClcbiAgICAgICAgPyByZW1haW5pbmdSZXBsaWVzTWFwLmdldChjb21tYW5kKVxuICAgICAgICA6IGNvbW1hbmQuYXJncy5sZW5ndGg7XG4gICAgcmVtYWluaW5nUmVwbGllcyAtPSAxO1xuICAgIGlmIChyZW1haW5pbmdSZXBsaWVzIDw9IDApIHtcbiAgICAgICAgY29tbWFuZC5yZXNvbHZlKGNvdW50KTtcbiAgICAgICAgcmVtYWluaW5nUmVwbGllc01hcC5kZWxldGUoY29tbWFuZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZW1haW5pbmdSZXBsaWVzTWFwLnNldChjb21tYW5kLCByZW1haW5pbmdSZXBsaWVzKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBmaWxsVW5zdWJDb21tYW5kKGNvbW1hbmQsIGNvdW50KSB7XG4gICAgbGV0IHJlbWFpbmluZ1JlcGxpZXMgPSByZW1haW5pbmdSZXBsaWVzTWFwLmhhcyhjb21tYW5kKVxuICAgICAgICA/IHJlbWFpbmluZ1JlcGxpZXNNYXAuZ2V0KGNvbW1hbmQpXG4gICAgICAgIDogY29tbWFuZC5hcmdzLmxlbmd0aDtcbiAgICBpZiAocmVtYWluaW5nUmVwbGllcyA9PT0gMCkge1xuICAgICAgICBpZiAoTnVtYmVyKGNvdW50KSA9PT0gMCkge1xuICAgICAgICAgICAgcmVtYWluaW5nUmVwbGllc01hcC5kZWxldGUoY29tbWFuZCk7XG4gICAgICAgICAgICBjb21tYW5kLnJlc29sdmUoY291bnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZW1haW5pbmdSZXBsaWVzIC09IDE7XG4gICAgaWYgKHJlbWFpbmluZ1JlcGxpZXMgPD0gMCkge1xuICAgICAgICBjb21tYW5kLnJlc29sdmUoY291bnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVtYWluaW5nUmVwbGllc01hcC5zZXQoY29tbWFuZCwgcmVtYWluaW5nUmVwbGllcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ29tbWFuZF8xIiwicmVxdWlyZSIsInV0aWxzXzEiLCJSZWRpc1BhcnNlciIsIlN1YnNjcmlwdGlvblNldF8xIiwiZGVidWciLCJEZWJ1ZyIsIkRhdGFIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJyZWRpcyIsInBhcnNlck9wdGlvbnMiLCJwYXJzZXIiLCJzdHJpbmdOdW1iZXJzIiwicmV0dXJuQnVmZmVycyIsInJldHVybkVycm9yIiwiZXJyIiwicmV0dXJuRmF0YWxFcnJvciIsInJldHVyblJlcGx5IiwicmVwbHkiLCJzdHJlYW0iLCJwcmVwZW5kTGlzdGVuZXIiLCJkYXRhIiwiZXhlY3V0ZSIsInJlc3VtZSIsIm1lc3NhZ2UiLCJyZWNvdmVyRnJvbUZhdGFsRXJyb3IiLCJvZmZsaW5lUXVldWUiLCJpdGVtIiwic2hpZnRDb21tYW5kIiwiY29tbWFuZCIsIm5hbWUiLCJhcmdzIiwiaW5jbHVkZXMiLCJlbWl0IiwiaGFuZGxlUmVjb25uZWN0aW9uIiwiaGFuZGxlTW9uaXRvclJlcGx5IiwiaGFuZGxlU3Vic2NyaWJlclJlcGx5IiwiZGVmYXVsdCIsImNoZWNrRmxhZyIsImNvbmRpdGlvbiIsInN1YnNjcmliZXIiLCJhZGQiLCJ0b1N0cmluZyIsImZpbGxTdWJDb21tYW5kIiwiY29tbWFuZFF1ZXVlIiwidW5zaGlmdCIsImZpbGxVbnN1YkNvbW1hbmQiLCJyZXNvbHZlIiwicmVwbHlUeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwibGlzdGVuZXJzIiwibGVuZ3RoIiwicGF0dGVybiIsImNoYW5uZWwiLCJkZWwiLCJjb3VudCIsIk51bWJlciIsInN0YXR1cyIsInJlcGx5U3RyIiwibGVuIiwiaW5kZXhPZiIsInRpbWVzdGFtcCIsInNsaWNlIiwiYXJnSW5kZXgiLCJzcGxpdCIsIm1hcCIsImVsZW0iLCJyZXBsYWNlIiwiZGJBbmRTb3VyY2UiLCJzaGlmdCIsImVycm9yIiwiRXJyb3IiLCJyZW1haW5pbmdSZXBsaWVzTWFwIiwiV2Vha01hcCIsInJlbWFpbmluZ1JlcGxpZXMiLCJoYXMiLCJnZXQiLCJkZWxldGUiLCJzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/DataHandler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/Pipeline.js":
/*!************************************************!*\
  !*** ./node_modules/ioredis/built/Pipeline.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/./node_modules/cluster-key-slot/lib/index.js\");\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst Commander_1 = __webpack_require__(/*! ./utils/Commander */ \"(rsc)/./node_modules/ioredis/built/utils/Commander.js\");\n/*\n  This function derives from the cluster-key-slot implementation.\n  Instead of checking that all keys have the same slot, it checks that all slots are served by the same set of nodes.\n  If this is satisfied, it returns the first key's slot.\n*/ function generateMultiWithNodes(redis, keys) {\n    const slot = calculateSlot(keys[0]);\n    const target = redis._groupsBySlot[slot];\n    for(let i = 1; i < keys.length; i++){\n        if (redis._groupsBySlot[calculateSlot(keys[i])] !== target) {\n            return -1;\n        }\n    }\n    return slot;\n}\nclass Pipeline extends Commander_1.default {\n    constructor(redis){\n        super();\n        this.redis = redis;\n        this.isPipeline = true;\n        this.replyPending = 0;\n        this._queue = [];\n        this._result = [];\n        this._transactions = 0;\n        this._shaToScript = {};\n        this.isCluster = this.redis.constructor.name === \"Cluster\" || this.redis.isCluster;\n        this.options = redis.options;\n        Object.keys(redis.scriptsSet).forEach((name)=>{\n            const script = redis.scriptsSet[name];\n            this._shaToScript[script.sha] = script;\n            this[name] = redis[name];\n            this[name + \"Buffer\"] = redis[name + \"Buffer\"];\n        });\n        redis.addedBuiltinSet.forEach((name)=>{\n            this[name] = redis[name];\n            this[name + \"Buffer\"] = redis[name + \"Buffer\"];\n        });\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        const _this = this;\n        Object.defineProperty(this, \"length\", {\n            get: function() {\n                return _this._queue.length;\n            }\n        });\n    }\n    fillResult(value, position) {\n        if (this._queue[position].name === \"exec\" && Array.isArray(value[1])) {\n            const execLength = value[1].length;\n            for(let i = 0; i < execLength; i++){\n                if (value[1][i] instanceof Error) {\n                    continue;\n                }\n                const cmd = this._queue[position - (execLength - i)];\n                try {\n                    value[1][i] = cmd.transformReply(value[1][i]);\n                } catch (err) {\n                    value[1][i] = err;\n                }\n            }\n        }\n        this._result[position] = value;\n        if (--this.replyPending) {\n            return;\n        }\n        if (this.isCluster) {\n            let retriable = true;\n            let commonError;\n            for(let i = 0; i < this._result.length; ++i){\n                const error = this._result[i][0];\n                const command = this._queue[i];\n                if (error) {\n                    if (command.name === \"exec\" && error.message === \"EXECABORT Transaction discarded because of previous errors.\") {\n                        continue;\n                    }\n                    if (!commonError) {\n                        commonError = {\n                            name: error.name,\n                            message: error.message\n                        };\n                    } else if (commonError.name !== error.name || commonError.message !== error.message) {\n                        retriable = false;\n                        break;\n                    }\n                } else if (!command.inTransaction) {\n                    const isReadOnly = (0, commands_1.exists)(command.name, {\n                        caseInsensitive: true\n                    }) && (0, commands_1.hasFlag)(command.name, \"readonly\", {\n                        nameCaseInsensitive: true\n                    });\n                    if (!isReadOnly) {\n                        retriable = false;\n                        break;\n                    }\n                }\n            }\n            if (commonError && retriable) {\n                const _this = this;\n                const errv = commonError.message.split(\" \");\n                const queue = this._queue;\n                let inTransaction = false;\n                this._queue = [];\n                for(let i = 0; i < queue.length; ++i){\n                    if (errv[0] === \"ASK\" && !inTransaction && queue[i].name !== \"asking\" && (!queue[i - 1] || queue[i - 1].name !== \"asking\")) {\n                        const asking = new Command_1.default(\"asking\");\n                        asking.ignore = true;\n                        this.sendCommand(asking);\n                    }\n                    queue[i].initPromise();\n                    this.sendCommand(queue[i]);\n                    inTransaction = queue[i].inTransaction;\n                }\n                let matched = true;\n                if (typeof this.leftRedirections === \"undefined\") {\n                    this.leftRedirections = {};\n                }\n                const exec = function() {\n                    _this.exec();\n                };\n                const cluster = this.redis;\n                cluster.handleError(commonError, this.leftRedirections, {\n                    moved: function(_slot, key) {\n                        _this.preferKey = key;\n                        if (cluster.slots[errv[1]]) {\n                            if (cluster.slots[errv[1]][0] !== key) {\n                                cluster.slots[errv[1]] = [\n                                    key\n                                ];\n                            }\n                        } else {\n                            cluster.slots[errv[1]] = [\n                                key\n                            ];\n                        }\n                        cluster._groupsBySlot[errv[1]] = cluster._groupsIds[cluster.slots[errv[1]].join(\";\")];\n                        cluster.refreshSlotsCache();\n                        _this.exec();\n                    },\n                    ask: function(_slot, key) {\n                        _this.preferKey = key;\n                        _this.exec();\n                    },\n                    tryagain: exec,\n                    clusterDown: exec,\n                    connectionClosed: exec,\n                    maxRedirections: ()=>{\n                        matched = false;\n                    },\n                    defaults: ()=>{\n                        matched = false;\n                    }\n                });\n                if (matched) {\n                    return;\n                }\n            }\n        }\n        let ignoredCount = 0;\n        for(let i = 0; i < this._queue.length - ignoredCount; ++i){\n            if (this._queue[i + ignoredCount].ignore) {\n                ignoredCount += 1;\n            }\n            this._result[i] = this._result[i + ignoredCount];\n        }\n        this.resolve(this._result.slice(0, this._result.length - ignoredCount));\n    }\n    sendCommand(command) {\n        if (this._transactions > 0) {\n            command.inTransaction = true;\n        }\n        const position = this._queue.length;\n        command.pipelineIndex = position;\n        command.promise.then((result)=>{\n            this.fillResult([\n                null,\n                result\n            ], position);\n        }).catch((error)=>{\n            this.fillResult([\n                error\n            ], position);\n        });\n        this._queue.push(command);\n        return this;\n    }\n    addBatch(commands) {\n        let command, commandName, args;\n        for(let i = 0; i < commands.length; ++i){\n            command = commands[i];\n            commandName = command[0];\n            args = command.slice(1);\n            this[commandName].apply(this, args);\n        }\n        return this;\n    }\n}\nexports[\"default\"] = Pipeline;\n// @ts-expect-error\nconst multi = Pipeline.prototype.multi;\n// @ts-expect-error\nPipeline.prototype.multi = function() {\n    this._transactions += 1;\n    return multi.apply(this, arguments);\n};\n// @ts-expect-error\nconst execBuffer = Pipeline.prototype.execBuffer;\n// @ts-expect-error\nPipeline.prototype.execBuffer = (0, util_1.deprecate)(function() {\n    if (this._transactions > 0) {\n        this._transactions -= 1;\n    }\n    return execBuffer.apply(this, arguments);\n}, \"Pipeline#execBuffer: Use Pipeline#exec instead\");\n// NOTE: To avoid an unhandled promise rejection, this will unconditionally always return this.promise,\n// which always has the rejection handled by standard-as-callback\n// adding the provided rejection callback.\n//\n// If a different promise instance were returned, that promise would cause its own unhandled promise rejection\n// errors, even if that promise unconditionally resolved to **the resolved value of** this.promise.\nPipeline.prototype.exec = function(callback) {\n    // Wait for the cluster to be connected, since we need nodes information before continuing\n    if (this.isCluster && !this.redis.slots.length) {\n        if (this.redis.status === \"wait\") this.redis.connect().catch(utils_1.noop);\n        if (callback && !this.nodeifiedPromise) {\n            this.nodeifiedPromise = true;\n            (0, standard_as_callback_1.default)(this.promise, callback);\n        }\n        this.redis.delayUntilReady((err)=>{\n            if (err) {\n                this.reject(err);\n                return;\n            }\n            this.exec(callback);\n        });\n        return this.promise;\n    }\n    if (this._transactions > 0) {\n        this._transactions -= 1;\n        return execBuffer.apply(this, arguments);\n    }\n    if (!this.nodeifiedPromise) {\n        this.nodeifiedPromise = true;\n        (0, standard_as_callback_1.default)(this.promise, callback);\n    }\n    if (!this._queue.length) {\n        this.resolve([]);\n    }\n    let pipelineSlot;\n    if (this.isCluster) {\n        // List of the first key for each command\n        const sampleKeys = [];\n        for(let i = 0; i < this._queue.length; i++){\n            const keys = this._queue[i].getKeys();\n            if (keys.length) {\n                sampleKeys.push(keys[0]);\n            }\n            // For each command, check that the keys belong to the same slot\n            if (keys.length && calculateSlot.generateMulti(keys) < 0) {\n                this.reject(new Error(\"All the keys in a pipeline command should belong to the same slot\"));\n                return this.promise;\n            }\n        }\n        if (sampleKeys.length) {\n            pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);\n            if (pipelineSlot < 0) {\n                this.reject(new Error(\"All keys in the pipeline should belong to the same slots allocation group\"));\n                return this.promise;\n            }\n        } else {\n            // Send the pipeline to a random node\n            pipelineSlot = Math.random() * 16384 | 0;\n        }\n    }\n    const _this = this;\n    execPipeline();\n    return this.promise;\n    function execPipeline() {\n        let writePending = _this.replyPending = _this._queue.length;\n        let node;\n        if (_this.isCluster) {\n            node = {\n                slot: pipelineSlot,\n                redis: _this.redis.connectionPool.nodes.all[_this.preferKey]\n            };\n        }\n        let data = \"\";\n        let buffers;\n        const stream = {\n            isPipeline: true,\n            destination: _this.isCluster ? node : {\n                redis: _this.redis\n            },\n            write (writable) {\n                if (typeof writable !== \"string\") {\n                    if (!buffers) {\n                        buffers = [];\n                    }\n                    if (data) {\n                        buffers.push(Buffer.from(data, \"utf8\"));\n                        data = \"\";\n                    }\n                    buffers.push(writable);\n                } else {\n                    data += writable;\n                }\n                if (!--writePending) {\n                    if (buffers) {\n                        if (data) {\n                            buffers.push(Buffer.from(data, \"utf8\"));\n                        }\n                        stream.destination.redis.stream.write(Buffer.concat(buffers));\n                    } else {\n                        stream.destination.redis.stream.write(data);\n                    }\n                    // Reset writePending for resending\n                    writePending = _this._queue.length;\n                    data = \"\";\n                    buffers = undefined;\n                }\n            }\n        };\n        for(let i = 0; i < _this._queue.length; ++i){\n            _this.redis.sendCommand(_this._queue[i], stream, node);\n        }\n        return _this.promise;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9QaXBlbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxnQkFBZ0JDLG1CQUFPQSxDQUFDLDRFQUFrQjtBQUNoRCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxnRkFBbUI7QUFDOUMsTUFBTUUseUJBQXlCRixtQkFBT0EsQ0FBQyxzRkFBc0I7QUFDN0QsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsa0JBQU07QUFDN0IsTUFBTUksWUFBWUosbUJBQU9BLENBQUMsZ0VBQVc7QUFDckMsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsa0VBQVM7QUFDakMsTUFBTU0sY0FBY04sbUJBQU9BLENBQUMsZ0ZBQW1CO0FBQy9DOzs7O0FBSUEsR0FDQSxTQUFTTyx1QkFBdUJDLEtBQUssRUFBRUMsSUFBSTtJQUN2QyxNQUFNQyxPQUFPWCxjQUFjVSxJQUFJLENBQUMsRUFBRTtJQUNsQyxNQUFNRSxTQUFTSCxNQUFNSSxhQUFhLENBQUNGLEtBQUs7SUFDeEMsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlKLEtBQUtLLE1BQU0sRUFBRUQsSUFBSztRQUNsQyxJQUFJTCxNQUFNSSxhQUFhLENBQUNiLGNBQWNVLElBQUksQ0FBQ0ksRUFBRSxFQUFFLEtBQUtGLFFBQVE7WUFDeEQsT0FBTyxDQUFDO1FBQ1o7SUFDSjtJQUNBLE9BQU9EO0FBQ1g7QUFDQSxNQUFNSyxpQkFBaUJULFlBQVlVLE9BQU87SUFDdENDLFlBQVlULEtBQUssQ0FBRTtRQUNmLEtBQUs7UUFDTCxJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNVLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLEVBQUU7UUFDakIsSUFBSSxDQUFD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QUFHQSxJQUFJdUIsTUFBTWhCLE1BQU0sQ0FBQ04sTUFBTSxFQUFFLEVBQUVELEVBQUc7WUFDMUN1QixNQUFNNUIsS0FBSyxDQUFDdUQsV0FBVyxDQUFDM0IsTUFBTWhCLE1BQU0sQ0FBQ1AsRUFBRSxFQUFFNEcsUUFBUU47UUFDckQ7UUFDQSxPQUFPL0UsTUFBTUosT0FBTztJQUN4QjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvZHVjdC1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9QaXBlbGluZS5qcz8wNDU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY2FsY3VsYXRlU2xvdCA9IHJlcXVpcmUoXCJjbHVzdGVyLWtleS1zbG90XCIpO1xuY29uc3QgY29tbWFuZHNfMSA9IHJlcXVpcmUoXCJAaW9yZWRpcy9jb21tYW5kc1wiKTtcbmNvbnN0IHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEgPSByZXF1aXJlKFwic3RhbmRhcmQtYXMtY2FsbGJhY2tcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL0NvbW1hbmRcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBDb21tYW5kZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL0NvbW1hbmRlclwiKTtcbi8qXG4gIFRoaXMgZnVuY3Rpb24gZGVyaXZlcyBmcm9tIHRoZSBjbHVzdGVyLWtleS1zbG90IGltcGxlbWVudGF0aW9uLlxuICBJbnN0ZWFkIG9mIGNoZWNraW5nIHRoYXQgYWxsIGtleXMgaGF2ZSB0aGUgc2FtZSBzbG90LCBpdCBjaGVja3MgdGhhdCBhbGwgc2xvdHMgYXJlIHNlcnZlZCBieSB0aGUgc2FtZSBzZXQgb2Ygbm9kZXMuXG4gIElmIHRoaXMgaXMgc2F0aXNmaWVkLCBpdCByZXR1cm5zIHRoZSBmaXJzdCBrZXkncyBzbG90LlxuKi9cbmZ1bmN0aW9uIGdlbmVyYXRlTXVsdGlXaXRoTm9kZXMocmVkaXMsIGtleXMpIHtcbiAgICBjb25zdCBzbG90ID0gY2FsY3VsYXRlU2xvdChrZXlzWzBdKTtcbiAgICBjb25zdCB0YXJnZXQgPSByZWRpcy5fZ3JvdXBzQnlTbG90W3Nsb3RdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVkaXMuX2dyb3Vwc0J5U2xvdFtjYWxjdWxhdGVTbG90KGtleXNbaV0pXSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNsb3Q7XG59XG5jbGFzcyBQaXBlbGluZSBleHRlbmRzIENvbW1hbmRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKHJlZGlzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVkaXMgPSByZWRpcztcbiAgICAgICAgdGhpcy5pc1BpcGVsaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXBseVBlbmRpbmcgPSAwO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLl9yZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25zID0gMDtcbiAgICAgICAgdGhpcy5fc2hhVG9TY3JpcHQgPSB7fTtcbiAgICAgICAgdGhpcy5pc0NsdXN0ZXIgPVxuICAgICAgICAgICAgdGhpcy5yZWRpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkNsdXN0ZXJcIiB8fCB0aGlzLnJlZGlzLmlzQ2x1c3RlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gcmVkaXMub3B0aW9ucztcbiAgICAgICAgT2JqZWN0LmtleXMocmVkaXMuc2NyaXB0c1NldCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0gcmVkaXMuc2NyaXB0c1NldFtuYW1lXTtcbiAgICAgICAgICAgIHRoaXMuX3NoYVRvU2NyaXB0W3NjcmlwdC5zaGFdID0gc2NyaXB0O1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHJlZGlzW25hbWVdO1xuICAgICAgICAgICAgdGhpc1tuYW1lICsgXCJCdWZmZXJcIl0gPSByZWRpc1tuYW1lICsgXCJCdWZmZXJcIl07XG4gICAgICAgIH0pO1xuICAgICAgICByZWRpcy5hZGRlZEJ1aWx0aW5TZXQuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHJlZGlzW25hbWVdO1xuICAgICAgICAgICAgdGhpc1tuYW1lICsgXCJCdWZmZXJcIl0gPSByZWRpc1tuYW1lICsgXCJCdWZmZXJcIl07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3F1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaWxsUmVzdWx0KHZhbHVlLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fcXVldWVbcG9zaXRpb25dLm5hbWUgPT09IFwiZXhlY1wiICYmIEFycmF5LmlzQXJyYXkodmFsdWVbMV0pKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjTGVuZ3RoID0gdmFsdWVbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGVjTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbMV1baV0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY21kID0gdGhpcy5fcXVldWVbcG9zaXRpb24gLSAoZXhlY0xlbmd0aCAtIGkpXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVsxXVtpXSA9IGNtZC50cmFuc2Zvcm1SZXBseSh2YWx1ZVsxXVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbMV1baV0gPSBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc3VsdFtwb3NpdGlvbl0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKC0tdGhpcy5yZXBseVBlbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0NsdXN0ZXIpIHtcbiAgICAgICAgICAgIGxldCByZXRyaWFibGUgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGNvbW1vbkVycm9yO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9yZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX3Jlc3VsdFtpXVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYW5kID0gdGhpcy5fcXVldWVbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kLm5hbWUgPT09IFwiZXhlY1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRVhFQ0FCT1JUIFRyYW5zYWN0aW9uIGRpc2NhcmRlZCBiZWNhdXNlIG9mIHByZXZpb3VzIGVycm9ycy5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21tb25FcnJvci5uYW1lICE9PSBlcnJvci5uYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tb25FcnJvci5tZXNzYWdlICE9PSBlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyaWFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjb21tYW5kLmluVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNSZWFkT25seSA9ICgwLCBjb21tYW5kc18xLmV4aXN0cykoY29tbWFuZC5uYW1lLCB7IGNhc2VJbnNlbnNpdGl2ZTogdHJ1ZSB9KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGNvbW1hbmRzXzEuaGFzRmxhZykoY29tbWFuZC5uYW1lLCBcInJlYWRvbmx5XCIsIHsgbmFtZUNhc2VJbnNlbnNpdGl2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyaWFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbW1vbkVycm9yICYmIHJldHJpYWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJ2ID0gY29tbW9uRXJyb3IubWVzc2FnZS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICAgICAgICAgICAgICBsZXQgaW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJydlswXSA9PT0gXCJBU0tcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWluVHJhbnNhY3Rpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldLm5hbWUgIT09IFwiYXNraW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghcXVldWVbaSAtIDFdIHx8IHF1ZXVlW2kgLSAxXS5uYW1lICE9PSBcImFza2luZ1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNraW5nID0gbmV3IENvbW1hbmRfMS5kZWZhdWx0KFwiYXNraW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNraW5nLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKGFza2luZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uaW5pdFByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kQ29tbWFuZChxdWV1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGluVHJhbnNhY3Rpb24gPSBxdWV1ZVtpXS5pblRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxlZnRSZWRpcmVjdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0UmVkaXJlY3Rpb25zID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV4ZWMoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXIgPSB0aGlzLnJlZGlzO1xuICAgICAgICAgICAgICAgIGNsdXN0ZXIuaGFuZGxlRXJyb3IoY29tbW9uRXJyb3IsIHRoaXMubGVmdFJlZGlyZWN0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZDogZnVuY3Rpb24gKF9zbG90LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByZWZlcktleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbHVzdGVyLnNsb3RzW2VycnZbMV1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsdXN0ZXIuc2xvdHNbZXJydlsxXV1bMF0gIT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLnNsb3RzW2VycnZbMV1dID0gW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3Rlci5zbG90c1tlcnJ2WzFdXSA9IFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3Rlci5fZ3JvdXBzQnlTbG90W2VycnZbMV1dID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLl9ncm91cHNJZHNbY2x1c3Rlci5zbG90c1tlcnJ2WzFdXS5qb2luKFwiO1wiKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLnJlZnJlc2hTbG90c0NhY2hlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5leGVjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFzazogZnVuY3Rpb24gKF9zbG90LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByZWZlcktleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmV4ZWMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdHJ5YWdhaW46IGV4ZWMsXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJEb3duOiBleGVjLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ2xvc2VkOiBleGVjLFxuICAgICAgICAgICAgICAgICAgICBtYXhSZWRpcmVjdGlvbnM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpZ25vcmVkQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aCAtIGlnbm9yZWRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcXVldWVbaSArIGlnbm9yZWRDb3VudF0uaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgaWdub3JlZENvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB0aGlzLl9yZXN1bHRbaSArIGlnbm9yZWRDb3VudF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlKHRoaXMuX3Jlc3VsdC5zbGljZSgwLCB0aGlzLl9yZXN1bHQubGVuZ3RoIC0gaWdub3JlZENvdW50KSk7XG4gICAgfVxuICAgIHNlbmRDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9ucyA+IDApIHtcbiAgICAgICAgICAgIGNvbW1hbmQuaW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9xdWV1ZS5sZW5ndGg7XG4gICAgICAgIGNvbW1hbmQucGlwZWxpbmVJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICBjb21tYW5kLnByb21pc2VcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlc3VsdChbbnVsbCwgcmVzdWx0XSwgcG9zaXRpb24pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5maWxsUmVzdWx0KFtlcnJvcl0sIHBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goY29tbWFuZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRCYXRjaChjb21tYW5kcykge1xuICAgICAgICBsZXQgY29tbWFuZCwgY29tbWFuZE5hbWUsIGFyZ3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbW1hbmQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgIGNvbW1hbmROYW1lID0gY29tbWFuZFswXTtcbiAgICAgICAgICAgIGFyZ3MgPSBjb21tYW5kLnNsaWNlKDEpO1xuICAgICAgICAgICAgdGhpc1tjb21tYW5kTmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUGlwZWxpbmU7XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5jb25zdCBtdWx0aSA9IFBpcGVsaW5lLnByb3RvdHlwZS5tdWx0aTtcbi8vIEB0cy1leHBlY3QtZXJyb3JcblBpcGVsaW5lLnByb3RvdHlwZS5tdWx0aSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90cmFuc2FjdGlvbnMgKz0gMTtcbiAgICByZXR1cm4gbXVsdGkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5jb25zdCBleGVjQnVmZmVyID0gUGlwZWxpbmUucHJvdG90eXBlLmV4ZWNCdWZmZXI7XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5QaXBlbGluZS5wcm90b3R5cGUuZXhlY0J1ZmZlciA9ICgwLCB1dGlsXzEuZGVwcmVjYXRlKShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9ucyA+IDApIHtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25zIC09IDE7XG4gICAgfVxuICAgIHJldHVybiBleGVjQnVmZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59LCBcIlBpcGVsaW5lI2V4ZWNCdWZmZXI6IFVzZSBQaXBlbGluZSNleGVjIGluc3RlYWRcIik7XG4vLyBOT1RFOiBUbyBhdm9pZCBhbiB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24sIHRoaXMgd2lsbCB1bmNvbmRpdGlvbmFsbHkgYWx3YXlzIHJldHVybiB0aGlzLnByb21pc2UsXG4vLyB3aGljaCBhbHdheXMgaGFzIHRoZSByZWplY3Rpb24gaGFuZGxlZCBieSBzdGFuZGFyZC1hcy1jYWxsYmFja1xuLy8gYWRkaW5nIHRoZSBwcm92aWRlZCByZWplY3Rpb24gY2FsbGJhY2suXG4vL1xuLy8gSWYgYSBkaWZmZXJlbnQgcHJvbWlzZSBpbnN0YW5jZSB3ZXJlIHJldHVybmVkLCB0aGF0IHByb21pc2Ugd291bGQgY2F1c2UgaXRzIG93biB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25cbi8vIGVycm9ycywgZXZlbiBpZiB0aGF0IHByb21pc2UgdW5jb25kaXRpb25hbGx5IHJlc29sdmVkIHRvICoqdGhlIHJlc29sdmVkIHZhbHVlIG9mKiogdGhpcy5wcm9taXNlLlxuUGlwZWxpbmUucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyBXYWl0IGZvciB0aGUgY2x1c3RlciB0byBiZSBjb25uZWN0ZWQsIHNpbmNlIHdlIG5lZWQgbm9kZXMgaW5mb3JtYXRpb24gYmVmb3JlIGNvbnRpbnVpbmdcbiAgICBpZiAodGhpcy5pc0NsdXN0ZXIgJiYgIXRoaXMucmVkaXMuc2xvdHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZGlzLnN0YXR1cyA9PT0gXCJ3YWl0XCIpXG4gICAgICAgICAgICB0aGlzLnJlZGlzLmNvbm5lY3QoKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgIXRoaXMubm9kZWlmaWVkUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlaWZpZWRQcm9taXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKHRoaXMucHJvbWlzZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkaXMuZGVsYXlVbnRpbFJlYWR5KChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXhlYyhjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb25zID4gMCkge1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbnMgLT0gMTtcbiAgICAgICAgcmV0dXJuIGV4ZWNCdWZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm5vZGVpZmllZFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5ub2RlaWZpZWRQcm9taXNlID0gdHJ1ZTtcbiAgICAgICAgKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkodGhpcy5wcm9taXNlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGxldCBwaXBlbGluZVNsb3Q7XG4gICAgaWYgKHRoaXMuaXNDbHVzdGVyKSB7XG4gICAgICAgIC8vIExpc3Qgb2YgdGhlIGZpcnN0IGtleSBmb3IgZWFjaCBjb21tYW5kXG4gICAgICAgIGNvbnN0IHNhbXBsZUtleXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuX3F1ZXVlW2ldLmdldEtleXMoKTtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNhbXBsZUtleXMucHVzaChrZXlzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGNvbW1hbmQsIGNoZWNrIHRoYXQgdGhlIGtleXMgYmVsb25nIHRvIHRoZSBzYW1lIHNsb3RcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCAmJiBjYWxjdWxhdGVTbG90LmdlbmVyYXRlTXVsdGkoa2V5cykgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QobmV3IEVycm9yKFwiQWxsIHRoZSBrZXlzIGluIGEgcGlwZWxpbmUgY29tbWFuZCBzaG91bGQgYmVsb25nIHRvIHRoZSBzYW1lIHNsb3RcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbXBsZUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwaXBlbGluZVNsb3QgPSBnZW5lcmF0ZU11bHRpV2l0aE5vZGVzKHRoaXMucmVkaXMsIHNhbXBsZUtleXMpO1xuICAgICAgICAgICAgaWYgKHBpcGVsaW5lU2xvdCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChuZXcgRXJyb3IoXCJBbGwga2V5cyBpbiB0aGUgcGlwZWxpbmUgc2hvdWxkIGJlbG9uZyB0byB0aGUgc2FtZSBzbG90cyBhbGxvY2F0aW9uIGdyb3VwXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgcGlwZWxpbmUgdG8gYSByYW5kb20gbm9kZVxuICAgICAgICAgICAgcGlwZWxpbmVTbG90ID0gKE1hdGgucmFuZG9tKCkgKiAxNjM4NCkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICBleGVjUGlwZWxpbmUoKTtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIGZ1bmN0aW9uIGV4ZWNQaXBlbGluZSgpIHtcbiAgICAgICAgbGV0IHdyaXRlUGVuZGluZyA9IChfdGhpcy5yZXBseVBlbmRpbmcgPSBfdGhpcy5fcXVldWUubGVuZ3RoKTtcbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIGlmIChfdGhpcy5pc0NsdXN0ZXIpIHtcbiAgICAgICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgc2xvdDogcGlwZWxpbmVTbG90LFxuICAgICAgICAgICAgICAgIHJlZGlzOiBfdGhpcy5yZWRpcy5jb25uZWN0aW9uUG9vbC5ub2Rlcy5hbGxbX3RoaXMucHJlZmVyS2V5XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSBcIlwiO1xuICAgICAgICBsZXQgYnVmZmVycztcbiAgICAgICAgY29uc3Qgc3RyZWFtID0ge1xuICAgICAgICAgICAgaXNQaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBfdGhpcy5pc0NsdXN0ZXIgPyBub2RlIDogeyByZWRpczogX3RoaXMucmVkaXMgfSxcbiAgICAgICAgICAgIHdyaXRlKHdyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3cml0YWJsZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1ZmZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKEJ1ZmZlci5mcm9tKGRhdGEsIFwidXRmOFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2god3JpdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSArPSB3cml0YWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEtLXdyaXRlUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goQnVmZmVyLmZyb20oZGF0YSwgXCJ1dGY4XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0aW5hdGlvbi5yZWRpcy5zdHJlYW0ud3JpdGUoQnVmZmVyLmNvbmNhdChidWZmZXJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZGVzdGluYXRpb24ucmVkaXMuc3RyZWFtLndyaXRlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHdyaXRlUGVuZGluZyBmb3IgcmVzZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlUGVuZGluZyA9IF90aGlzLl9xdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX3RoaXMuX3F1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWRpcy5zZW5kQ29tbWFuZChfdGhpcy5fcXVldWVbaV0sIHN0cmVhbSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzLnByb21pc2U7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNhbGN1bGF0ZVNsb3QiLCJyZXF1aXJlIiwiY29tbWFuZHNfMSIsInN0YW5kYXJkX2FzX2NhbGxiYWNrXzEiLCJ1dGlsXzEiLCJDb21tYW5kXzEiLCJ1dGlsc18xIiwiQ29tbWFuZGVyXzEiLCJnZW5lcmF0ZU11bHRpV2l0aE5vZGVzIiwicmVkaXMiLCJrZXlzIiwic2xvdCIsInRhcmdldCIsIl9ncm91cHNCeVNsb3QiLCJpIiwibGVuZ3RoIiwiUGlwZWxpbmUiLCJkZWZhdWx0IiwiY29uc3RydWN0b3IiLCJpc1BpcGVsaW5lIiwicmVwbHlQZW5kaW5nIiwiX3F1ZXVlIiwiX3Jlc3VsdCIsIl90cmFuc2FjdGlvbnMiLCJfc2hhVG9TY3JpcHQiLCJpc0NsdXN0ZXIiLCJuYW1lIiwib3B0aW9ucyIsInNjcmlwdHNTZXQiLCJmb3JFYWNoIiwic2NyaXB0Iiwic2hhIiwiYWRkZWRCdWlsdGluU2V0IiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiX3RoaXMiLCJnZXQiLCJmaWxsUmVzdWx0IiwicG9zaXRpb24iLCJBcnJheSIsImlzQXJyYXkiLCJleGVjTGVuZ3RoIiwiRXJyb3IiLCJjbWQiLCJ0cmFuc2Zvcm1SZXBseSIsImVyciIsInJldHJpYWJsZSIsImNvbW1vbkVycm9yIiwiZXJyb3IiLCJjb21tYW5kIiwibWVzc2FnZSIsImluVHJhbnNhY3Rpb24iLCJpc1JlYWRPbmx5IiwiZXhpc3RzIiwiY2FzZUluc2Vuc2l0aXZlIiwiaGFzRmxhZyIsIm5hbWVDYXNlSW5zZW5zaXRpdmUiLCJlcnJ2Iiwic3BsaXQiLCJxdWV1ZSIsImFza2luZyIsImlnbm9yZSIsInNlbmRDb21tYW5kIiwiaW5pdFByb21pc2UiLCJtYXRjaGVkIiwibGVmdFJlZGlyZWN0aW9ucyIsImV4ZWMiLCJjbHVzdGVyIiwiaGFuZGxlRXJyb3IiLCJtb3ZlZCIsIl9zbG90Iiwia2V5IiwicHJlZmVyS2V5Iiwic2xvdHMiLCJfZ3JvdXBzSWRzIiwiam9pbiIsInJlZnJlc2hTbG90c0NhY2hlIiwiYXNrIiwidHJ5YWdhaW4iLCJjbHVzdGVyRG93biIsImNvbm5lY3Rpb25DbG9zZWQiLCJtYXhSZWRpcmVjdGlvbnMiLCJkZWZhdWx0cyIsImlnbm9yZWRDb3VudCIsInNsaWNlIiwicGlwZWxpbmVJbmRleCIsInRoZW4iLCJyZXN1bHQiLCJjYXRjaCIsInB1c2giLCJhZGRCYXRjaCIsImNvbW1hbmRzIiwiY29tbWFuZE5hbWUiLCJhcmdzIiwiYXBwbHkiLCJtdWx0aSIsInByb3RvdHlwZSIsImFyZ3VtZW50cyIsImV4ZWNCdWZmZXIiLCJkZXByZWNhdGUiLCJjYWxsYmFjayIsInN0YXR1cyIsImNvbm5lY3QiLCJub29wIiwibm9kZWlmaWVkUHJvbWlzZSIsImRlbGF5VW50aWxSZWFkeSIsInBpcGVsaW5lU2xvdCIsInNhbXBsZUtleXMiLCJnZXRLZXlzIiwiZ2VuZXJhdGVNdWx0aSIsIk1hdGgiLCJyYW5kb20iLCJleGVjUGlwZWxpbmUiLCJ3cml0ZVBlbmRpbmciLCJub2RlIiwiY29ubmVjdGlvblBvb2wiLCJub2RlcyIsImFsbCIsImRhdGEiLCJidWZmZXJzIiwic3RyZWFtIiwiZGVzdGluYXRpb24iLCJ3cml0ZSIsIndyaXRhYmxlIiwiQnVmZmVyIiwiZnJvbSIsImNvbmNhdCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/Pipeline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/Redis.js":
/*!*********************************************!*\
  !*** ./node_modules/ioredis/built/Redis.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst cluster_1 = __webpack_require__(/*! ./cluster */ \"(rsc)/./node_modules/ioredis/built/cluster/index.js\");\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst connectors_1 = __webpack_require__(/*! ./connectors */ \"(rsc)/./node_modules/ioredis/built/connectors/index.js\");\nconst SentinelConnector_1 = __webpack_require__(/*! ./connectors/SentinelConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js\");\nconst eventHandler = __webpack_require__(/*! ./redis/event_handler */ \"(rsc)/./node_modules/ioredis/built/redis/event_handler.js\");\nconst RedisOptions_1 = __webpack_require__(/*! ./redis/RedisOptions */ \"(rsc)/./node_modules/ioredis/built/redis/RedisOptions.js\");\nconst ScanStream_1 = __webpack_require__(/*! ./ScanStream */ \"(rsc)/./node_modules/ioredis/built/ScanStream.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/ioredis/built/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst applyMixin_1 = __webpack_require__(/*! ./utils/applyMixin */ \"(rsc)/./node_modules/ioredis/built/utils/applyMixin.js\");\nconst Commander_1 = __webpack_require__(/*! ./utils/Commander */ \"(rsc)/./node_modules/ioredis/built/utils/Commander.js\");\nconst lodash_1 = __webpack_require__(/*! ./utils/lodash */ \"(rsc)/./node_modules/ioredis/built/utils/lodash.js\");\nconst Deque = __webpack_require__(/*! denque */ \"(rsc)/./node_modules/denque/index.js\");\nconst debug = (0, utils_1.Debug)(\"redis\");\n/**\n * This is the major component of ioredis.\n * Use it to connect to a standalone Redis server or Sentinels.\n *\n * ```typescript\n * const redis = new Redis(); // Default port is 6379\n * async function main() {\n *   redis.set(\"foo\", \"bar\");\n *   redis.get(\"foo\", (err, result) => {\n *     // `result` should be \"bar\"\n *     console.log(err, result);\n *   });\n *   // Or use Promise\n *   const result = await redis.get(\"foo\");\n * }\n * ```\n */ class Redis extends Commander_1.default {\n    constructor(arg1, arg2, arg3){\n        super();\n        this.status = \"wait\";\n        /**\n         * @ignore\n         */ this.isCluster = false;\n        this.reconnectTimeout = null;\n        this.connectionEpoch = 0;\n        this.retryAttempts = 0;\n        this.manuallyClosing = false;\n        // Prepare autopipelines structures\n        this._autoPipelines = new Map();\n        this._runningAutoPipelines = new Set();\n        this.parseOptions(arg1, arg2, arg3);\n        events_1.EventEmitter.call(this);\n        this.resetCommandQueue();\n        this.resetOfflineQueue();\n        if (this.options.Connector) {\n            this.connector = new this.options.Connector(this.options);\n        } else if (this.options.sentinels) {\n            const sentinelConnector = new SentinelConnector_1.default(this.options);\n            sentinelConnector.emitter = this;\n            this.connector = sentinelConnector;\n        } else {\n            this.connector = new connectors_1.StandaloneConnector(this.options);\n        }\n        if (this.options.scripts) {\n            Object.entries(this.options.scripts).forEach(([name, definition])=>{\n                this.defineCommand(name, definition);\n            });\n        }\n        // end(or wait) -> connecting -> connect -> ready -> end\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        } else {\n            this.connect().catch(lodash_1.noop);\n        }\n    }\n    /**\n     * Create a Redis instance.\n     * This is the same as `new Redis()` but is included for compatibility with node-redis.\n     */ static createClient(...args) {\n        return new Redis(...args);\n    }\n    get autoPipelineQueueSize() {\n        let queued = 0;\n        for (const pipeline of this._autoPipelines.values()){\n            queued += pipeline.length;\n        }\n        return queued;\n    }\n    /**\n     * Create a connection to Redis.\n     * This method will be invoked automatically when creating a new Redis instance\n     * unless `lazyConnect: true` is passed.\n     *\n     * When calling this method manually, a Promise is returned, which will\n     * be resolved when the connection status is ready. The promise can reject\n     * if the connection fails, times out, or if Redis is already connecting/connected.\n     */ connect(callback) {\n        const promise = new Promise((resolve, reject)=>{\n            if (this.status === \"connecting\" || this.status === \"connect\" || this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            this.connectionEpoch += 1;\n            this.setStatus(\"connecting\");\n            const { options } = this;\n            this.condition = {\n                select: options.db,\n                auth: options.username ? [\n                    options.username,\n                    options.password\n                ] : options.password,\n                subscriber: false\n            };\n            const _this = this;\n            (0, standard_as_callback_1.default)(this.connector.connect(function(type, err) {\n                _this.silentEmit(type, err);\n            }), function(err, stream) {\n                if (err) {\n                    _this.flushQueue(err);\n                    _this.silentEmit(\"error\", err);\n                    reject(err);\n                    _this.setStatus(\"end\");\n                    return;\n                }\n                let CONNECT_EVENT = options.tls ? \"secureConnect\" : \"connect\";\n                if (\"sentinels\" in options && options.sentinels && !options.enableTLSForSentinelMode) {\n                    CONNECT_EVENT = \"connect\";\n                }\n                _this.stream = stream;\n                if (options.noDelay) {\n                    stream.setNoDelay(true);\n                }\n                // Node ignores setKeepAlive before connect, therefore we wait for the event:\n                // https://github.com/nodejs/node/issues/31663\n                if (typeof options.keepAlive === \"number\") {\n                    if (stream.connecting) {\n                        stream.once(CONNECT_EVENT, ()=>{\n                            stream.setKeepAlive(true, options.keepAlive);\n                        });\n                    } else {\n                        stream.setKeepAlive(true, options.keepAlive);\n                    }\n                }\n                if (stream.connecting) {\n                    stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));\n                    if (options.connectTimeout) {\n                        /*\n                         * Typically, Socket#setTimeout(0) will clear the timer\n                         * set before. However, in some platforms (Electron 3.x~4.x),\n                         * the timer will not be cleared. So we introduce a variable here.\n                         *\n                         * See https://github.com/electron/electron/issues/14915\n                         */ let connectTimeoutCleared = false;\n                        stream.setTimeout(options.connectTimeout, function() {\n                            if (connectTimeoutCleared) {\n                                return;\n                            }\n                            stream.setTimeout(0);\n                            stream.destroy();\n                            const err = new Error(\"connect ETIMEDOUT\");\n                            // @ts-expect-error\n                            err.errorno = \"ETIMEDOUT\";\n                            // @ts-expect-error\n                            err.code = \"ETIMEDOUT\";\n                            // @ts-expect-error\n                            err.syscall = \"connect\";\n                            eventHandler.errorHandler(_this)(err);\n                        });\n                        stream.once(CONNECT_EVENT, function() {\n                            connectTimeoutCleared = true;\n                            stream.setTimeout(0);\n                        });\n                    }\n                } else if (stream.destroyed) {\n                    const firstError = _this.connector.firstError;\n                    if (firstError) {\n                        process.nextTick(()=>{\n                            eventHandler.errorHandler(_this)(firstError);\n                        });\n                    }\n                    process.nextTick(eventHandler.closeHandler(_this));\n                } else {\n                    process.nextTick(eventHandler.connectHandler(_this));\n                }\n                if (!stream.destroyed) {\n                    stream.once(\"error\", eventHandler.errorHandler(_this));\n                    stream.once(\"close\", eventHandler.closeHandler(_this));\n                }\n                const connectionReadyHandler = function() {\n                    _this.removeListener(\"close\", connectionCloseHandler);\n                    resolve();\n                };\n                var connectionCloseHandler = function() {\n                    _this.removeListener(\"ready\", connectionReadyHandler);\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                };\n                _this.once(\"ready\", connectionReadyHandler);\n                _this.once(\"close\", connectionCloseHandler);\n            });\n        });\n        return (0, standard_as_callback_1.default)(promise, callback);\n    }\n    /**\n     * Disconnect from Redis.\n     *\n     * This method closes the connection immediately,\n     * and may lose some pending replies that haven't written to client.\n     * If you want to wait for the pending replies, use Redis#quit instead.\n     */ disconnect(reconnect = false) {\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout && !reconnect) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        if (this.status === \"wait\") {\n            eventHandler.closeHandler(this)();\n        } else {\n            this.connector.disconnect();\n        }\n    }\n    /**\n     * Disconnect from Redis.\n     *\n     * @deprecated\n     */ end() {\n        this.disconnect();\n    }\n    /**\n     * Create a new instance with the same options as the current one.\n     *\n     * @example\n     * ```js\n     * var redis = new Redis(6380);\n     * var anotherRedis = redis.duplicate();\n     * ```\n     */ duplicate(override) {\n        return new Redis({\n            ...this.options,\n            ...override\n        });\n    }\n    /**\n     * Mode of the connection.\n     *\n     * One of `\"normal\"`, `\"subscriber\"`, or `\"monitor\"`. When the connection is\n     * not in `\"normal\"` mode, certain commands are not allowed.\n     */ get mode() {\n        var _a;\n        return this.options.monitor ? \"monitor\" : ((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) ? \"subscriber\" : \"normal\";\n    }\n    /**\n     * Listen for all requests received by the server in real time.\n     *\n     * This command will create a new connection to Redis and send a\n     * MONITOR command via the new connection in order to avoid disturbing\n     * the current connection.\n     *\n     * @param callback The callback function. If omit, a promise will be returned.\n     * @example\n     * ```js\n     * var redis = new Redis();\n     * redis.monitor(function (err, monitor) {\n     *   // Entering monitoring mode.\n     *   monitor.on('monitor', function (time, args, source, database) {\n     *     console.log(time + \": \" + util.inspect(args));\n     *   });\n     * });\n     *\n     * // supports promise as well as other commands\n     * redis.monitor().then(function (monitor) {\n     *   monitor.on('monitor', function (time, args, source, database) {\n     *     console.log(time + \": \" + util.inspect(args));\n     *   });\n     * });\n     * ```\n     */ monitor(callback) {\n        const monitorInstance = this.duplicate({\n            monitor: true,\n            lazyConnect: false\n        });\n        return (0, standard_as_callback_1.default)(new Promise(function(resolve, reject) {\n            monitorInstance.once(\"error\", reject);\n            monitorInstance.once(\"monitoring\", function() {\n                resolve(monitorInstance);\n            });\n        }), callback);\n    }\n    /**\n     * Send a command to Redis\n     *\n     * This method is used internally and in most cases you should not\n     * use it directly. If you need to send a command that is not supported\n     * by the library, you can use the `call` method:\n     *\n     * ```js\n     * const redis = new Redis();\n     *\n     * redis.call('set', 'foo', 'bar');\n     * // or\n     * redis.call(['set', 'foo', 'bar']);\n     * ```\n     *\n     * @ignore\n     */ sendCommand(command, stream) {\n        var _a, _b;\n        if (this.status === \"wait\") {\n            this.connect().catch(lodash_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) && !Command_1.default.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", command.name)) {\n            command.reject(new Error(\"Connection in subscriber mode, only subscriber commands may be used\"));\n            return command.promise;\n        }\n        if (typeof this.options.commandTimeout === \"number\") {\n            command.setTimeout(this.options.commandTimeout);\n        }\n        const blockingTimeout = this.getBlockingTimeoutInMs(command);\n        let writable = this.status === \"ready\" || !stream && this.status === \"connect\" && (0, commands_1.exists)(command.name, {\n            caseInsensitive: true\n        }) && ((0, commands_1.hasFlag)(command.name, \"loading\", {\n            nameCaseInsensitive: true\n        }) || Command_1.default.checkFlag(\"HANDSHAKE_COMMANDS\", command.name));\n        if (!this.stream) {\n            writable = false;\n        } else if (!this.stream.writable) {\n            writable = false;\n        // @ts-expect-error\n        } else if (this.stream._writableState && this.stream._writableState.ended) {\n            // TODO: We should be able to remove this as the PR has already been merged.\n            // https://github.com/iojs/io.js/pull/1217\n            writable = false;\n        }\n        if (!writable) {\n            if (!this.options.enableOfflineQueue) {\n                command.reject(new Error(\"Stream isn't writeable and enableOfflineQueue options is false\"));\n                return command.promise;\n            }\n            if (command.name === \"quit\" && this.offlineQueue.length === 0) {\n                this.disconnect();\n                command.resolve(Buffer.from(\"OK\"));\n                return command.promise;\n            }\n            // @ts-expect-error\n            if (debug.enabled) {\n                debug(\"queue command[%s]: %d -> %s(%o)\", this._getDescription(), this.condition.select, command.name, command.args);\n            }\n            this.offlineQueue.push({\n                command: command,\n                stream: stream,\n                select: this.condition.select\n            });\n            // For blocking commands in the offline queue, arm a client-side timeout\n            // only when blockingTimeout is configured. Without this option, queued\n            // blocking commands may wait indefinitely on a dead connection.\n            if (Command_1.default.checkFlag(\"BLOCKING_COMMANDS\", command.name)) {\n                const offlineTimeout = this.getConfiguredBlockingTimeout();\n                if (offlineTimeout !== undefined) {\n                    command.setBlockingTimeout(offlineTimeout);\n                }\n            }\n        } else {\n            // @ts-expect-error\n            if (debug.enabled) {\n                debug(\"write command[%s]: %d -> %s(%o)\", this._getDescription(), (_b = this.condition) === null || _b === void 0 ? void 0 : _b.select, command.name, command.args);\n            }\n            if (stream) {\n                if (\"isPipeline\" in stream && stream.isPipeline) {\n                    stream.write(command.toWritable(stream.destination.redis.stream));\n                } else {\n                    stream.write(command.toWritable(stream));\n                }\n            } else {\n                this.stream.write(command.toWritable(this.stream));\n            }\n            this.commandQueue.push({\n                command: command,\n                stream: stream,\n                select: this.condition.select\n            });\n            if (blockingTimeout !== undefined) {\n                command.setBlockingTimeout(blockingTimeout);\n            }\n            if (Command_1.default.checkFlag(\"WILL_DISCONNECT\", command.name)) {\n                this.manuallyClosing = true;\n            }\n            if (this.options.socketTimeout !== undefined && this.socketTimeoutTimer === undefined) {\n                this.setSocketTimeout();\n            }\n        }\n        if (command.name === \"select\" && (0, utils_1.isInt)(command.args[0])) {\n            const db = parseInt(command.args[0], 10);\n            if (this.condition.select !== db) {\n                this.condition.select = db;\n                this.emit(\"select\", db);\n                debug(\"switch to db [%d]\", this.condition.select);\n            }\n        }\n        return command.promise;\n    }\n    getBlockingTimeoutInMs(command) {\n        var _a;\n        if (!Command_1.default.checkFlag(\"BLOCKING_COMMANDS\", command.name)) {\n            return undefined;\n        }\n        // Feature is opt-in: only enabled when blockingTimeout is set to a positive number\n        const configuredTimeout = this.getConfiguredBlockingTimeout();\n        if (configuredTimeout === undefined) {\n            return undefined;\n        }\n        const timeout = command.extractBlockingTimeout();\n        if (typeof timeout === \"number\") {\n            if (timeout > 0) {\n                // Finite timeout from command args - add grace period\n                return timeout + ((_a = this.options.blockingTimeoutGrace) !== null && _a !== void 0 ? _a : RedisOptions_1.DEFAULT_REDIS_OPTIONS.blockingTimeoutGrace);\n            }\n            // Command has timeout=0 (block forever), use blockingTimeout option as safety net\n            return configuredTimeout;\n        }\n        if (timeout === null) {\n            // No BLOCK option found (e.g., XREAD without BLOCK), use blockingTimeout as safety net\n            return configuredTimeout;\n        }\n        return undefined;\n    }\n    getConfiguredBlockingTimeout() {\n        if (typeof this.options.blockingTimeout === \"number\" && this.options.blockingTimeout > 0) {\n            return this.options.blockingTimeout;\n        }\n        return undefined;\n    }\n    setSocketTimeout() {\n        this.socketTimeoutTimer = setTimeout(()=>{\n            this.stream.destroy(new Error(`Socket timeout. Expecting data, but didn't receive any in ${this.options.socketTimeout}ms.`));\n            this.socketTimeoutTimer = undefined;\n        }, this.options.socketTimeout);\n        // this handler must run after the \"data\" handler in \"DataHandler\"\n        // so that `this.commandQueue.length` will be updated\n        this.stream.once(\"data\", ()=>{\n            clearTimeout(this.socketTimeoutTimer);\n            this.socketTimeoutTimer = undefined;\n            if (this.commandQueue.length === 0) return;\n            this.setSocketTimeout();\n        });\n    }\n    scanStream(options) {\n        return this.createScanStream(\"scan\", {\n            options\n        });\n    }\n    scanBufferStream(options) {\n        return this.createScanStream(\"scanBuffer\", {\n            options\n        });\n    }\n    sscanStream(key, options) {\n        return this.createScanStream(\"sscan\", {\n            key,\n            options\n        });\n    }\n    sscanBufferStream(key, options) {\n        return this.createScanStream(\"sscanBuffer\", {\n            key,\n            options\n        });\n    }\n    hscanStream(key, options) {\n        return this.createScanStream(\"hscan\", {\n            key,\n            options\n        });\n    }\n    hscanBufferStream(key, options) {\n        return this.createScanStream(\"hscanBuffer\", {\n            key,\n            options\n        });\n    }\n    zscanStream(key, options) {\n        return this.createScanStream(\"zscan\", {\n            key,\n            options\n        });\n    }\n    zscanBufferStream(key, options) {\n        return this.createScanStream(\"zscanBuffer\", {\n            key,\n            options\n        });\n    }\n    /**\n     * Emit only when there's at least one listener.\n     *\n     * @ignore\n     */ silentEmit(eventName, arg) {\n        let error;\n        if (eventName === \"error\") {\n            error = arg;\n            if (this.status === \"end\") {\n                return;\n            }\n            if (this.manuallyClosing) {\n                // ignore connection related errors when manually disconnecting\n                if (error instanceof Error && (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG || // @ts-expect-error\n                error.syscall === \"connect\" || // @ts-expect-error\n                error.syscall === \"read\")) {\n                    return;\n                }\n            }\n        }\n        if (this.listeners(eventName).length > 0) {\n            return this.emit.apply(this, arguments);\n        }\n        if (error && error instanceof Error) {\n            console.error(\"[ioredis] Unhandled error event:\", error.stack);\n        }\n        return false;\n    }\n    /**\n     * @ignore\n     */ recoverFromFatalError(_commandError, err, options) {\n        this.flushQueue(err, options);\n        this.silentEmit(\"error\", err);\n        this.disconnect(true);\n    }\n    /**\n     * @ignore\n     */ handleReconnection(err, item) {\n        var _a;\n        let needReconnect = false;\n        if (this.options.reconnectOnError && !Command_1.default.checkFlag(\"IGNORE_RECONNECT_ON_ERROR\", item.command.name)) {\n            needReconnect = this.options.reconnectOnError(err);\n        }\n        switch(needReconnect){\n            case 1:\n            case true:\n                if (this.status !== \"reconnecting\") {\n                    this.disconnect(true);\n                }\n                item.command.reject(err);\n                break;\n            case 2:\n                if (this.status !== \"reconnecting\") {\n                    this.disconnect(true);\n                }\n                if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.select) !== item.select && item.command.name !== \"select\") {\n                    this.select(item.select);\n                }\n                // TODO\n                // @ts-expect-error\n                this.sendCommand(item.command);\n                break;\n            default:\n                item.command.reject(err);\n        }\n    }\n    /**\n     * Get description of the connection. Used for debugging.\n     */ _getDescription() {\n        let description;\n        if (\"path\" in this.options && this.options.path) {\n            description = this.options.path;\n        } else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {\n            description = this.stream.remoteAddress + \":\" + this.stream.remotePort;\n        } else if (\"host\" in this.options && this.options.host) {\n            description = this.options.host + \":\" + this.options.port;\n        } else {\n            // Unexpected\n            description = \"\";\n        }\n        if (this.options.connectionName) {\n            description += ` (${this.options.connectionName})`;\n        }\n        return description;\n    }\n    resetCommandQueue() {\n        this.commandQueue = new Deque();\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    parseOptions(...args) {\n        const options = {};\n        let isTls = false;\n        for(let i = 0; i < args.length; ++i){\n            const arg = args[i];\n            if (arg === null || typeof arg === \"undefined\") {\n                continue;\n            }\n            if (typeof arg === \"object\") {\n                (0, lodash_1.defaults)(options, arg);\n            } else if (typeof arg === \"string\") {\n                (0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));\n                if (arg.startsWith(\"rediss://\")) {\n                    isTls = true;\n                }\n            } else if (typeof arg === \"number\") {\n                options.port = arg;\n            } else {\n                throw new Error(\"Invalid argument \" + arg);\n            }\n        }\n        if (isTls) {\n            (0, lodash_1.defaults)(options, {\n                tls: true\n            });\n        }\n        (0, lodash_1.defaults)(options, Redis.defaultOptions);\n        if (typeof options.port === \"string\") {\n            options.port = parseInt(options.port, 10);\n        }\n        if (typeof options.db === \"string\") {\n            options.db = parseInt(options.db, 10);\n        }\n        // @ts-expect-error\n        this.options = (0, utils_1.resolveTLSProfile)(options);\n    }\n    /**\n     * Change instance's status\n     */ setStatus(status, arg) {\n        // @ts-expect-error\n        if (debug.enabled) {\n            debug(\"status[%s]: %s -> %s\", this._getDescription(), this.status || \"[empty]\", status);\n        }\n        this.status = status;\n        process.nextTick(this.emit.bind(this, status, arg));\n    }\n    createScanStream(command, { key, options = {} }) {\n        return new ScanStream_1.default({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command,\n            ...options\n        });\n    }\n    /**\n     * Flush offline queue and command queue with error.\n     *\n     * @param error The error object to send to the commands\n     * @param options options\n     */ flushQueue(error, options) {\n        options = (0, lodash_1.defaults)({}, options, {\n            offlineQueue: true,\n            commandQueue: true\n        });\n        let item;\n        if (options.offlineQueue) {\n            while(item = this.offlineQueue.shift()){\n                item.command.reject(error);\n            }\n        }\n        if (options.commandQueue) {\n            if (this.commandQueue.length > 0) {\n                if (this.stream) {\n                    this.stream.removeAllListeners(\"data\");\n                }\n                while(item = this.commandQueue.shift()){\n                    item.command.reject(error);\n                }\n            }\n        }\n    }\n    /**\n     * Check whether Redis has finished loading the persistent data and is able to\n     * process commands.\n     */ _readyCheck(callback) {\n        const _this = this;\n        this.info(function(err, res) {\n            if (err) {\n                if (err.message && err.message.includes(\"NOPERM\")) {\n                    console.warn(`Skipping the ready check because INFO command fails: \"${err.message}\". You can disable ready check with \"enableReadyCheck\". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`);\n                    return callback(null, {});\n                }\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback(null, res);\n            }\n            const info = {};\n            const lines = res.split(\"\\r\\n\");\n            for(let i = 0; i < lines.length; ++i){\n                const [fieldName, ...fieldValueParts] = lines[i].split(\":\");\n                const fieldValue = fieldValueParts.join(\":\");\n                if (fieldValue) {\n                    info[fieldName] = fieldValue;\n                }\n            }\n            if (!info.loading || info.loading === \"0\") {\n                callback(null, info);\n            } else {\n                const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;\n                const retryTime = _this.options.maxLoadingRetryTime && _this.options.maxLoadingRetryTime < loadingEtaMs ? _this.options.maxLoadingRetryTime : loadingEtaMs;\n                debug(\"Redis server still loading, trying again in \" + retryTime + \"ms\");\n                setTimeout(function() {\n                    _this._readyCheck(callback);\n                }, retryTime);\n            }\n        }).catch(lodash_1.noop);\n    }\n}\nRedis.Cluster = cluster_1.default;\nRedis.Command = Command_1.default;\n/**\n * Default options\n */ Redis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;\n(0, applyMixin_1.default)(Redis, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Redis.prototype);\nexports[\"default\"] = Redis;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9SZWRpcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxhQUFhQyxtQkFBT0EsQ0FBQyxnRkFBbUI7QUFDOUMsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUUseUJBQXlCRixtQkFBT0EsQ0FBQyxzRkFBc0I7QUFDN0QsTUFBTUcsWUFBWUgsbUJBQU9BLENBQUMsc0VBQVc7QUFDckMsTUFBTUksWUFBWUosbUJBQU9BLENBQUMsZ0VBQVc7QUFDckMsTUFBTUssZUFBZUwsbUJBQU9BLENBQUMsNEVBQWM7QUFDM0MsTUFBTU0sc0JBQXNCTixtQkFBT0EsQ0FBQyxnSEFBZ0M7QUFDcEUsTUFBTU8sZUFBZVAsbUJBQU9BLENBQUMsd0ZBQXVCO0FBQ3BELE1BQU1RLGlCQUFpQlIsbUJBQU9BLENBQUMsc0ZBQXNCO0FBQ3JELE1BQU1TLGVBQWVULG1CQUFPQSxDQUFDLHNFQUFjO0FBQzNDLE1BQU1VLGdCQUFnQlYsbUJBQU9BLENBQUMsd0VBQWU7QUFDN0MsTUFBTVcsVUFBVVgsbUJBQU9BLENBQUMsa0VBQVM7QUFDakMsTUFBTVksZUFBZVosbUJBQU9BLENBQUMsa0ZBQW9CO0FBQ2pELE1BQU1hLGNBQWNiLG1CQUFPQSxDQUFDLGdGQUFtQjtBQUMvQyxNQUFNYyxXQUFXZCxtQkFBT0EsQ0FBQywwRUFBZ0I7QUFDekMsTUFBTWUsUUFBUWYsbUJBQU9BLENBQUMsb0RBQVE7QUFDOUIsTUFBTWdCLFFBQVEsQ0FBQyxHQUFHTCxRQUFRTSxLQUFLLEVBQUU7QUFDakM7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDRCxNQUFNQyxjQUFjTCxZQUFZTSxPQUFPO0lBQ25DQyxZQUFZQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSSxDQUFFO1FBQzFCLEtBQUs7UUFDTCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNk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LFNBQVMwQyxJQUFJO0lBQzFCO0FBQ0o7QUFDQXRDLE1BQU0yTSxPQUFPLEdBQUcxTixVQUFVZ0IsT0FBTztBQUNqQ0QsTUFBTTRNLE9BQU8sR0FBRzFOLFVBQVVlLE9BQU87QUFDakM7O0NBRUMsR0FDREQsTUFBTXFMLGNBQWMsR0FBRy9MLGVBQWV5SixxQkFBcUI7QUFDMUQsSUFBR3JKLGFBQWFPLE9BQU8sRUFBRUQsT0FBT2pCLFNBQVNrQyxZQUFZO0FBQ3JELElBQUd6QixjQUFjcU4scUJBQXFCLEVBQUU3TSxNQUFNOE0sU0FBUztBQUN4RG5PLGtCQUFlLEdBQUdxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvUmVkaXMuanM/NDhhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiQGlvcmVkaXMvY29tbWFuZHNcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBzdGFuZGFyZF9hc19jYWxsYmFja18xID0gcmVxdWlyZShcInN0YW5kYXJkLWFzLWNhbGxiYWNrXCIpO1xuY29uc3QgY2x1c3Rlcl8xID0gcmVxdWlyZShcIi4vY2x1c3RlclwiKTtcbmNvbnN0IENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL0NvbW1hbmRcIik7XG5jb25zdCBjb25uZWN0b3JzXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0b3JzXCIpO1xuY29uc3QgU2VudGluZWxDb25uZWN0b3JfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3RvcnMvU2VudGluZWxDb25uZWN0b3JcIik7XG5jb25zdCBldmVudEhhbmRsZXIgPSByZXF1aXJlKFwiLi9yZWRpcy9ldmVudF9oYW5kbGVyXCIpO1xuY29uc3QgUmVkaXNPcHRpb25zXzEgPSByZXF1aXJlKFwiLi9yZWRpcy9SZWRpc09wdGlvbnNcIik7XG5jb25zdCBTY2FuU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9TY2FuU3RyZWFtXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgYXBwbHlNaXhpbl8xID0gcmVxdWlyZShcIi4vdXRpbHMvYXBwbHlNaXhpblwiKTtcbmNvbnN0IENvbW1hbmRlcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvQ29tbWFuZGVyXCIpO1xuY29uc3QgbG9kYXNoXzEgPSByZXF1aXJlKFwiLi91dGlscy9sb2Rhc2hcIik7XG5jb25zdCBEZXF1ZSA9IHJlcXVpcmUoXCJkZW5xdWVcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCB1dGlsc18xLkRlYnVnKShcInJlZGlzXCIpO1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWpvciBjb21wb25lbnQgb2YgaW9yZWRpcy5cbiAqIFVzZSBpdCB0byBjb25uZWN0IHRvIGEgc3RhbmRhbG9uZSBSZWRpcyBzZXJ2ZXIgb3IgU2VudGluZWxzLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHJlZGlzID0gbmV3IFJlZGlzKCk7IC8vIERlZmF1bHQgcG9ydCBpcyA2Mzc5XG4gKiBhc3luYyBmdW5jdGlvbiBtYWluKCkge1xuICogICByZWRpcy5zZXQoXCJmb29cIiwgXCJiYXJcIik7XG4gKiAgIHJlZGlzLmdldChcImZvb1wiLCAoZXJyLCByZXN1bHQpID0+IHtcbiAqICAgICAvLyBgcmVzdWx0YCBzaG91bGQgYmUgXCJiYXJcIlxuICogICAgIGNvbnNvbGUubG9nKGVyciwgcmVzdWx0KTtcbiAqICAgfSk7XG4gKiAgIC8vIE9yIHVzZSBQcm9taXNlXG4gKiAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZGlzLmdldChcImZvb1wiKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBSZWRpcyBleHRlbmRzIENvbW1hbmRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBcIndhaXRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNDbHVzdGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkVwb2NoID0gMDtcbiAgICAgICAgdGhpcy5yZXRyeUF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5tYW51YWxseUNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gUHJlcGFyZSBhdXRvcGlwZWxpbmVzIHN0cnVjdHVyZXNcbiAgICAgICAgdGhpcy5fYXV0b1BpcGVsaW5lcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcnVubmluZ0F1dG9QaXBlbGluZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucGFyc2VPcHRpb25zKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgICBldmVudHNfMS5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZXNldENvbW1hbmRRdWV1ZSgpO1xuICAgICAgICB0aGlzLnJlc2V0T2ZmbGluZVF1ZXVlKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuQ29ubmVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyB0aGlzLm9wdGlvbnMuQ29ubmVjdG9yKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLnNlbnRpbmVscykge1xuICAgICAgICAgICAgY29uc3Qgc2VudGluZWxDb25uZWN0b3IgPSBuZXcgU2VudGluZWxDb25uZWN0b3JfMS5kZWZhdWx0KHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBzZW50aW5lbENvbm5lY3Rvci5lbWl0dGVyID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yID0gc2VudGluZWxDb25uZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG5ldyBjb25uZWN0b3JzXzEuU3RhbmRhbG9uZUNvbm5lY3Rvcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NyaXB0cykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5vcHRpb25zLnNjcmlwdHMpLmZvckVhY2goKFtuYW1lLCBkZWZpbml0aW9uXSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ29tbWFuZChuYW1lLCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZChvciB3YWl0KSAtPiBjb25uZWN0aW5nIC0+IGNvbm5lY3QgLT4gcmVhZHkgLT4gZW5kXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF6eUNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwid2FpdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKGxvZGFzaF8xLm5vb3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFJlZGlzIGluc3RhbmNlLlxuICAgICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgYG5ldyBSZWRpcygpYCBidXQgaXMgaW5jbHVkZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub2RlLXJlZGlzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVDbGllbnQoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFJlZGlzKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBnZXQgYXV0b1BpcGVsaW5lUXVldWVTaXplKCkge1xuICAgICAgICBsZXQgcXVldWVkID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBwaXBlbGluZSBvZiB0aGlzLl9hdXRvUGlwZWxpbmVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBxdWV1ZWQgKz0gcGlwZWxpbmUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWV1ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbm5lY3Rpb24gdG8gUmVkaXMuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBpbnZva2VkIGF1dG9tYXRpY2FsbHkgd2hlbiBjcmVhdGluZyBhIG5ldyBSZWRpcyBpbnN0YW5jZVxuICAgICAqIHVubGVzcyBgbGF6eUNvbm5lY3Q6IHRydWVgIGlzIHBhc3NlZC5cbiAgICAgKlxuICAgICAqIFdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBtYW51YWxseSwgYSBQcm9taXNlIGlzIHJldHVybmVkLCB3aGljaCB3aWxsXG4gICAgICogYmUgcmVzb2x2ZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBzdGF0dXMgaXMgcmVhZHkuIFRoZSBwcm9taXNlIGNhbiByZWplY3RcbiAgICAgKiBpZiB0aGUgY29ubmVjdGlvbiBmYWlscywgdGltZXMgb3V0LCBvciBpZiBSZWRpcyBpcyBhbHJlYWR5IGNvbm5lY3RpbmcvY29ubmVjdGVkLlxuICAgICAqL1xuICAgIGNvbm5lY3QoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJjb25uZWN0aW5nXCIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJjb25uZWN0XCIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlJlZGlzIGlzIGFscmVhZHkgY29ubmVjdGluZy9jb25uZWN0ZWRcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbkVwb2NoICs9IDE7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImNvbm5lY3RpbmdcIik7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IG9wdGlvbnMuZGIsXG4gICAgICAgICAgICAgICAgYXV0aDogb3B0aW9ucy51c2VybmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFtvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkXVxuICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbnMucGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcjogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkodGhpcy5jb25uZWN0b3IuY29ubmVjdChmdW5jdGlvbiAodHlwZSwgZXJyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2lsZW50RW1pdCh0eXBlLCBlcnIpO1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uIChlcnIsIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmx1c2hRdWV1ZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaWxlbnRFbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXR1cyhcImVuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgQ09OTkVDVF9FVkVOVCA9IG9wdGlvbnMudGxzID8gXCJzZWN1cmVDb25uZWN0XCIgOiBcImNvbm5lY3RcIjtcbiAgICAgICAgICAgICAgICBpZiAoXCJzZW50aW5lbHNcIiBpbiBvcHRpb25zICYmXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VudGluZWxzICYmXG4gICAgICAgICAgICAgICAgICAgICFvcHRpb25zLmVuYWJsZVRMU0ZvclNlbnRpbmVsTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBDT05ORUNUX0VWRU5UID0gXCJjb25uZWN0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ub0RlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5zZXROb0RlbGF5KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOb2RlIGlnbm9yZXMgc2V0S2VlcEFsaXZlIGJlZm9yZSBjb25uZWN0LCB0aGVyZWZvcmUgd2Ugd2FpdCBmb3IgdGhlIGV2ZW50OlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzE2NjNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMua2VlcEFsaXZlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uY2UoQ09OTkVDVF9FVkVOVCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5zZXRLZWVwQWxpdmUodHJ1ZSwgb3B0aW9ucy5rZWVwQWxpdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uc2V0S2VlcEFsaXZlKHRydWUsIG9wdGlvbnMua2VlcEFsaXZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uY2UoQ09OTkVDVF9FVkVOVCwgZXZlbnRIYW5kbGVyLmNvbm5lY3RIYW5kbGVyKF90aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogVHlwaWNhbGx5LCBTb2NrZXQjc2V0VGltZW91dCgwKSB3aWxsIGNsZWFyIHRoZSB0aW1lclxuICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IGJlZm9yZS4gSG93ZXZlciwgaW4gc29tZSBwbGF0Zm9ybXMgKEVsZWN0cm9uIDMueH40LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlIHRpbWVyIHdpbGwgbm90IGJlIGNsZWFyZWQuIFNvIHdlIGludHJvZHVjZSBhIHZhcmlhYmxlIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi9lbGVjdHJvbi9pc3N1ZXMvMTQ5MTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3RUaW1lb3V0Q2xlYXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnNldFRpbWVvdXQob3B0aW9ucy5jb25uZWN0VGltZW91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0VGltZW91dENsZWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uc2V0VGltZW91dCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcImNvbm5lY3QgRVRJTUVET1VUXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuZXJyb3JubyA9IFwiRVRJTUVET1VUXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gXCJFVElNRURPVVRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN5c2NhbGwgPSBcImNvbm5lY3RcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIuZXJyb3JIYW5kbGVyKF90aGlzKShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub25jZShDT05ORUNUX0VWRU5ULCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdFRpbWVvdXRDbGVhcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uc2V0VGltZW91dCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RFcnJvciA9IF90aGlzLmNvbm5lY3Rvci5maXJzdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmVycm9ySGFuZGxlcihfdGhpcykoZmlyc3RFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGV2ZW50SGFuZGxlci5jbG9zZUhhbmRsZXIoX3RoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZXZlbnRIYW5kbGVyLmNvbm5lY3RIYW5kbGVyKF90aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub25jZShcImVycm9yXCIsIGV2ZW50SGFuZGxlci5lcnJvckhhbmRsZXIoX3RoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uY2UoXCJjbG9zZVwiLCBldmVudEhhbmRsZXIuY2xvc2VIYW5kbGVyKF90aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25SZWFkeUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgY29ubmVjdGlvbkNsb3NlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0aW9uQ2xvc2VIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVMaXN0ZW5lcihcInJlYWR5XCIsIGNvbm5lY3Rpb25SZWFkeUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmNlKFwicmVhZHlcIiwgY29ubmVjdGlvblJlYWR5SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgX3RoaXMub25jZShcImNsb3NlXCIsIGNvbm5lY3Rpb25DbG9zZUhhbmRsZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkocHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGZyb20gUmVkaXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjbG9zZXMgdGhlIGNvbm5lY3Rpb24gaW1tZWRpYXRlbHksXG4gICAgICogYW5kIG1heSBsb3NlIHNvbWUgcGVuZGluZyByZXBsaWVzIHRoYXQgaGF2ZW4ndCB3cml0dGVuIHRvIGNsaWVudC5cbiAgICAgKiBJZiB5b3Ugd2FudCB0byB3YWl0IGZvciB0aGUgcGVuZGluZyByZXBsaWVzLCB1c2UgUmVkaXMjcXVpdCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QocmVjb25uZWN0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFyZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMubWFudWFsbHlDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0ICYmICFyZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwid2FpdFwiKSB7XG4gICAgICAgICAgICBldmVudEhhbmRsZXIuY2xvc2VIYW5kbGVyKHRoaXMpKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBmcm9tIFJlZGlzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBvcHRpb25zIGFzIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgcmVkaXMgPSBuZXcgUmVkaXMoNjM4MCk7XG4gICAgICogdmFyIGFub3RoZXJSZWRpcyA9IHJlZGlzLmR1cGxpY2F0ZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGR1cGxpY2F0ZShvdmVycmlkZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZGlzKHsgLi4udGhpcy5vcHRpb25zLCAuLi5vdmVycmlkZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9kZSBvZiB0aGUgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIE9uZSBvZiBgXCJub3JtYWxcImAsIGBcInN1YnNjcmliZXJcImAsIG9yIGBcIm1vbml0b3JcImAuIFdoZW4gdGhlIGNvbm5lY3Rpb24gaXNcbiAgICAgKiBub3QgaW4gYFwibm9ybWFsXCJgIG1vZGUsIGNlcnRhaW4gY29tbWFuZHMgYXJlIG5vdCBhbGxvd2VkLlxuICAgICAqL1xuICAgIGdldCBtb2RlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubW9uaXRvclxuICAgICAgICAgICAgPyBcIm1vbml0b3JcIlxuICAgICAgICAgICAgOiAoKF9hID0gdGhpcy5jb25kaXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJzY3JpYmVyKVxuICAgICAgICAgICAgICAgID8gXCJzdWJzY3JpYmVyXCJcbiAgICAgICAgICAgICAgICA6IFwibm9ybWFsXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgYWxsIHJlcXVlc3RzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIgaW4gcmVhbCB0aW1lLlxuICAgICAqXG4gICAgICogVGhpcyBjb21tYW5kIHdpbGwgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24gdG8gUmVkaXMgYW5kIHNlbmQgYVxuICAgICAqIE1PTklUT1IgY29tbWFuZCB2aWEgdGhlIG5ldyBjb25uZWN0aW9uIGluIG9yZGVyIHRvIGF2b2lkIGRpc3R1cmJpbmdcbiAgICAgKiB0aGUgY3VycmVudCBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbi4gSWYgb21pdCwgYSBwcm9taXNlIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciByZWRpcyA9IG5ldyBSZWRpcygpO1xuICAgICAqIHJlZGlzLm1vbml0b3IoZnVuY3Rpb24gKGVyciwgbW9uaXRvcikge1xuICAgICAqICAgLy8gRW50ZXJpbmcgbW9uaXRvcmluZyBtb2RlLlxuICAgICAqICAgbW9uaXRvci5vbignbW9uaXRvcicsIGZ1bmN0aW9uICh0aW1lLCBhcmdzLCBzb3VyY2UsIGRhdGFiYXNlKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHRpbWUgKyBcIjogXCIgKyB1dGlsLmluc3BlY3QoYXJncykpO1xuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBzdXBwb3J0cyBwcm9taXNlIGFzIHdlbGwgYXMgb3RoZXIgY29tbWFuZHNcbiAgICAgKiByZWRpcy5tb25pdG9yKCkudGhlbihmdW5jdGlvbiAobW9uaXRvcikge1xuICAgICAqICAgbW9uaXRvci5vbignbW9uaXRvcicsIGZ1bmN0aW9uICh0aW1lLCBhcmdzLCBzb3VyY2UsIGRhdGFiYXNlKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHRpbWUgKyBcIjogXCIgKyB1dGlsLmluc3BlY3QoYXJncykpO1xuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbW9uaXRvcihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBtb25pdG9ySW5zdGFuY2UgPSB0aGlzLmR1cGxpY2F0ZSh7XG4gICAgICAgICAgICBtb25pdG9yOiB0cnVlLFxuICAgICAgICAgICAgbGF6eUNvbm5lY3Q6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIG1vbml0b3JJbnN0YW5jZS5vbmNlKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgIG1vbml0b3JJbnN0YW5jZS5vbmNlKFwibW9uaXRvcmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtb25pdG9ySW5zdGFuY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBjb21tYW5kIHRvIFJlZGlzXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGludGVybmFsbHkgYW5kIGluIG1vc3QgY2FzZXMgeW91IHNob3VsZCBub3RcbiAgICAgKiB1c2UgaXQgZGlyZWN0bHkuIElmIHlvdSBuZWVkIHRvIHNlbmQgYSBjb21tYW5kIHRoYXQgaXMgbm90IHN1cHBvcnRlZFxuICAgICAqIGJ5IHRoZSBsaWJyYXJ5LCB5b3UgY2FuIHVzZSB0aGUgYGNhbGxgIG1ldGhvZDpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgcmVkaXMgPSBuZXcgUmVkaXMoKTtcbiAgICAgKlxuICAgICAqIHJlZGlzLmNhbGwoJ3NldCcsICdmb28nLCAnYmFyJyk7XG4gICAgICogLy8gb3JcbiAgICAgKiByZWRpcy5jYWxsKFsnc2V0JywgJ2ZvbycsICdiYXInXSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgc2VuZENvbW1hbmQoY29tbWFuZCwgc3RyZWFtKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJ3YWl0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKGxvZGFzaF8xLm5vb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IEVycm9yKHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKSk7XG4gICAgICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5jb25kaXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJzY3JpYmVyKSAmJlxuICAgICAgICAgICAgIUNvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIlZBTElEX0lOX1NVQlNDUklCRVJfTU9ERVwiLCBjb21tYW5kLm5hbWUpKSB7XG4gICAgICAgICAgICBjb21tYW5kLnJlamVjdChuZXcgRXJyb3IoXCJDb25uZWN0aW9uIGluIHN1YnNjcmliZXIgbW9kZSwgb25seSBzdWJzY3JpYmVyIGNvbW1hbmRzIG1heSBiZSB1c2VkXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kLnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuY29tbWFuZFRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbW1hbmQuc2V0VGltZW91dCh0aGlzLm9wdGlvbnMuY29tbWFuZFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NraW5nVGltZW91dCA9IHRoaXMuZ2V0QmxvY2tpbmdUaW1lb3V0SW5Ncyhjb21tYW5kKTtcbiAgICAgICAgbGV0IHdyaXRhYmxlID0gdGhpcy5zdGF0dXMgPT09IFwicmVhZHlcIiB8fFxuICAgICAgICAgICAgKCFzdHJlYW0gJiZcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJjb25uZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAoMCwgY29tbWFuZHNfMS5leGlzdHMpKGNvbW1hbmQubmFtZSwgeyBjYXNlSW5zZW5zaXRpdmU6IHRydWUgfSkgJiZcbiAgICAgICAgICAgICAgICAoKDAsIGNvbW1hbmRzXzEuaGFzRmxhZykoY29tbWFuZC5uYW1lLCBcImxvYWRpbmdcIiwgeyBuYW1lQ2FzZUluc2Vuc2l0aXZlOiB0cnVlIH0pIHx8XG4gICAgICAgICAgICAgICAgICAgIENvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIkhBTkRTSEFLRV9DT01NQU5EU1wiLCBjb21tYW5kLm5hbWUpKSk7XG4gICAgICAgIGlmICghdGhpcy5zdHJlYW0pIHtcbiAgICAgICAgICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3RyZWFtLndyaXRhYmxlKSB7XG4gICAgICAgICAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHRoaXMuc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyBhcyB0aGUgUFIgaGFzIGFscmVhZHkgYmVlbiBtZXJnZWQuXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaW9qcy9pby5qcy9wdWxsLzEyMTdcbiAgICAgICAgICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3cml0YWJsZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlT2ZmbGluZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IEVycm9yKFwiU3RyZWFtIGlzbid0IHdyaXRlYWJsZSBhbmQgZW5hYmxlT2ZmbGluZVF1ZXVlIG9wdGlvbnMgaXMgZmFsc2VcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tbWFuZC5uYW1lID09PSBcInF1aXRcIiAmJiB0aGlzLm9mZmxpbmVRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBjb21tYW5kLnJlc29sdmUoQnVmZmVyLmZyb20oXCJPS1wiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJxdWV1ZSBjb21tYW5kWyVzXTogJWQgLT4gJXMoJW8pXCIsIHRoaXMuX2dldERlc2NyaXB0aW9uKCksIHRoaXMuY29uZGl0aW9uLnNlbGVjdCwgY29tbWFuZC5uYW1lLCBjb21tYW5kLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vZmZsaW5lUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgICAgICAgICBzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHRoaXMuY29uZGl0aW9uLnNlbGVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRm9yIGJsb2NraW5nIGNvbW1hbmRzIGluIHRoZSBvZmZsaW5lIHF1ZXVlLCBhcm0gYSBjbGllbnQtc2lkZSB0aW1lb3V0XG4gICAgICAgICAgICAvLyBvbmx5IHdoZW4gYmxvY2tpbmdUaW1lb3V0IGlzIGNvbmZpZ3VyZWQuIFdpdGhvdXQgdGhpcyBvcHRpb24sIHF1ZXVlZFxuICAgICAgICAgICAgLy8gYmxvY2tpbmcgY29tbWFuZHMgbWF5IHdhaXQgaW5kZWZpbml0ZWx5IG9uIGEgZGVhZCBjb25uZWN0aW9uLlxuICAgICAgICAgICAgaWYgKENvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIkJMT0NLSU5HX0NPTU1BTkRTXCIsIGNvbW1hbmQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZsaW5lVGltZW91dCA9IHRoaXMuZ2V0Q29uZmlndXJlZEJsb2NraW5nVGltZW91dCgpO1xuICAgICAgICAgICAgICAgIGlmIChvZmZsaW5lVGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQuc2V0QmxvY2tpbmdUaW1lb3V0KG9mZmxpbmVUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBpZiAoZGVidWcuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwid3JpdGUgY29tbWFuZFslc106ICVkIC0+ICVzKCVvKVwiLCB0aGlzLl9nZXREZXNjcmlwdGlvbigpLCAoX2IgPSB0aGlzLmNvbmRpdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNlbGVjdCwgY29tbWFuZC5uYW1lLCBjb21tYW5kLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGlmIChcImlzUGlwZWxpbmVcIiBpbiBzdHJlYW0gJiYgc3RyZWFtLmlzUGlwZWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLndyaXRlKGNvbW1hbmQudG9Xcml0YWJsZShzdHJlYW0uZGVzdGluYXRpb24ucmVkaXMuc3RyZWFtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ud3JpdGUoY29tbWFuZC50b1dyaXRhYmxlKHN0cmVhbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKGNvbW1hbmQudG9Xcml0YWJsZSh0aGlzLnN0cmVhbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21tYW5kUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgICAgICAgICBzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHRoaXMuY29uZGl0aW9uLnNlbGVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGJsb2NraW5nVGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZC5zZXRCbG9ja2luZ1RpbWVvdXQoYmxvY2tpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChDb21tYW5kXzEuZGVmYXVsdC5jaGVja0ZsYWcoXCJXSUxMX0RJU0NPTk5FQ1RcIiwgY29tbWFuZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFudWFsbHlDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc29ja2V0VGltZW91dCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc29ja2V0VGltZW91dFRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNvY2tldFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC5uYW1lID09PSBcInNlbGVjdFwiICYmICgwLCB1dGlsc18xLmlzSW50KShjb21tYW5kLmFyZ3NbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBkYiA9IHBhcnNlSW50KGNvbW1hbmQuYXJnc1swXSwgMTApO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uLnNlbGVjdCAhPT0gZGIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5zZWxlY3QgPSBkYjtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJzZWxlY3RcIiwgZGIpO1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic3dpdGNoIHRvIGRiIFslZF1cIiwgdGhpcy5jb25kaXRpb24uc2VsZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgIH1cbiAgICBnZXRCbG9ja2luZ1RpbWVvdXRJbk1zKGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIUNvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIkJMT0NLSU5HX0NPTU1BTkRTXCIsIGNvbW1hbmQubmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmVhdHVyZSBpcyBvcHQtaW46IG9ubHkgZW5hYmxlZCB3aGVuIGJsb2NraW5nVGltZW91dCBpcyBzZXQgdG8gYSBwb3NpdGl2ZSBudW1iZXJcbiAgICAgICAgY29uc3QgY29uZmlndXJlZFRpbWVvdXQgPSB0aGlzLmdldENvbmZpZ3VyZWRCbG9ja2luZ1RpbWVvdXQoKTtcbiAgICAgICAgaWYgKGNvbmZpZ3VyZWRUaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZW91dCA9IGNvbW1hbmQuZXh0cmFjdEJsb2NraW5nVGltZW91dCgpO1xuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEZpbml0ZSB0aW1lb3V0IGZyb20gY29tbWFuZCBhcmdzIC0gYWRkIGdyYWNlIHBlcmlvZFxuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lb3V0ICsgKChfYSA9IHRoaXMub3B0aW9ucy5ibG9ja2luZ1RpbWVvdXRHcmFjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogUmVkaXNPcHRpb25zXzEuREVGQVVMVF9SRURJU19PUFRJT05TLmJsb2NraW5nVGltZW91dEdyYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbW1hbmQgaGFzIHRpbWVvdXQ9MCAoYmxvY2sgZm9yZXZlciksIHVzZSBibG9ja2luZ1RpbWVvdXQgb3B0aW9uIGFzIHNhZmV0eSBuZXRcbiAgICAgICAgICAgIHJldHVybiBjb25maWd1cmVkVGltZW91dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZW91dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gTm8gQkxPQ0sgb3B0aW9uIGZvdW5kIChlLmcuLCBYUkVBRCB3aXRob3V0IEJMT0NLKSwgdXNlIGJsb2NraW5nVGltZW91dCBhcyBzYWZldHkgbmV0XG4gICAgICAgICAgICByZXR1cm4gY29uZmlndXJlZFRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0Q29uZmlndXJlZEJsb2NraW5nVGltZW91dCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYmxvY2tpbmdUaW1lb3V0ID09PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYmxvY2tpbmdUaW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ibG9ja2luZ1RpbWVvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0U29ja2V0VGltZW91dCgpIHtcbiAgICAgICAgdGhpcy5zb2NrZXRUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKGBTb2NrZXQgdGltZW91dC4gRXhwZWN0aW5nIGRhdGEsIGJ1dCBkaWRuJ3QgcmVjZWl2ZSBhbnkgaW4gJHt0aGlzLm9wdGlvbnMuc29ja2V0VGltZW91dH1tcy5gKSk7XG4gICAgICAgICAgICB0aGlzLnNvY2tldFRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLnNvY2tldFRpbWVvdXQpO1xuICAgICAgICAvLyB0aGlzIGhhbmRsZXIgbXVzdCBydW4gYWZ0ZXIgdGhlIFwiZGF0YVwiIGhhbmRsZXIgaW4gXCJEYXRhSGFuZGxlclwiXG4gICAgICAgIC8vIHNvIHRoYXQgYHRoaXMuY29tbWFuZFF1ZXVlLmxlbmd0aGAgd2lsbCBiZSB1cGRhdGVkXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoXCJkYXRhXCIsICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNvY2tldFRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnNvY2tldFRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbW1hbmRRdWV1ZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zZXRTb2NrZXRUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2FuU3RyZWFtKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInNjYW5cIiwgeyBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBzY2FuQnVmZmVyU3RyZWFtKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInNjYW5CdWZmZXJcIiwgeyBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBzc2NhblN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInNzY2FuXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBzc2NhbkJ1ZmZlclN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInNzY2FuQnVmZmVyXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBoc2NhblN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcImhzY2FuXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBoc2NhbkJ1ZmZlclN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcImhzY2FuQnVmZmVyXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICB6c2NhblN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInpzY2FuXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICB6c2NhbkJ1ZmZlclN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInpzY2FuQnVmZmVyXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IG9ubHkgd2hlbiB0aGVyZSdzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lci5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBzaWxlbnRFbWl0KGV2ZW50TmFtZSwgYXJnKSB7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBlcnJvciA9IGFyZztcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1hbnVhbGx5Q2xvc2luZykge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBjb25uZWN0aW9uIHJlbGF0ZWQgZXJyb3JzIHdoZW4gbWFudWFsbHkgZGlzY29ubmVjdGluZ1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIChlcnJvci5tZXNzYWdlID09PSB1dGlsc18xLkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3lzY2FsbCA9PT0gXCJjb25uZWN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnN5c2NhbGwgPT09IFwicmVhZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVycyhldmVudE5hbWUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltpb3JlZGlzXSBVbmhhbmRsZWQgZXJyb3IgZXZlbnQ6XCIsIGVycm9yLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZWNvdmVyRnJvbUZhdGFsRXJyb3IoX2NvbW1hbmRFcnJvciwgZXJyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZmx1c2hRdWV1ZShlcnIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNpbGVudEVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QodHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBoYW5kbGVSZWNvbm5lY3Rpb24oZXJyLCBpdGVtKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IG5lZWRSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWNvbm5lY3RPbkVycm9yICYmXG4gICAgICAgICAgICAhQ29tbWFuZF8xLmRlZmF1bHQuY2hlY2tGbGFnKFwiSUdOT1JFX1JFQ09OTkVDVF9PTl9FUlJPUlwiLCBpdGVtLmNvbW1hbmQubmFtZSkpIHtcbiAgICAgICAgICAgIG5lZWRSZWNvbm5lY3QgPSB0aGlzLm9wdGlvbnMucmVjb25uZWN0T25FcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobmVlZFJlY29ubmVjdCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJyZWNvbm5lY3RpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwicmVjb25uZWN0aW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuY29uZGl0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VsZWN0KSAhPT0gaXRlbS5zZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jb21tYW5kLm5hbWUgIT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QoaXRlbS5zZWxlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQoaXRlbS5jb21tYW5kKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaXRlbS5jb21tYW5kLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBkZXNjcmlwdGlvbiBvZiB0aGUgY29ubmVjdGlvbi4gVXNlZCBmb3IgZGVidWdnaW5nLlxuICAgICAqL1xuICAgIF9nZXREZXNjcmlwdGlvbigpIHtcbiAgICAgICAgbGV0IGRlc2NyaXB0aW9uO1xuICAgICAgICBpZiAoXCJwYXRoXCIgaW4gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IHRoaXMub3B0aW9ucy5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RyZWFtICYmXG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5yZW1vdGVBZGRyZXNzICYmXG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5yZW1vdGVQb3J0KSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IHRoaXMuc3RyZWFtLnJlbW90ZUFkZHJlc3MgKyBcIjpcIiArIHRoaXMuc3RyZWFtLnJlbW90ZVBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJob3N0XCIgaW4gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5ob3N0KSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IHRoaXMub3B0aW9ucy5ob3N0ICsgXCI6XCIgKyB0aGlzLm9wdGlvbnMucG9ydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWRcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbm5lY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgICgke3RoaXMub3B0aW9ucy5jb25uZWN0aW9uTmFtZX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxuICAgIHJlc2V0Q29tbWFuZFF1ZXVlKCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRRdWV1ZSA9IG5ldyBEZXF1ZSgpO1xuICAgIH1cbiAgICByZXNldE9mZmxpbmVRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5vZmZsaW5lUXVldWUgPSBuZXcgRGVxdWUoKTtcbiAgICB9XG4gICAgcGFyc2VPcHRpb25zKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBsZXQgaXNUbHMgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgICAgICAgICAgaWYgKGFyZyA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICgwLCBsb2Rhc2hfMS5kZWZhdWx0cykob3B0aW9ucywgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAoMCwgbG9kYXNoXzEuZGVmYXVsdHMpKG9wdGlvbnMsICgwLCB1dGlsc18xLnBhcnNlVVJMKShhcmcpKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLnN0YXJ0c1dpdGgoXCJyZWRpc3M6Ly9cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNUbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBvcnQgPSBhcmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IFwiICsgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUbHMpIHtcbiAgICAgICAgICAgICgwLCBsb2Rhc2hfMS5kZWZhdWx0cykob3B0aW9ucywgeyB0bHM6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGxvZGFzaF8xLmRlZmF1bHRzKShvcHRpb25zLCBSZWRpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvcnQgPSBwYXJzZUludChvcHRpb25zLnBvcnQsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGIgPSBwYXJzZUludChvcHRpb25zLmRiLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSAoMCwgdXRpbHNfMS5yZXNvbHZlVExTUHJvZmlsZSkob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSBpbnN0YW5jZSdzIHN0YXR1c1xuICAgICAqL1xuICAgIHNldFN0YXR1cyhzdGF0dXMsIGFyZykge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInN0YXR1c1slc106ICVzIC0+ICVzXCIsIHRoaXMuX2dldERlc2NyaXB0aW9uKCksIHRoaXMuc3RhdHVzIHx8IFwiW2VtcHR5XVwiLCBzdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW1pdC5iaW5kKHRoaXMsIHN0YXR1cywgYXJnKSk7XG4gICAgfVxuICAgIGNyZWF0ZVNjYW5TdHJlYW0oY29tbWFuZCwgeyBrZXksIG9wdGlvbnMgPSB7fSB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NhblN0cmVhbV8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgcmVkaXM6IHRoaXMsXG4gICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoIG9mZmxpbmUgcXVldWUgYW5kIGNvbW1hbmQgcXVldWUgd2l0aCBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnJvciBUaGUgZXJyb3Igb2JqZWN0IHRvIHNlbmQgdG8gdGhlIGNvbW1hbmRzXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uc1xuICAgICAqL1xuICAgIGZsdXNoUXVldWUoZXJyb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9ICgwLCBsb2Rhc2hfMS5kZWZhdWx0cykoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIG9mZmxpbmVRdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbW1hbmRRdWV1ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBpdGVtO1xuICAgICAgICBpZiAob3B0aW9ucy5vZmZsaW5lUXVldWUpIHtcbiAgICAgICAgICAgIHdoaWxlICgoaXRlbSA9IHRoaXMub2ZmbGluZVF1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jb21tYW5kLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY29tbWFuZFF1ZXVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21tYW5kUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJkYXRhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoKGl0ZW0gPSB0aGlzLmNvbW1hbmRRdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbW1hbmQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciBSZWRpcyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgcGVyc2lzdGVudCBkYXRhIGFuZCBpcyBhYmxlIHRvXG4gICAgICogcHJvY2VzcyBjb21tYW5kcy5cbiAgICAgKi9cbiAgICBfcmVhZHlDaGVjayhjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5mbyhmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJOT1BFUk1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTa2lwcGluZyB0aGUgcmVhZHkgY2hlY2sgYmVjYXVzZSBJTkZPIGNvbW1hbmQgZmFpbHM6IFwiJHtlcnIubWVzc2FnZX1cIi4gWW91IGNhbiBkaXNhYmxlIHJlYWR5IGNoZWNrIHdpdGggXCJlbmFibGVSZWFkeUNoZWNrXCIuIE1vcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9sdWluL2lvcmVkaXMvd2lraS9EaXNhYmxlLXJlYWR5LWNoZWNrLmApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmZvID0ge307XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHJlcy5zcGxpdChcIlxcclxcblwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZmllbGROYW1lLCAuLi5maWVsZFZhbHVlUGFydHNdID0gbGluZXNbaV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSBmaWVsZFZhbHVlUGFydHMuam9pbihcIjpcIik7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mb1tmaWVsZE5hbWVdID0gZmllbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWluZm8ubG9hZGluZyB8fCBpbmZvLmxvYWRpbmcgPT09IFwiMFwiKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkaW5nRXRhTXMgPSAoaW5mby5sb2FkaW5nX2V0YV9zZWNvbmRzIHx8IDEpICogMTAwMDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeVRpbWUgPSBfdGhpcy5vcHRpb25zLm1heExvYWRpbmdSZXRyeVRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5tYXhMb2FkaW5nUmV0cnlUaW1lIDwgbG9hZGluZ0V0YU1zXG4gICAgICAgICAgICAgICAgICAgID8gX3RoaXMub3B0aW9ucy5tYXhMb2FkaW5nUmV0cnlUaW1lXG4gICAgICAgICAgICAgICAgICAgIDogbG9hZGluZ0V0YU1zO1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiUmVkaXMgc2VydmVyIHN0aWxsIGxvYWRpbmcsIHRyeWluZyBhZ2FpbiBpbiBcIiArIHJldHJ5VGltZSArIFwibXNcIik7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZWFkeUNoZWNrKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9LCByZXRyeVRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChsb2Rhc2hfMS5ub29wKTtcbiAgICB9XG59XG5SZWRpcy5DbHVzdGVyID0gY2x1c3Rlcl8xLmRlZmF1bHQ7XG5SZWRpcy5Db21tYW5kID0gQ29tbWFuZF8xLmRlZmF1bHQ7XG4vKipcbiAqIERlZmF1bHQgb3B0aW9uc1xuICovXG5SZWRpcy5kZWZhdWx0T3B0aW9ucyA9IFJlZGlzT3B0aW9uc18xLkRFRkFVTFRfUkVESVNfT1BUSU9OUztcbigwLCBhcHBseU1peGluXzEuZGVmYXVsdCkoUmVkaXMsIGV2ZW50c18xLkV2ZW50RW1pdHRlcik7XG4oMCwgdHJhbnNhY3Rpb25fMS5hZGRUcmFuc2FjdGlvblN1cHBvcnQpKFJlZGlzLnByb3RvdHlwZSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZWRpcztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNvbW1hbmRzXzEiLCJyZXF1aXJlIiwiZXZlbnRzXzEiLCJzdGFuZGFyZF9hc19jYWxsYmFja18xIiwiY2x1c3Rlcl8xIiwiQ29tbWFuZF8xIiwiY29ubmVjdG9yc18xIiwiU2VudGluZWxDb25uZWN0b3JfMSIsImV2ZW50SGFuZGxlciIsIlJlZGlzT3B0aW9uc18xIiwiU2NhblN0cmVhbV8xIiwidHJhbnNhY3Rpb25fMSIsInV0aWxzXzEiLCJhcHBseU1peGluXzEiLCJDb21tYW5kZXJfMSIsImxvZGFzaF8xIiwiRGVxdWUiLCJkZWJ1ZyIsIkRlYnVnIiwiUmVkaXMiLCJkZWZhdWx0IiwiY29uc3RydWN0b3IiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJzdGF0dXMiLCJpc0NsdXN0ZXIiLCJyZWNvbm5lY3RUaW1lb3V0IiwiY29ubmVjdGlvbkVwb2NoIiwicmV0cnlBdHRlbXB0cyIsIm1hbnVhbGx5Q2xvc2luZyIsIl9hdXRvUGlwZWxpbmVzIiwiTWFwIiwiX3J1bm5pbmdBdXRvUGlwZWxpbmVzIiwiU2V0IiwicGFyc2VPcHRpb25zIiwiRXZlbnRFbWl0dGVyIiwiY2FsbCIsInJlc2V0Q29tbWFuZFF1ZXVlIiwicmVzZXRPZmZsaW5lUXVldWUiLCJvcHRpb25zIiwiQ29ubmVjdG9yIiwiY29ubmVjdG9yIiwic2VudGluZWxzIiwic2VudGluZWxDb25uZWN0b3IiLCJlbWl0dGVyIiwiU3RhbmRhbG9uZUNvbm5lY3RvciIsInNjcmlwdHMiLCJlbnRyaWVzIiwiZm9yRWFjaCIsIm5hbWUiLCJkZWZpbml0aW9uIiwiZGVmaW5lQ29tbWFuZCIsImxhenlDb25uZWN0Iiwic2V0U3RhdHVzIiwiY29ubmVjdCIsImNhdGNoIiwibm9vcCIsImNyZWF0ZUNsaWVudCIsImFyZ3MiLCJhdXRvUGlwZWxpbmVRdWV1ZVNpemUiLCJxdWV1ZWQiLCJwaXBlbGluZSIsInZhbHVlcyIsImxlbmd0aCIsImNhbGxiYWNrIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiRXJyb3IiLCJjb25kaXRpb24iLCJzZWxlY3QiLCJkYiIsImF1dGgiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwic3Vic2NyaWJlciIsIl90aGlzIiwidHlwZSIsImVyciIsInNpbGVudEVtaXQiLCJzdHJlYW0iLCJmbHVzaFF1ZXVlIiwiQ09OTkVDVF9FVkVOVCIsInRscyIsImVuYWJsZVRMU0ZvclNlbnRpbmVsTW9kZSIsIm5vRGVsYXkiLCJzZXROb0RlbGF5Iiwia2VlcEFsaXZlIiwiY29ubmVjdGluZyIsIm9uY2UiLCJzZXRLZWVwQWxpdmUiLCJjb25uZWN0SGFuZGxlciIsImNvbm5lY3RUaW1lb3V0IiwiY29ubmVjdFRpbWVvdXRDbGVhcmVkIiwic2V0VGltZW91dCIsImRlc3Ryb3kiLCJlcnJvcm5vIiwiY29kZSIsInN5c2NhbGwiLCJlcnJvckhhbmRsZXIiLCJkZXN0cm95ZWQiLCJmaXJzdEVycm9yIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2xvc2VIYW5kbGVyIiwiY29ubmVjdGlvblJlYWR5SGFuZGxlciIsInJlbW92ZUxpc3RlbmVyIiwiY29ubmVjdGlvbkNsb3NlSGFuZGxlciIsIkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyIsImRpc2Nvbm5lY3QiLCJyZWNvbm5lY3QiLCJjbGVhclRpbWVvdXQiLCJlbmQiLCJkdXBsaWNhdGUiLCJvdmVycmlkZSIsIm1vZGUiLCJfYSIsIm1vbml0b3IiLCJtb25pdG9ySW5zdGFuY2UiLCJzZW5kQ29tbWFuZCIsImNvbW1hbmQiLCJfYiIsImNoZWNrRmxhZyIsImNvbW1hbmRUaW1lb3V0IiwiYmxvY2tpbmdUaW1lb3V0IiwiZ2V0QmxvY2tpbmdUaW1lb3V0SW5NcyIsIndyaXRhYmxlIiwiZXhpc3RzIiwiY2FzZUluc2Vuc2l0aXZlIiwiaGFzRmxhZyIsIm5hbWVDYXNlSW5zZW5zaXRpdmUiLCJfd3JpdGFibGVTdGF0ZSIsImVuZGVkIiwiZW5hYmxlT2ZmbGluZVF1ZXVlIiwib2ZmbGluZVF1ZXVlIiwiQnVmZmVyIiwiZnJvbSIsImVuYWJsZWQiLCJfZ2V0RGVzY3JpcHRpb24iLCJwdXNoIiwib2ZmbGluZVRpbWVvdXQiLCJnZXRDb25maWd1cmVkQmxvY2tpbmdUaW1lb3V0IiwidW5kZWZpbmVkIiwic2V0QmxvY2tpbmdUaW1lb3V0IiwiaXNQaXBlbGluZSIsIndyaXRlIiwidG9Xcml0YWJsZSIsImRlc3RpbmF0aW9uIiwicmVkaXMiLCJjb21tYW5kUXVldWUiLCJzb2NrZXRUaW1lb3V0Iiwic29ja2V0VGltZW91dFRpbWVyIiwic2V0U29ja2V0VGltZW91dCIsImlzSW50IiwicGFyc2VJbnQiLCJlbWl0IiwiY29uZmlndXJlZFRpbWVvdXQiLCJ0aW1lb3V0IiwiZXh0cmFjdEJsb2NraW5nVGltZW91dCIsImJsb2NraW5nVGltZW91dEdyYWNlIiwiREVGQVVMVF9SRURJU19PUFRJT05TIiwic2NhblN0cmVhbSIsImNyZWF0ZVNjYW5TdHJlYW0iLCJzY2FuQnVmZmVyU3RyZWFtIiwic3NjYW5TdHJlYW0iLCJrZXkiLCJzc2NhbkJ1ZmZlclN0cmVhbSIsImhzY2FuU3RyZWFtIiwiaHNjYW5CdWZmZXJTdHJlYW0iLCJ6c2NhblN0cmVhbSIsInpzY2FuQnVmZmVyU3RyZWFtIiwiZXZlbnROYW1lIiwiYXJnIiwiZXJyb3IiLCJtZXNzYWdlIiwibGlzdGVuZXJzIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJjb25zb2xlIiwic3RhY2siLCJyZWNvdmVyRnJvbUZhdGFsRXJyb3IiLCJfY29tbWFuZEVycm9yIiwiaGFuZGxlUmVjb25uZWN0aW9uIiwiaXRlbSIsIm5lZWRSZWNvbm5lY3QiLCJyZWNvbm5lY3RPbkVycm9yIiwiZGVzY3JpcHRpb24iLCJwYXRoIiwicmVtb3RlQWRkcmVzcyIsInJlbW90ZVBvcnQiLCJob3N0IiwicG9ydCIsImNvbm5lY3Rpb25OYW1lIiwiaXNUbHMiLCJpIiwiZGVmYXVsdHMiLCJwYXJzZVVSTCIsInN0YXJ0c1dpdGgiLCJkZWZhdWx0T3B0aW9ucyIsInJlc29sdmVUTFNQcm9maWxlIiwiYmluZCIsIm9iamVjdE1vZGUiLCJzaGlmdCIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9yZWFkeUNoZWNrIiwiaW5mbyIsInJlcyIsImluY2x1ZGVzIiwid2FybiIsImxpbmVzIiwic3BsaXQiLCJmaWVsZE5hbWUiLCJmaWVsZFZhbHVlUGFydHMiLCJmaWVsZFZhbHVlIiwiam9pbiIsImxvYWRpbmciLCJsb2FkaW5nRXRhTXMiLCJsb2FkaW5nX2V0YV9zZWNvbmRzIiwicmV0cnlUaW1lIiwibWF4TG9hZGluZ1JldHJ5VGltZSIsIkNsdXN0ZXIiLCJDb21tYW5kIiwiYWRkVHJhbnNhY3Rpb25TdXBwb3J0IiwicHJvdG90eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/Redis.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/ScanStream.js":
/*!**************************************************!*\
  !*** ./node_modules/ioredis/built/ScanStream.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * Convenient class to convert the process of scanning keys to a readable stream.\n */ class ScanStream extends stream_1.Readable {\n    constructor(opt){\n        super(opt);\n        this.opt = opt;\n        this._redisCursor = \"0\";\n        this._redisDrained = false;\n    }\n    _read() {\n        if (this._redisDrained) {\n            this.push(null);\n            return;\n        }\n        const args = [\n            this._redisCursor\n        ];\n        if (this.opt.key) {\n            args.unshift(this.opt.key);\n        }\n        if (this.opt.match) {\n            args.push(\"MATCH\", this.opt.match);\n        }\n        if (this.opt.type) {\n            args.push(\"TYPE\", this.opt.type);\n        }\n        if (this.opt.count) {\n            args.push(\"COUNT\", String(this.opt.count));\n        }\n        if (this.opt.noValues) {\n            args.push(\"NOVALUES\");\n        }\n        this.opt.redis[this.opt.command](args, (err, res)=>{\n            if (err) {\n                this.emit(\"error\", err);\n                return;\n            }\n            this._redisCursor = res[0] instanceof Buffer ? res[0].toString() : res[0];\n            if (this._redisCursor === \"0\") {\n                this._redisDrained = true;\n            }\n            this.push(res[1]);\n        });\n    }\n    close() {\n        this._redisDrained = true;\n    }\n}\nexports[\"default\"] = ScanStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9TY2FuU3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDOztDQUVDLEdBQ0QsTUFBTUMsbUJBQW1CRixTQUFTRyxRQUFRO0lBQ3RDQyxZQUFZQyxHQUFHLENBQUU7UUFDYixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQSxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDekI7SUFDQUMsUUFBUTtRQUNKLElBQUksSUFBSSxDQUFDRCxhQUFhLEVBQUU7WUFDcEIsSUFBSSxDQUFDRSxJQUFJLENBQUM7WUFDVjtRQUNKO1FBQ0EsTUFBTUMsT0FBTztZQUFDLElBQUksQ0FBQ0osWUFBWTtTQUFDO1FBQ2hDLElBQUksSUFBSSxDQUFDRCxHQUFHLENBQUNNLEdBQUcsRUFBRTtZQUNkRCxLQUFLRSxPQUFPLENBQUMsSUFBSSxDQUFDUCxHQUFHLENBQUNNLEdBQUc7UUFDN0I7UUFDQSxJQUFJLElBQUksQ0FBQ04sR0FBRyxDQUFDUSxLQUFLLEVBQUU7WUFDaEJILEtBQUtELElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQ0osR0FBRyxDQUFDUSxLQUFLO1FBQ3JDO1FBQ0EsSUFBSSxJQUFJLENBQUNSLEdBQUcsQ0FBQ1MsSUFBSSxFQUFFO1lBQ2ZKLEtBQUtELElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQ0osR0FBRyxDQUFDUyxJQUFJO1FBQ25DO1FBQ0EsSUFBSSxJQUFJLENBQUNULEdBQUcsQ0FBQ1UsS0FBSyxFQUFFO1lBQ2hCTCxLQUFLRCxJQUFJLENBQUMsU0FBU08sT0FBTyxJQUFJLENBQUNYLEdBQUcsQ0FBQ1UsS0FBSztRQUM1QztRQUNBLElBQUksSUFBSSxDQUFDVixHQUFHLENBQUNZLFFBQVEsRUFBRTtZQUNuQlAsS0FBS0QsSUFBSSxDQUFDO1FBQ2Q7UUFDQSxJQUFJLENBQUNKLEdBQUcsQ0FBQ2EsS0FBSyxDQUFDLElBQUksQ0FBQ2IsR0FBRyxDQUFDYyxPQUFPLENBQUMsQ0FBQ1QsTUFBTSxDQUFDVSxLQUFLQztZQUN6QyxJQUFJRCxLQUFLO2dCQUNMLElBQUksQ0FBQ0UsSUFBSSxDQUFDLFNBQVNGO2dCQUNuQjtZQUNKO1lBQ0EsSUFBSSxDQUFDZCxZQUFZLEdBQUdlLEdBQUcsQ0FBQyxFQUFFLFlBQVlFLFNBQVNGLEdBQUcsQ0FBQyxFQUFFLENBQUNHLFFBQVEsS0FBS0gsR0FBRyxDQUFDLEVBQUU7WUFDekUsSUFBSSxJQUFJLENBQUNmLFlBQVksS0FBSyxLQUFLO2dCQUMzQixJQUFJLENBQUNDLGFBQWEsR0FBRztZQUN6QjtZQUNBLElBQUksQ0FBQ0UsSUFBSSxDQUFDWSxHQUFHLENBQUMsRUFBRTtRQUNwQjtJQUNKO0lBQ0FJLFFBQVE7UUFDSixJQUFJLENBQUNsQixhQUFhLEdBQUc7SUFDekI7QUFDSjtBQUNBVCxrQkFBZSxHQUFHSSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvU2NhblN0cmVhbS5qcz8zMzhmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuLyoqXG4gKiBDb252ZW5pZW50IGNsYXNzIHRvIGNvbnZlcnQgdGhlIHByb2Nlc3Mgb2Ygc2Nhbm5pbmcga2V5cyB0byBhIHJlYWRhYmxlIHN0cmVhbS5cbiAqL1xuY2xhc3MgU2NhblN0cmVhbSBleHRlbmRzIHN0cmVhbV8xLlJlYWRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHQpIHtcbiAgICAgICAgc3VwZXIob3B0KTtcbiAgICAgICAgdGhpcy5vcHQgPSBvcHQ7XG4gICAgICAgIHRoaXMuX3JlZGlzQ3Vyc29yID0gXCIwXCI7XG4gICAgICAgIHRoaXMuX3JlZGlzRHJhaW5lZCA9IGZhbHNlO1xuICAgIH1cbiAgICBfcmVhZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlZGlzRHJhaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbdGhpcy5fcmVkaXNDdXJzb3JdO1xuICAgICAgICBpZiAodGhpcy5vcHQua2V5KSB7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQodGhpcy5vcHQua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHQubWF0Y2gpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIk1BVENIXCIsIHRoaXMub3B0Lm1hdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHQudHlwZSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKFwiVFlQRVwiLCB0aGlzLm9wdC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHQuY291bnQpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIkNPVU5UXCIsIFN0cmluZyh0aGlzLm9wdC5jb3VudCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdC5ub1ZhbHVlcykge1xuICAgICAgICAgICAgYXJncy5wdXNoKFwiTk9WQUxVRVNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHQucmVkaXNbdGhpcy5vcHQuY29tbWFuZF0oYXJncywgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZWRpc0N1cnNvciA9IHJlc1swXSBpbnN0YW5jZW9mIEJ1ZmZlciA/IHJlc1swXS50b1N0cmluZygpIDogcmVzWzBdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlZGlzQ3Vyc29yID09PSBcIjBcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZGlzRHJhaW5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnB1c2gocmVzWzFdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLl9yZWRpc0RyYWluZWQgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNjYW5TdHJlYW07XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzdHJlYW1fMSIsInJlcXVpcmUiLCJTY2FuU3RyZWFtIiwiUmVhZGFibGUiLCJjb25zdHJ1Y3RvciIsIm9wdCIsIl9yZWRpc0N1cnNvciIsIl9yZWRpc0RyYWluZWQiLCJfcmVhZCIsInB1c2giLCJhcmdzIiwia2V5IiwidW5zaGlmdCIsIm1hdGNoIiwidHlwZSIsImNvdW50IiwiU3RyaW5nIiwibm9WYWx1ZXMiLCJyZWRpcyIsImNvbW1hbmQiLCJlcnIiLCJyZXMiLCJlbWl0IiwiQnVmZmVyIiwidG9TdHJpbmciLCJjbG9zZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/ScanStream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/Script.js":
/*!**********************************************!*\
  !*** ./node_modules/ioredis/built/Script.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nclass Script {\n    constructor(lua, numberOfKeys = null, keyPrefix = \"\", readOnly = false){\n        this.lua = lua;\n        this.numberOfKeys = numberOfKeys;\n        this.keyPrefix = keyPrefix;\n        this.readOnly = readOnly;\n        this.sha = (0, crypto_1.createHash)(\"sha1\").update(lua).digest(\"hex\");\n        const sha = this.sha;\n        const socketHasScriptLoaded = new WeakSet();\n        this.Command = class CustomScriptCommand extends Command_1.default {\n            toWritable(socket) {\n                const origReject = this.reject;\n                this.reject = (err)=>{\n                    if (err.message.indexOf(\"NOSCRIPT\") !== -1) {\n                        socketHasScriptLoaded.delete(socket);\n                    }\n                    origReject.call(this, err);\n                };\n                if (!socketHasScriptLoaded.has(socket)) {\n                    socketHasScriptLoaded.add(socket);\n                    this.name = \"eval\";\n                    this.args[0] = lua;\n                } else if (this.name === \"eval\") {\n                    this.name = \"evalsha\";\n                    this.args[0] = sha;\n                }\n                return super.toWritable(socket);\n            }\n        };\n    }\n    execute(container, args, options, callback) {\n        if (typeof this.numberOfKeys === \"number\") {\n            args.unshift(this.numberOfKeys);\n        }\n        if (this.keyPrefix) {\n            options.keyPrefix = this.keyPrefix;\n        }\n        if (this.readOnly) {\n            options.readOnly = true;\n        }\n        const evalsha = new this.Command(\"evalsha\", [\n            this.sha,\n            ...args\n        ], options);\n        evalsha.promise = evalsha.promise.catch((err)=>{\n            if (err.message.indexOf(\"NOSCRIPT\") === -1) {\n                throw err;\n            }\n            // Resend the same custom evalsha command that gets transformed\n            // to an eval in case it's not loaded yet on the connection.\n            const resend = new this.Command(\"evalsha\", [\n                this.sha,\n                ...args\n            ], options);\n            const client = container.isPipeline ? container.redis : container;\n            return client.sendCommand(resend);\n        });\n        (0, standard_as_callback_1.default)(evalsha.promise, callback);\n        return container.sendCommand(evalsha);\n    }\n}\nexports[\"default\"] = Script;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9TY3JpcHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUMsZ0VBQVc7QUFDckMsTUFBTUUseUJBQXlCRixtQkFBT0EsQ0FBQyxzRkFBc0I7QUFDN0QsTUFBTUc7SUFDRkMsWUFBWUMsR0FBRyxFQUFFQyxlQUFlLElBQUksRUFBRUMsWUFBWSxFQUFFLEVBQUVDLFdBQVcsS0FBSyxDQUFFO1FBQ3BFLElBQUksQ0FBQ0gsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsR0FBRyxHQUFHLENBQUMsR0FBR1YsU0FBU1csVUFBVSxFQUFFLFFBQVFDLE1BQU0sQ0FBQ04sS0FBS08sTUFBTSxDQUFDO1FBQy9ELE1BQU1ILE1BQU0sSUFBSSxDQUFDQSxHQUFHO1FBQ3BCLE1BQU1JLHdCQUF3QixJQUFJQztRQUNsQyxJQUFJLENBQUNDLE9BQU8sR0FBRyxNQUFNQyw0QkFBNEJmLFVBQVVnQixPQUFPO1lBQzlEQyxXQUFXQyxNQUFNLEVBQUU7Z0JBQ2YsTUFBTUMsYUFBYSxJQUFJLENBQUNDLE1BQU07Z0JBQzlCLElBQUksQ0FBQ0EsTUFBTSxHQUFHLENBQUNDO29CQUNYLElBQUlBLElBQUlDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLGdCQUFnQixDQUFDLEdBQUc7d0JBQ3hDWCxzQkFBc0JZLE1BQU0sQ0FBQ047b0JBQ2pDO29CQUNBQyxXQUFXTSxJQUFJLENBQUMsSUFBSSxFQUFFSjtnQkFDMUI7Z0JBQ0EsSUFBSSxDQUFDVCxzQkFBc0JjLEdBQUcsQ0FBQ1IsU0FBUztvQkFDcENOLHNCQUFzQmUsR0FBRyxDQUFDVDtvQkFDMUIsSUFBSSxDQUFDVSxJQUFJLEdBQUc7b0JBQ1osSUFBSSxDQUFDQyxJQUFJLENBQUMsRUFBRSxHQUFHekI7Z0JBQ25CLE9BQ0ssSUFBSSxJQUFJLENBQUN3QixJQUFJLEtBQUssUUFBUTtvQkFDM0IsSUFBSSxDQUFDQSxJQUFJLEdBQUc7b0JBQ1osSUFBSSxDQUFDQyxJQUFJLENBQUMsRUFBRSxHQUFHckI7Z0JBQ25CO2dCQUNBLE9BQU8sS0FBSyxDQUFDUyxXQUFXQztZQUM1QjtRQUNKO0lBQ0o7SUFDQVksUUFBUUMsU0FBUyxFQUFFRixJQUFJLEVBQUVHLE9BQU8sRUFBRUMsUUFBUSxFQUFFO1FBQ3hDLElBQUksT0FBTyxJQUFJLENBQUM1QixZQUFZLEtBQUssVUFBVTtZQUN2Q3dCLEtBQUtLLE9BQU8sQ0FBQyxJQUFJLENBQUM3QixZQUFZO1FBQ2xDO1FBQ0EsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRTtZQUNoQjBCLFFBQVExQixTQUFTLEdBQUcsSUFBSSxDQUFDQSxTQUFTO1FBQ3RDO1FBQ0EsSUFBSSxJQUFJLENBQUNDLFFBQVEsRUFBRTtZQUNmeUIsUUFBUXpCLFFBQVEsR0FBRztRQUN2QjtRQUNBLE1BQU00QixVQUFVLElBQUksSUFBSSxDQUFDckIsT0FBTyxDQUFDLFdBQVc7WUFBQyxJQUFJLENBQUNOLEdBQUc7ZUFBS3FCO1NBQUssRUFBRUc7UUFDakVHLFFBQVFDLE9BQU8sR0FBR0QsUUFBUUMsT0FBTyxDQUFDQyxLQUFLLENBQUMsQ0FBQ2hCO1lBQ3JDLElBQUlBLElBQUlDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLGdCQUFnQixDQUFDLEdBQUc7Z0JBQ3hDLE1BQU1GO1lBQ1Y7WUFDQSwrREFBK0Q7WUFDL0QsNERBQTREO1lBQzVELE1BQU1pQixTQUFTLElBQUksSUFBSSxDQUFDeEIsT0FBTyxDQUFDLFdBQVc7Z0JBQUMsSUFBSSxDQUFDTixHQUFHO21CQUFLcUI7YUFBSyxFQUFFRztZQUNoRSxNQUFNTyxTQUFTUixVQUFVUyxVQUFVLEdBQUdULFVBQVVVLEtBQUssR0FBR1Y7WUFDeEQsT0FBT1EsT0FBT0csV0FBVyxDQUFDSjtRQUM5QjtRQUNDLElBQUdyQyx1QkFBdUJlLE9BQU8sRUFBRW1CLFFBQVFDLE9BQU8sRUFBRUg7UUFDckQsT0FBT0YsVUFBVVcsV0FBVyxDQUFDUDtJQUNqQztBQUNKO0FBQ0F2QyxrQkFBZSxHQUFHTSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvU2NyaXB0LmpzP2Y5ODAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5jb25zdCBDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db21tYW5kXCIpO1xuY29uc3Qgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMSA9IHJlcXVpcmUoXCJzdGFuZGFyZC1hcy1jYWxsYmFja1wiKTtcbmNsYXNzIFNjcmlwdCB7XG4gICAgY29uc3RydWN0b3IobHVhLCBudW1iZXJPZktleXMgPSBudWxsLCBrZXlQcmVmaXggPSBcIlwiLCByZWFkT25seSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMubHVhID0gbHVhO1xuICAgICAgICB0aGlzLm51bWJlck9mS2V5cyA9IG51bWJlck9mS2V5cztcbiAgICAgICAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgICAgIHRoaXMucmVhZE9ubHkgPSByZWFkT25seTtcbiAgICAgICAgdGhpcy5zaGEgPSAoMCwgY3J5cHRvXzEuY3JlYXRlSGFzaCkoXCJzaGExXCIpLnVwZGF0ZShsdWEpLmRpZ2VzdChcImhleFwiKTtcbiAgICAgICAgY29uc3Qgc2hhID0gdGhpcy5zaGE7XG4gICAgICAgIGNvbnN0IHNvY2tldEhhc1NjcmlwdExvYWRlZCA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICAgIHRoaXMuQ29tbWFuZCA9IGNsYXNzIEN1c3RvbVNjcmlwdENvbW1hbmQgZXh0ZW5kcyBDb21tYW5kXzEuZGVmYXVsdCB7XG4gICAgICAgICAgICB0b1dyaXRhYmxlKHNvY2tldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdSZWplY3QgPSB0aGlzLnJlamVjdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoXCJOT1NDUklQVFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldEhhc1NjcmlwdExvYWRlZC5kZWxldGUoc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcmlnUmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICghc29ja2V0SGFzU2NyaXB0TG9hZGVkLmhhcyhzb2NrZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldEhhc1NjcmlwdExvYWRlZC5hZGQoc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gXCJldmFsXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnc1swXSA9IGx1YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uYW1lID09PSBcImV2YWxcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBcImV2YWxzaGFcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdzWzBdID0gc2hhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIudG9Xcml0YWJsZShzb2NrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBleGVjdXRlKGNvbnRhaW5lciwgYXJncywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm51bWJlck9mS2V5cyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMubnVtYmVyT2ZLZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5rZXlQcmVmaXgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMua2V5UHJlZml4ID0gdGhpcy5rZXlQcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2YWxzaGEgPSBuZXcgdGhpcy5Db21tYW5kKFwiZXZhbHNoYVwiLCBbdGhpcy5zaGEsIC4uLmFyZ3NdLCBvcHRpb25zKTtcbiAgICAgICAgZXZhbHNoYS5wcm9taXNlID0gZXZhbHNoYS5wcm9taXNlLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKFwiTk9TQ1JJUFRcIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzZW5kIHRoZSBzYW1lIGN1c3RvbSBldmFsc2hhIGNvbW1hbmQgdGhhdCBnZXRzIHRyYW5zZm9ybWVkXG4gICAgICAgICAgICAvLyB0byBhbiBldmFsIGluIGNhc2UgaXQncyBub3QgbG9hZGVkIHlldCBvbiB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IHJlc2VuZCA9IG5ldyB0aGlzLkNvbW1hbmQoXCJldmFsc2hhXCIsIFt0aGlzLnNoYSwgLi4uYXJnc10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gY29udGFpbmVyLmlzUGlwZWxpbmUgPyBjb250YWluZXIucmVkaXMgOiBjb250YWluZXI7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnNlbmRDb21tYW5kKHJlc2VuZCk7XG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShldmFsc2hhLnByb21pc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5zZW5kQ29tbWFuZChldmFsc2hhKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTY3JpcHQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcnlwdG9fMSIsInJlcXVpcmUiLCJDb21tYW5kXzEiLCJzdGFuZGFyZF9hc19jYWxsYmFja18xIiwiU2NyaXB0IiwiY29uc3RydWN0b3IiLCJsdWEiLCJudW1iZXJPZktleXMiLCJrZXlQcmVmaXgiLCJyZWFkT25seSIsInNoYSIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJkaWdlc3QiLCJzb2NrZXRIYXNTY3JpcHRMb2FkZWQiLCJXZWFrU2V0IiwiQ29tbWFuZCIsIkN1c3RvbVNjcmlwdENvbW1hbmQiLCJkZWZhdWx0IiwidG9Xcml0YWJsZSIsInNvY2tldCIsIm9yaWdSZWplY3QiLCJyZWplY3QiLCJlcnIiLCJtZXNzYWdlIiwiaW5kZXhPZiIsImRlbGV0ZSIsImNhbGwiLCJoYXMiLCJhZGQiLCJuYW1lIiwiYXJncyIsImV4ZWN1dGUiLCJjb250YWluZXIiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJ1bnNoaWZ0IiwiZXZhbHNoYSIsInByb21pc2UiLCJjYXRjaCIsInJlc2VuZCIsImNsaWVudCIsImlzUGlwZWxpbmUiLCJyZWRpcyIsInNlbmRDb21tYW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/Script.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/SubscriptionSet.js":
/*!*******************************************************!*\
  !*** ./node_modules/ioredis/built/SubscriptionSet.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * Tiny class to simplify dealing with subscription set\n */ class SubscriptionSet {\n    constructor(){\n        this.set = {\n            subscribe: {},\n            psubscribe: {},\n            ssubscribe: {}\n        };\n    }\n    add(set, channel) {\n        this.set[mapSet(set)][channel] = true;\n    }\n    del(set, channel) {\n        delete this.set[mapSet(set)][channel];\n    }\n    channels(set) {\n        return Object.keys(this.set[mapSet(set)]);\n    }\n    isEmpty() {\n        return this.channels(\"subscribe\").length === 0 && this.channels(\"psubscribe\").length === 0 && this.channels(\"ssubscribe\").length === 0;\n    }\n}\nexports[\"default\"] = SubscriptionSet;\nfunction mapSet(set) {\n    if (set === \"unsubscribe\") {\n        return \"subscribe\";\n    }\n    if (set === \"punsubscribe\") {\n        return \"psubscribe\";\n    }\n    if (set === \"sunsubscribe\") {\n        return \"ssubscribe\";\n    }\n    return set;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9TdWJzY3JpcHRpb25TZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0Q7O0NBRUMsR0FDRCxNQUFNQztJQUNGQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxHQUFHLEdBQUc7WUFDUEMsV0FBVyxDQUFDO1lBQ1pDLFlBQVksQ0FBQztZQUNiQyxZQUFZLENBQUM7UUFDakI7SUFDSjtJQUNBQyxJQUFJSixHQUFHLEVBQUVLLE9BQU8sRUFBRTtRQUNkLElBQUksQ0FBQ0wsR0FBRyxDQUFDTSxPQUFPTixLQUFLLENBQUNLLFFBQVEsR0FBRztJQUNyQztJQUNBRSxJQUFJUCxHQUFHLEVBQUVLLE9BQU8sRUFBRTtRQUNkLE9BQU8sSUFBSSxDQUFDTCxHQUFHLENBQUNNLE9BQU9OLEtBQUssQ0FBQ0ssUUFBUTtJQUN6QztJQUNBRyxTQUFTUixHQUFHLEVBQUU7UUFDVixPQUFPTixPQUFPZSxJQUFJLENBQUMsSUFBSSxDQUFDVCxHQUFHLENBQUNNLE9BQU9OLEtBQUs7SUFDNUM7SUFDQVUsVUFBVTtRQUNOLE9BQVEsSUFBSSxDQUFDRixRQUFRLENBQUMsYUFBYUcsTUFBTSxLQUFLLEtBQzFDLElBQUksQ0FBQ0gsUUFBUSxDQUFDLGNBQWNHLE1BQU0sS0FBSyxLQUN2QyxJQUFJLENBQUNILFFBQVEsQ0FBQyxjQUFjRyxNQUFNLEtBQUs7SUFDL0M7QUFDSjtBQUNBZixrQkFBZSxHQUFHRTtBQUNsQixTQUFTUSxPQUFPTixHQUFHO0lBQ2YsSUFBSUEsUUFBUSxlQUFlO1FBQ3ZCLE9BQU87SUFDWDtJQUNBLElBQUlBLFFBQVEsZ0JBQWdCO1FBQ3hCLE9BQU87SUFDWDtJQUNBLElBQUlBLFFBQVEsZ0JBQWdCO1FBQ3hCLE9BQU87SUFDWDtJQUNBLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0LWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L1N1YnNjcmlwdGlvblNldC5qcz9mMWY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUaW55IGNsYXNzIHRvIHNpbXBsaWZ5IGRlYWxpbmcgd2l0aCBzdWJzY3JpcHRpb24gc2V0XG4gKi9cbmNsYXNzIFN1YnNjcmlwdGlvblNldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2V0ID0ge1xuICAgICAgICAgICAgc3Vic2NyaWJlOiB7fSxcbiAgICAgICAgICAgIHBzdWJzY3JpYmU6IHt9LFxuICAgICAgICAgICAgc3N1YnNjcmliZToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZChzZXQsIGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5zZXRbbWFwU2V0KHNldCldW2NoYW5uZWxdID0gdHJ1ZTtcbiAgICB9XG4gICAgZGVsKHNldCwgY2hhbm5lbCkge1xuICAgICAgICBkZWxldGUgdGhpcy5zZXRbbWFwU2V0KHNldCldW2NoYW5uZWxdO1xuICAgIH1cbiAgICBjaGFubmVscyhzZXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0W21hcFNldChzZXQpXSk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jaGFubmVscyhcInN1YnNjcmliZVwiKS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMoXCJwc3Vic2NyaWJlXCIpLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5jaGFubmVscyhcInNzdWJzY3JpYmVcIikubGVuZ3RoID09PSAwKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTdWJzY3JpcHRpb25TZXQ7XG5mdW5jdGlvbiBtYXBTZXQoc2V0KSB7XG4gICAgaWYgKHNldCA9PT0gXCJ1bnN1YnNjcmliZVwiKSB7XG4gICAgICAgIHJldHVybiBcInN1YnNjcmliZVwiO1xuICAgIH1cbiAgICBpZiAoc2V0ID09PSBcInB1bnN1YnNjcmliZVwiKSB7XG4gICAgICAgIHJldHVybiBcInBzdWJzY3JpYmVcIjtcbiAgICB9XG4gICAgaWYgKHNldCA9PT0gXCJzdW5zdWJzY3JpYmVcIikge1xuICAgICAgICByZXR1cm4gXCJzc3Vic2NyaWJlXCI7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTdWJzY3JpcHRpb25TZXQiLCJjb25zdHJ1Y3RvciIsInNldCIsInN1YnNjcmliZSIsInBzdWJzY3JpYmUiLCJzc3Vic2NyaWJlIiwiYWRkIiwiY2hhbm5lbCIsIm1hcFNldCIsImRlbCIsImNoYW5uZWxzIiwia2V5cyIsImlzRW1wdHkiLCJsZW5ndGgiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/SubscriptionSet.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/autoPipelining.js":
/*!******************************************************!*\
  !*** ./node_modules/ioredis/built/autoPipelining.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.executeWithAutoPipelining = exports.getFirstValueInFlattenedArray = exports.shouldUseAutoPipelining = exports.notAllowedAutoPipelineCommands = exports.kCallbacks = exports.kExec = void 0;\nconst lodash_1 = __webpack_require__(/*! ./utils/lodash */ \"(rsc)/./node_modules/ioredis/built/utils/lodash.js\");\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/./node_modules/cluster-key-slot/lib/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nexports.kExec = Symbol(\"exec\");\nexports.kCallbacks = Symbol(\"callbacks\");\nexports.notAllowedAutoPipelineCommands = [\n    \"auth\",\n    \"info\",\n    \"script\",\n    \"quit\",\n    \"cluster\",\n    \"pipeline\",\n    \"multi\",\n    \"subscribe\",\n    \"psubscribe\",\n    \"unsubscribe\",\n    \"unpsubscribe\",\n    \"select\",\n    \"client\"\n];\nfunction executeAutoPipeline(client, slotKey) {\n    /*\n      If a pipeline is already executing, keep queueing up commands\n      since ioredis won't serve two pipelines at the same time\n    */ if (client._runningAutoPipelines.has(slotKey)) {\n        return;\n    }\n    if (!client._autoPipelines.has(slotKey)) {\n        /*\n          Rare edge case. Somehow, something has deleted this running autopipeline in an immediate\n          call to executeAutoPipeline.\n         \n          Maybe the callback in the pipeline.exec is sometimes called in the same tick,\n          e.g. if redis is disconnected?\n        */ return;\n    }\n    client._runningAutoPipelines.add(slotKey);\n    // Get the pipeline and immediately delete it so that new commands are queued on a new pipeline\n    const pipeline = client._autoPipelines.get(slotKey);\n    client._autoPipelines.delete(slotKey);\n    const callbacks = pipeline[exports.kCallbacks];\n    // Stop keeping a reference to callbacks immediately after the callbacks stop being used.\n    // This allows the GC to reclaim objects referenced by callbacks, especially with 16384 slots\n    // in Redis.Cluster\n    pipeline[exports.kCallbacks] = null;\n    // Perform the call\n    pipeline.exec(function(err, results) {\n        client._runningAutoPipelines.delete(slotKey);\n        /*\n          Invoke all callback in nextTick so the stack is cleared\n          and callbacks can throw errors without affecting other callbacks.\n        */ if (err) {\n            for(let i = 0; i < callbacks.length; i++){\n                process.nextTick(callbacks[i], err);\n            }\n        } else {\n            for(let i = 0; i < callbacks.length; i++){\n                process.nextTick(callbacks[i], ...results[i]);\n            }\n        }\n        // If there is another pipeline on the same node, immediately execute it without waiting for nextTick\n        if (client._autoPipelines.has(slotKey)) {\n            executeAutoPipeline(client, slotKey);\n        }\n    });\n}\nfunction shouldUseAutoPipelining(client, functionName, commandName) {\n    return functionName && client.options.enableAutoPipelining && !client.isPipeline && !exports.notAllowedAutoPipelineCommands.includes(commandName) && !client.options.autoPipeliningIgnoredCommands.includes(commandName);\n}\nexports.shouldUseAutoPipelining = shouldUseAutoPipelining;\nfunction getFirstValueInFlattenedArray(args) {\n    for(let i = 0; i < args.length; i++){\n        const arg = args[i];\n        if (typeof arg === \"string\") {\n            return arg;\n        } else if (Array.isArray(arg) || (0, lodash_1.isArguments)(arg)) {\n            if (arg.length === 0) {\n                continue;\n            }\n            return arg[0];\n        }\n        const flattened = [\n            arg\n        ].flat();\n        if (flattened.length > 0) {\n            return flattened[0];\n        }\n    }\n    return undefined;\n}\nexports.getFirstValueInFlattenedArray = getFirstValueInFlattenedArray;\nfunction executeWithAutoPipelining(client, functionName, commandName, args, callback) {\n    // On cluster mode let's wait for slots to be available\n    if (client.isCluster && !client.slots.length) {\n        if (client.status === \"wait\") client.connect().catch(lodash_1.noop);\n        return (0, standard_as_callback_1.default)(new Promise(function(resolve, reject) {\n            client.delayUntilReady((err)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                executeWithAutoPipelining(client, functionName, commandName, args, null).then(resolve, reject);\n            });\n        }), callback);\n    }\n    // If we have slot information, we can improve routing by grouping slots served by the same subset of nodes\n    // Note that the first value in args may be a (possibly empty) array.\n    // ioredis will only flatten one level of the array, in the Command constructor.\n    const prefix = client.options.keyPrefix || \"\";\n    let slotKey = client.isCluster ? client.slots[calculateSlot(`${prefix}${getFirstValueInFlattenedArray(args)}`)].join(\",\") : \"main\";\n    // When scaleReads is enabled, separate read and write commands into different pipelines\n    // so they can be routed to replicas and masters respectively\n    if (client.isCluster && client.options.scaleReads !== \"master\") {\n        const isReadOnly = (0, commands_1.exists)(commandName) && (0, commands_1.hasFlag)(commandName, \"readonly\");\n        slotKey += isReadOnly ? \":read\" : \":write\";\n    }\n    if (!client._autoPipelines.has(slotKey)) {\n        const pipeline = client.pipeline();\n        pipeline[exports.kExec] = false;\n        pipeline[exports.kCallbacks] = [];\n        client._autoPipelines.set(slotKey, pipeline);\n    }\n    const pipeline = client._autoPipelines.get(slotKey);\n    /*\n      Mark the pipeline as scheduled.\n      The symbol will make sure that the pipeline is only scheduled once per tick.\n      New commands are appended to an already scheduled pipeline.\n    */ if (!pipeline[exports.kExec]) {\n        pipeline[exports.kExec] = true;\n        /*\n          Deferring with setImmediate so we have a chance to capture multiple\n          commands that can be scheduled by I/O events already in the event loop queue.\n        */ setImmediate(executeAutoPipeline, client, slotKey);\n    }\n    // Create the promise which will execute the command in the pipeline.\n    const autoPipelinePromise = new Promise(function(resolve, reject) {\n        pipeline[exports.kCallbacks].push(function(err, value) {\n            if (err) {\n                reject(err);\n                return;\n            }\n            resolve(value);\n        });\n        if (functionName === \"call\") {\n            args.unshift(commandName);\n        }\n        pipeline[functionName](...args);\n    });\n    return (0, standard_as_callback_1.default)(autoPipelinePromise, callback);\n}\nexports.executeWithAutoPipelining = executeWithAutoPipelining;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9hdXRvUGlwZWxpbmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUNBQWlDLEdBQUdBLHFDQUFxQyxHQUFHQSwrQkFBK0IsR0FBR0Esc0NBQXNDLEdBQUdBLGtCQUFrQixHQUFHQSxhQUFhLEdBQUcsS0FBSztBQUNqTSxNQUFNUSxXQUFXQyxtQkFBT0EsQ0FBQywwRUFBZ0I7QUFDekMsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyw0RUFBa0I7QUFDaEQsTUFBTUUseUJBQXlCRixtQkFBT0EsQ0FBQyxzRkFBc0I7QUFDN0QsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsZ0ZBQW1CO0FBQzlDVCxhQUFhLEdBQUdhLE9BQU87QUFDdkJiLGtCQUFrQixHQUFHYSxPQUFPO0FBQzVCYixzQ0FBc0MsR0FBRztJQUNyQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsU0FBU2Msb0JBQW9CQyxNQUFNLEVBQUVDLE9BQU87SUFDeEM7OztJQUdBLEdBQ0EsSUFBSUQsT0FBT0UscUJBQXFCLENBQUNDLEdBQUcsQ0FBQ0YsVUFBVTtRQUMzQztJQUNKO0lBQ0EsSUFBSSxDQUFDRCxPQUFPSSxjQUFjLENBQUNELEdBQUcsQ0FBQ0YsVUFBVTtRQUNyQzs7Ozs7O1FBTUEsR0FDQTtJQUNKO0lBQ0FELE9BQU9FLHFCQUFxQixDQUFDRyxHQUFHLENBQUNKO0lBQ2pDLCtGQUErRjtJQUMvRixNQUFNSyxXQUFXTixPQUFPSSxjQUFjLENBQUNHLEdBQUcsQ0FBQ047SUFDM0NELE9BQU9JLGNBQWMsQ0FBQ0ksTUFBTSxDQUFDUDtJQUM3QixNQUFNUSxZQUFZSCxRQUFRLENBQUNyQixRQUFRTSxVQUFVLENBQUM7SUFDOUMseUZBQXlGO0lBQ3pGLDZGQUE2RjtJQUM3RixtQkFB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LFFBQVF2RDtRQUNaO1FBQ0EsSUFBSStCLGlCQUFpQixRQUFRO1lBQ3pCTyxLQUFLZ0MsT0FBTyxDQUFDdEM7UUFDakI7UUFDQVosUUFBUSxDQUFDVyxhQUFhLElBQUlPO0lBQzlCO0lBQ0EsT0FBTyxDQUFDLEdBQUc1Qix1QkFBdUIyQyxPQUFPLEVBQUVlLHFCQUFxQnRCO0FBQ3BFO0FBQ0EvQyxpQ0FBaUMsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0LWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2F1dG9QaXBlbGluaW5nLmpzPzE4NDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4ZWN1dGVXaXRoQXV0b1BpcGVsaW5pbmcgPSBleHBvcnRzLmdldEZpcnN0VmFsdWVJbkZsYXR0ZW5lZEFycmF5ID0gZXhwb3J0cy5zaG91bGRVc2VBdXRvUGlwZWxpbmluZyA9IGV4cG9ydHMubm90QWxsb3dlZEF1dG9QaXBlbGluZUNvbW1hbmRzID0gZXhwb3J0cy5rQ2FsbGJhY2tzID0gZXhwb3J0cy5rRXhlYyA9IHZvaWQgMDtcbmNvbnN0IGxvZGFzaF8xID0gcmVxdWlyZShcIi4vdXRpbHMvbG9kYXNoXCIpO1xuY29uc3QgY2FsY3VsYXRlU2xvdCA9IHJlcXVpcmUoXCJjbHVzdGVyLWtleS1zbG90XCIpO1xuY29uc3Qgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMSA9IHJlcXVpcmUoXCJzdGFuZGFyZC1hcy1jYWxsYmFja1wiKTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiQGlvcmVkaXMvY29tbWFuZHNcIik7XG5leHBvcnRzLmtFeGVjID0gU3ltYm9sKFwiZXhlY1wiKTtcbmV4cG9ydHMua0NhbGxiYWNrcyA9IFN5bWJvbChcImNhbGxiYWNrc1wiKTtcbmV4cG9ydHMubm90QWxsb3dlZEF1dG9QaXBlbGluZUNvbW1hbmRzID0gW1xuICAgIFwiYXV0aFwiLFxuICAgIFwiaW5mb1wiLFxuICAgIFwic2NyaXB0XCIsXG4gICAgXCJxdWl0XCIsXG4gICAgXCJjbHVzdGVyXCIsXG4gICAgXCJwaXBlbGluZVwiLFxuICAgIFwibXVsdGlcIixcbiAgICBcInN1YnNjcmliZVwiLFxuICAgIFwicHN1YnNjcmliZVwiLFxuICAgIFwidW5zdWJzY3JpYmVcIixcbiAgICBcInVucHN1YnNjcmliZVwiLFxuICAgIFwic2VsZWN0XCIsXG4gICAgXCJjbGllbnRcIixcbl07XG5mdW5jdGlvbiBleGVjdXRlQXV0b1BpcGVsaW5lKGNsaWVudCwgc2xvdEtleSkge1xuICAgIC8qXG4gICAgICBJZiBhIHBpcGVsaW5lIGlzIGFscmVhZHkgZXhlY3V0aW5nLCBrZWVwIHF1ZXVlaW5nIHVwIGNvbW1hbmRzXG4gICAgICBzaW5jZSBpb3JlZGlzIHdvbid0IHNlcnZlIHR3byBwaXBlbGluZXMgYXQgdGhlIHNhbWUgdGltZVxuICAgICovXG4gICAgaWYgKGNsaWVudC5fcnVubmluZ0F1dG9QaXBlbGluZXMuaGFzKHNsb3RLZXkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjbGllbnQuX2F1dG9QaXBlbGluZXMuaGFzKHNsb3RLZXkpKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgUmFyZSBlZGdlIGNhc2UuIFNvbWVob3csIHNvbWV0aGluZyBoYXMgZGVsZXRlZCB0aGlzIHJ1bm5pbmcgYXV0b3BpcGVsaW5lIGluIGFuIGltbWVkaWF0ZVxuICAgICAgICAgIGNhbGwgdG8gZXhlY3V0ZUF1dG9QaXBlbGluZS5cbiAgICAgICAgIFxuICAgICAgICAgIE1heWJlIHRoZSBjYWxsYmFjayBpbiB0aGUgcGlwZWxpbmUuZXhlYyBpcyBzb21ldGltZXMgY2FsbGVkIGluIHRoZSBzYW1lIHRpY2ssXG4gICAgICAgICAgZS5nLiBpZiByZWRpcyBpcyBkaXNjb25uZWN0ZWQ/XG4gICAgICAgICovXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xpZW50Ll9ydW5uaW5nQXV0b1BpcGVsaW5lcy5hZGQoc2xvdEtleSk7XG4gICAgLy8gR2V0IHRoZSBwaXBlbGluZSBhbmQgaW1tZWRpYXRlbHkgZGVsZXRlIGl0IHNvIHRoYXQgbmV3IGNvbW1hbmRzIGFyZSBxdWV1ZWQgb24gYSBuZXcgcGlwZWxpbmVcbiAgICBjb25zdCBwaXBlbGluZSA9IGNsaWVudC5fYXV0b1BpcGVsaW5lcy5nZXQoc2xvdEtleSk7XG4gICAgY2xpZW50Ll9hdXRvUGlwZWxpbmVzLmRlbGV0ZShzbG90S2V5KTtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBwaXBlbGluZVtleHBvcnRzLmtDYWxsYmFja3NdO1xuICAgIC8vIFN0b3Aga2VlcGluZyBhIHJlZmVyZW5jZSB0byBjYWxsYmFja3MgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNhbGxiYWNrcyBzdG9wIGJlaW5nIHVzZWQuXG4gICAgLy8gVGhpcyBhbGxvd3MgdGhlIEdDIHRvIHJlY2xhaW0gb2JqZWN0cyByZWZlcmVuY2VkIGJ5IGNhbGxiYWNrcywgZXNwZWNpYWxseSB3aXRoIDE2Mzg0IHNsb3RzXG4gICAgLy8gaW4gUmVkaXMuQ2x1c3RlclxuICAgIHBpcGVsaW5lW2V4cG9ydHMua0NhbGxiYWNrc10gPSBudWxsO1xuICAgIC8vIFBlcmZvcm0gdGhlIGNhbGxcbiAgICBwaXBlbGluZS5leGVjKGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgY2xpZW50Ll9ydW5uaW5nQXV0b1BpcGVsaW5lcy5kZWxldGUoc2xvdEtleSk7XG4gICAgICAgIC8qXG4gICAgICAgICAgSW52b2tlIGFsbCBjYWxsYmFjayBpbiBuZXh0VGljayBzbyB0aGUgc3RhY2sgaXMgY2xlYXJlZFxuICAgICAgICAgIGFuZCBjYWxsYmFja3MgY2FuIHRocm93IGVycm9ycyB3aXRob3V0IGFmZmVjdGluZyBvdGhlciBjYWxsYmFja3MuXG4gICAgICAgICovXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja3NbaV0sIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tzW2ldLCAuLi5yZXN1bHRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbm90aGVyIHBpcGVsaW5lIG9uIHRoZSBzYW1lIG5vZGUsIGltbWVkaWF0ZWx5IGV4ZWN1dGUgaXQgd2l0aG91dCB3YWl0aW5nIGZvciBuZXh0VGlja1xuICAgICAgICBpZiAoY2xpZW50Ll9hdXRvUGlwZWxpbmVzLmhhcyhzbG90S2V5KSkge1xuICAgICAgICAgICAgZXhlY3V0ZUF1dG9QaXBlbGluZShjbGllbnQsIHNsb3RLZXkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzaG91bGRVc2VBdXRvUGlwZWxpbmluZyhjbGllbnQsIGZ1bmN0aW9uTmFtZSwgY29tbWFuZE5hbWUpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uTmFtZSAmJlxuICAgICAgICBjbGllbnQub3B0aW9ucy5lbmFibGVBdXRvUGlwZWxpbmluZyAmJlxuICAgICAgICAhY2xpZW50LmlzUGlwZWxpbmUgJiZcbiAgICAgICAgIWV4cG9ydHMubm90QWxsb3dlZEF1dG9QaXBlbGluZUNvbW1hbmRzLmluY2x1ZGVzKGNvbW1hbmROYW1lKSAmJlxuICAgICAgICAhY2xpZW50Lm9wdGlvbnMuYXV0b1BpcGVsaW5pbmdJZ25vcmVkQ29tbWFuZHMuaW5jbHVkZXMoY29tbWFuZE5hbWUpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlQXV0b1BpcGVsaW5pbmcgPSBzaG91bGRVc2VBdXRvUGlwZWxpbmluZztcbmZ1bmN0aW9uIGdldEZpcnN0VmFsdWVJbkZsYXR0ZW5lZEFycmF5KGFyZ3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpIHx8ICgwLCBsb2Rhc2hfMS5pc0FyZ3VtZW50cykoYXJnKSkge1xuICAgICAgICAgICAgaWYgKGFyZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhdHRlbmVkID0gW2FyZ10uZmxhdCgpO1xuICAgICAgICBpZiAoZmxhdHRlbmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuZWRbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZ2V0Rmlyc3RWYWx1ZUluRmxhdHRlbmVkQXJyYXkgPSBnZXRGaXJzdFZhbHVlSW5GbGF0dGVuZWRBcnJheTtcbmZ1bmN0aW9uIGV4ZWN1dGVXaXRoQXV0b1BpcGVsaW5pbmcoY2xpZW50LCBmdW5jdGlvbk5hbWUsIGNvbW1hbmROYW1lLCBhcmdzLCBjYWxsYmFjaykge1xuICAgIC8vIE9uIGNsdXN0ZXIgbW9kZSBsZXQncyB3YWl0IGZvciBzbG90cyB0byBiZSBhdmFpbGFibGVcbiAgICBpZiAoY2xpZW50LmlzQ2x1c3RlciAmJiAhY2xpZW50LnNsb3RzLmxlbmd0aCkge1xuICAgICAgICBpZiAoY2xpZW50LnN0YXR1cyA9PT0gXCJ3YWl0XCIpXG4gICAgICAgICAgICBjbGllbnQuY29ubmVjdCgpLmNhdGNoKGxvZGFzaF8xLm5vb3ApO1xuICAgICAgICByZXR1cm4gKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgY2xpZW50LmRlbGF5VW50aWxSZWFkeSgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleGVjdXRlV2l0aEF1dG9QaXBlbGluaW5nKGNsaWVudCwgZnVuY3Rpb25OYW1lLCBjb21tYW5kTmFtZSwgYXJncywgbnVsbCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8vIElmIHdlIGhhdmUgc2xvdCBpbmZvcm1hdGlvbiwgd2UgY2FuIGltcHJvdmUgcm91dGluZyBieSBncm91cGluZyBzbG90cyBzZXJ2ZWQgYnkgdGhlIHNhbWUgc3Vic2V0IG9mIG5vZGVzXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBmaXJzdCB2YWx1ZSBpbiBhcmdzIG1heSBiZSBhIChwb3NzaWJseSBlbXB0eSkgYXJyYXkuXG4gICAgLy8gaW9yZWRpcyB3aWxsIG9ubHkgZmxhdHRlbiBvbmUgbGV2ZWwgb2YgdGhlIGFycmF5LCBpbiB0aGUgQ29tbWFuZCBjb25zdHJ1Y3Rvci5cbiAgICBjb25zdCBwcmVmaXggPSBjbGllbnQub3B0aW9ucy5rZXlQcmVmaXggfHwgXCJcIjtcbiAgICBsZXQgc2xvdEtleSA9IGNsaWVudC5pc0NsdXN0ZXJcbiAgICAgICAgPyBjbGllbnQuc2xvdHNbY2FsY3VsYXRlU2xvdChgJHtwcmVmaXh9JHtnZXRGaXJzdFZhbHVlSW5GbGF0dGVuZWRBcnJheShhcmdzKX1gKV0uam9pbihcIixcIilcbiAgICAgICAgOiBcIm1haW5cIjtcbiAgICAvLyBXaGVuIHNjYWxlUmVhZHMgaXMgZW5hYmxlZCwgc2VwYXJhdGUgcmVhZCBhbmQgd3JpdGUgY29tbWFuZHMgaW50byBkaWZmZXJlbnQgcGlwZWxpbmVzXG4gICAgLy8gc28gdGhleSBjYW4gYmUgcm91dGVkIHRvIHJlcGxpY2FzIGFuZCBtYXN0ZXJzIHJlc3BlY3RpdmVseVxuICAgIGlmIChjbGllbnQuaXNDbHVzdGVyICYmIGNsaWVudC5vcHRpb25zLnNjYWxlUmVhZHMgIT09IFwibWFzdGVyXCIpIHtcbiAgICAgICAgY29uc3QgaXNSZWFkT25seSA9ICgwLCBjb21tYW5kc18xLmV4aXN0cykoY29tbWFuZE5hbWUpICYmICgwLCBjb21tYW5kc18xLmhhc0ZsYWcpKGNvbW1hbmROYW1lLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICBzbG90S2V5ICs9IGlzUmVhZE9ubHkgPyBcIjpyZWFkXCIgOiBcIjp3cml0ZVwiO1xuICAgIH1cbiAgICBpZiAoIWNsaWVudC5fYXV0b1BpcGVsaW5lcy5oYXMoc2xvdEtleSkpIHtcbiAgICAgICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQucGlwZWxpbmUoKTtcbiAgICAgICAgcGlwZWxpbmVbZXhwb3J0cy5rRXhlY10gPSBmYWxzZTtcbiAgICAgICAgcGlwZWxpbmVbZXhwb3J0cy5rQ2FsbGJhY2tzXSA9IFtdO1xuICAgICAgICBjbGllbnQuX2F1dG9QaXBlbGluZXMuc2V0KHNsb3RLZXksIHBpcGVsaW5lKTtcbiAgICB9XG4gICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQuX2F1dG9QaXBlbGluZXMuZ2V0KHNsb3RLZXkpO1xuICAgIC8qXG4gICAgICBNYXJrIHRoZSBwaXBlbGluZSBhcyBzY2hlZHVsZWQuXG4gICAgICBUaGUgc3ltYm9sIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIHBpcGVsaW5lIGlzIG9ubHkgc2NoZWR1bGVkIG9uY2UgcGVyIHRpY2suXG4gICAgICBOZXcgY29tbWFuZHMgYXJlIGFwcGVuZGVkIHRvIGFuIGFscmVhZHkgc2NoZWR1bGVkIHBpcGVsaW5lLlxuICAgICovXG4gICAgaWYgKCFwaXBlbGluZVtleHBvcnRzLmtFeGVjXSkge1xuICAgICAgICBwaXBlbGluZVtleHBvcnRzLmtFeGVjXSA9IHRydWU7XG4gICAgICAgIC8qXG4gICAgICAgICAgRGVmZXJyaW5nIHdpdGggc2V0SW1tZWRpYXRlIHNvIHdlIGhhdmUgYSBjaGFuY2UgdG8gY2FwdHVyZSBtdWx0aXBsZVxuICAgICAgICAgIGNvbW1hbmRzIHRoYXQgY2FuIGJlIHNjaGVkdWxlZCBieSBJL08gZXZlbnRzIGFscmVhZHkgaW4gdGhlIGV2ZW50IGxvb3AgcXVldWUuXG4gICAgICAgICovXG4gICAgICAgIHNldEltbWVkaWF0ZShleGVjdXRlQXV0b1BpcGVsaW5lLCBjbGllbnQsIHNsb3RLZXkpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgdGhlIHByb21pc2Ugd2hpY2ggd2lsbCBleGVjdXRlIHRoZSBjb21tYW5kIGluIHRoZSBwaXBlbGluZS5cbiAgICBjb25zdCBhdXRvUGlwZWxpbmVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwaXBlbGluZVtleHBvcnRzLmtDYWxsYmFja3NdLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmdW5jdGlvbk5hbWUgPT09IFwiY2FsbFwiKSB7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoY29tbWFuZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHBpcGVsaW5lW2Z1bmN0aW9uTmFtZV0oLi4uYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKGF1dG9QaXBlbGluZVByb21pc2UsIGNhbGxiYWNrKTtcbn1cbmV4cG9ydHMuZXhlY3V0ZVdpdGhBdXRvUGlwZWxpbmluZyA9IGV4ZWN1dGVXaXRoQXV0b1BpcGVsaW5pbmc7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJleGVjdXRlV2l0aEF1dG9QaXBlbGluaW5nIiwiZ2V0Rmlyc3RWYWx1ZUluRmxhdHRlbmVkQXJyYXkiLCJzaG91bGRVc2VBdXRvUGlwZWxpbmluZyIsIm5vdEFsbG93ZWRBdXRvUGlwZWxpbmVDb21tYW5kcyIsImtDYWxsYmFja3MiLCJrRXhlYyIsImxvZGFzaF8xIiwicmVxdWlyZSIsImNhbGN1bGF0ZVNsb3QiLCJzdGFuZGFyZF9hc19jYWxsYmFja18xIiwiY29tbWFuZHNfMSIsIlN5bWJvbCIsImV4ZWN1dGVBdXRvUGlwZWxpbmUiLCJjbGllbnQiLCJzbG90S2V5IiwiX3J1bm5pbmdBdXRvUGlwZWxpbmVzIiwiaGFzIiwiX2F1dG9QaXBlbGluZXMiLCJhZGQiLCJwaXBlbGluZSIsImdldCIsImRlbGV0ZSIsImNhbGxiYWNrcyIsImV4ZWMiLCJlcnIiLCJyZXN1bHRzIiwiaSIsImxlbmd0aCIsInByb2Nlc3MiLCJuZXh0VGljayIsImZ1bmN0aW9uTmFtZSIsImNvbW1hbmROYW1lIiwib3B0aW9ucyIsImVuYWJsZUF1dG9QaXBlbGluaW5nIiwiaXNQaXBlbGluZSIsImluY2x1ZGVzIiwiYXV0b1BpcGVsaW5pbmdJZ25vcmVkQ29tbWFuZHMiLCJhcmdzIiwiYXJnIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNBcmd1bWVudHMiLCJmbGF0dGVuZWQiLCJmbGF0IiwidW5kZWZpbmVkIiwiY2FsbGJhY2siLCJpc0NsdXN0ZXIiLCJzbG90cyIsInN0YXR1cyIsImNvbm5lY3QiLCJjYXRjaCIsIm5vb3AiLCJkZWZhdWx0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJkZWxheVVudGlsUmVhZHkiLCJ0aGVuIiwicHJlZml4Iiwia2V5UHJlZml4Iiwiam9pbiIsInNjYWxlUmVhZHMiLCJpc1JlYWRPbmx5IiwiZXhpc3RzIiwiaGFzRmxhZyIsInNldCIsInNldEltbWVkaWF0ZSIsImF1dG9QaXBlbGluZVByb21pc2UiLCJwdXNoIiwidW5zaGlmdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/autoPipelining.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/ClusterOptions.js":
/*!**************************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/ClusterOptions.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DEFAULT_CLUSTER_OPTIONS = void 0;\nconst dns_1 = __webpack_require__(/*! dns */ \"dns\");\nexports.DEFAULT_CLUSTER_OPTIONS = {\n    clusterRetryStrategy: (times)=>Math.min(100 + times * 2, 2000),\n    enableOfflineQueue: true,\n    enableReadyCheck: true,\n    scaleReads: \"master\",\n    maxRedirections: 16,\n    retryDelayOnMoved: 0,\n    retryDelayOnFailover: 100,\n    retryDelayOnClusterDown: 100,\n    retryDelayOnTryAgain: 100,\n    slotsRefreshTimeout: 1000,\n    useSRVRecords: false,\n    resolveSrv: dns_1.resolveSrv,\n    dnsLookup: dns_1.lookup,\n    enableAutoPipelining: false,\n    autoPipeliningIgnoredCommands: [],\n    shardedSubscribers: false\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0NsdXN0ZXJPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwrQkFBK0IsR0FBRyxLQUFLO0FBQ3ZDLE1BQU1HLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCSiwrQkFBK0IsR0FBRztJQUM5Qkssc0JBQXNCLENBQUNDLFFBQVVDLEtBQUtDLEdBQUcsQ0FBQyxNQUFNRixRQUFRLEdBQUc7SUFDM0RHLG9CQUFvQjtJQUNwQkMsa0JBQWtCO0lBQ2xCQyxZQUFZO0lBQ1pDLGlCQUFpQjtJQUNqQkMsbUJBQW1CO0lBQ25CQyxzQkFBc0I7SUFDdEJDLHlCQUF5QjtJQUN6QkMsc0JBQXNCO0lBQ3RCQyxxQkFBcUI7SUFDckJDLGVBQWU7SUFDZkMsWUFBWWhCLE1BQU1nQixVQUFVO0lBQzVCQyxXQUFXakIsTUFBTWtCLE1BQU07SUFDdkJDLHNCQUFzQjtJQUN0QkMsK0JBQStCLEVBQUU7SUFDakNDLG9CQUFvQjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci9DbHVzdGVyT3B0aW9ucy5qcz82NDg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX0NMVVNURVJfT1BUSU9OUyA9IHZvaWQgMDtcbmNvbnN0IGRuc18xID0gcmVxdWlyZShcImRuc1wiKTtcbmV4cG9ydHMuREVGQVVMVF9DTFVTVEVSX09QVElPTlMgPSB7XG4gICAgY2x1c3RlclJldHJ5U3RyYXRlZ3k6ICh0aW1lcykgPT4gTWF0aC5taW4oMTAwICsgdGltZXMgKiAyLCAyMDAwKSxcbiAgICBlbmFibGVPZmZsaW5lUXVldWU6IHRydWUsXG4gICAgZW5hYmxlUmVhZHlDaGVjazogdHJ1ZSxcbiAgICBzY2FsZVJlYWRzOiBcIm1hc3RlclwiLFxuICAgIG1heFJlZGlyZWN0aW9uczogMTYsXG4gICAgcmV0cnlEZWxheU9uTW92ZWQ6IDAsXG4gICAgcmV0cnlEZWxheU9uRmFpbG92ZXI6IDEwMCxcbiAgICByZXRyeURlbGF5T25DbHVzdGVyRG93bjogMTAwLFxuICAgIHJldHJ5RGVsYXlPblRyeUFnYWluOiAxMDAsXG4gICAgc2xvdHNSZWZyZXNoVGltZW91dDogMTAwMCxcbiAgICB1c2VTUlZSZWNvcmRzOiBmYWxzZSxcbiAgICByZXNvbHZlU3J2OiBkbnNfMS5yZXNvbHZlU3J2LFxuICAgIGRuc0xvb2t1cDogZG5zXzEubG9va3VwLFxuICAgIGVuYWJsZUF1dG9QaXBlbGluaW5nOiBmYWxzZSxcbiAgICBhdXRvUGlwZWxpbmluZ0lnbm9yZWRDb21tYW5kczogW10sXG4gICAgc2hhcmRlZFN1YnNjcmliZXJzOiBmYWxzZSxcbn07XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJERUZBVUxUX0NMVVNURVJfT1BUSU9OUyIsImRuc18xIiwicmVxdWlyZSIsImNsdXN0ZXJSZXRyeVN0cmF0ZWd5IiwidGltZXMiLCJNYXRoIiwibWluIiwiZW5hYmxlT2ZmbGluZVF1ZXVlIiwiZW5hYmxlUmVhZHlDaGVjayIsInNjYWxlUmVhZHMiLCJtYXhSZWRpcmVjdGlvbnMiLCJyZXRyeURlbGF5T25Nb3ZlZCIsInJldHJ5RGVsYXlPbkZhaWxvdmVyIiwicmV0cnlEZWxheU9uQ2x1c3RlckRvd24iLCJyZXRyeURlbGF5T25UcnlBZ2FpbiIsInNsb3RzUmVmcmVzaFRpbWVvdXQiLCJ1c2VTUlZSZWNvcmRzIiwicmVzb2x2ZVNydiIsImRuc0xvb2t1cCIsImxvb2t1cCIsImVuYWJsZUF1dG9QaXBlbGluaW5nIiwiYXV0b1BpcGVsaW5pbmdJZ25vcmVkQ29tbWFuZHMiLCJzaGFyZGVkU3Vic2NyaWJlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/ClusterOptions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriber.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/ClusterSubscriber.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/ioredis/built/cluster/util.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst debug = (0, utils_1.Debug)(\"cluster:subscriber\");\nclass ClusterSubscriber {\n    constructor(connectionPool, emitter, isSharded = false){\n        this.connectionPool = connectionPool;\n        this.emitter = emitter;\n        this.isSharded = isSharded;\n        this.started = false;\n        //There is only one connection for the entire pool\n        this.subscriber = null;\n        //The slot range for which this subscriber is responsible\n        this.slotRange = [];\n        this.onSubscriberEnd = ()=>{\n            if (!this.started) {\n                debug(\"subscriber has disconnected, but ClusterSubscriber is not started, so not reconnecting.\");\n                return;\n            }\n            // If the subscriber closes whilst it's still the active connection,\n            // we might as well try to connecting to a new node if possible to\n            // minimise the number of missed publishes.\n            debug(\"subscriber has disconnected, selecting a new one...\");\n            this.selectSubscriber();\n        };\n        // If the current node we're using as the subscriber disappears\n        // from the node pool for some reason, we will select a new one\n        // to connect to.\n        // Note that this event is only triggered if the connection to\n        // the node has been used; cluster subscriptions are setup with\n        // lazyConnect = true. It's possible for the subscriber node to\n        // disappear without this method being called!\n        // See https://github.com/luin/ioredis/pull/1589\n        this.connectionPool.on(\"-node\", (_, key)=>{\n            if (!this.started || !this.subscriber) {\n                return;\n            }\n            if ((0, util_1.getNodeKey)(this.subscriber.options) === key) {\n                debug(\"subscriber has left, selecting a new one...\");\n                this.selectSubscriber();\n            }\n        });\n        this.connectionPool.on(\"+node\", ()=>{\n            if (!this.started || this.subscriber) {\n                return;\n            }\n            debug(\"a new node is discovered and there is no subscriber, selecting a new one...\");\n            this.selectSubscriber();\n        });\n    }\n    getInstance() {\n        return this.subscriber;\n    }\n    /**\n     * Associate this subscriber to a specific slot range.\n     *\n     * Returns the range or an empty array if the slot range couldn't be associated.\n     *\n     * BTW: This is more for debugging and testing purposes.\n     *\n     * @param range\n     */ associateSlotRange(range) {\n        if (this.isSharded) {\n            this.slotRange = range;\n        }\n        return this.slotRange;\n    }\n    start() {\n        this.started = true;\n        this.selectSubscriber();\n        debug(\"started\");\n    }\n    stop() {\n        this.started = false;\n        if (this.subscriber) {\n            this.subscriber.disconnect();\n            this.subscriber = null;\n        }\n    }\n    isStarted() {\n        return this.started;\n    }\n    selectSubscriber() {\n        const lastActiveSubscriber = this.lastActiveSubscriber;\n        // Disconnect the previous subscriber even if there\n        // will not be a new one.\n        if (lastActiveSubscriber) {\n            lastActiveSubscriber.off(\"end\", this.onSubscriberEnd);\n            lastActiveSubscriber.disconnect();\n        }\n        if (this.subscriber) {\n            this.subscriber.off(\"end\", this.onSubscriberEnd);\n            this.subscriber.disconnect();\n        }\n        const sampleNode = (0, utils_1.sample)(this.connectionPool.getNodes());\n        if (!sampleNode) {\n            debug(\"selecting subscriber failed since there is no node discovered in the cluster yet\");\n            this.subscriber = null;\n            return;\n        }\n        const { options } = sampleNode;\n        debug(\"selected a subscriber %s:%s\", options.host, options.port);\n        /*\n         * Create a specialized Redis connection for the subscription.\n         * Note that auto reconnection is enabled here.\n         *\n         * `enableReadyCheck` is also enabled because although subscription is allowed\n         * while redis is loading data from the disk, we can check if the password\n         * provided for the subscriber is correct, and if not, the current subscriber\n         * will be disconnected and a new subscriber will be selected.\n         */ let connectionPrefix = \"subscriber\";\n        if (this.isSharded) connectionPrefix = \"ssubscriber\";\n        this.subscriber = new Redis_1.default({\n            port: options.port,\n            host: options.host,\n            username: options.username,\n            password: options.password,\n            enableReadyCheck: true,\n            connectionName: (0, util_1.getConnectionName)(connectionPrefix, options.connectionName),\n            lazyConnect: true,\n            tls: options.tls,\n            // Don't try to reconnect the subscriber connection. If the connection fails\n            // we will get an end event (handled below), at which point we'll pick a new\n            // node from the pool and try to connect to that as the subscriber connection.\n            retryStrategy: null\n        });\n        // Ignore the errors since they're handled in the connection pool.\n        this.subscriber.on(\"error\", utils_1.noop);\n        this.subscriber.on(\"moved\", ()=>{\n            this.emitter.emit(\"forceRefresh\");\n        });\n        // The node we lost connection to may not come back up in a\n        // reasonable amount of time (e.g. a slave that's taken down\n        // for maintainence), we could potentially miss many published\n        // messages so we should reconnect as quickly as possible, to\n        // a different node if needed.\n        this.subscriber.once(\"end\", this.onSubscriberEnd);\n        // Re-subscribe previous channels\n        const previousChannels = {\n            subscribe: [],\n            psubscribe: [],\n            ssubscribe: []\n        };\n        if (lastActiveSubscriber) {\n            const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;\n            if (condition && condition.subscriber) {\n                previousChannels.subscribe = condition.subscriber.channels(\"subscribe\");\n                previousChannels.psubscribe = condition.subscriber.channels(\"psubscribe\");\n                previousChannels.ssubscribe = condition.subscriber.channels(\"ssubscribe\");\n            }\n        }\n        if (previousChannels.subscribe.length || previousChannels.psubscribe.length || previousChannels.ssubscribe.length) {\n            let pending = 0;\n            for (const type of [\n                \"subscribe\",\n                \"psubscribe\",\n                \"ssubscribe\"\n            ]){\n                const channels = previousChannels[type];\n                if (channels.length == 0) {\n                    continue;\n                }\n                debug(\"%s %d channels\", type, channels.length);\n                if (type === \"ssubscribe\") {\n                    for (const channel of channels){\n                        pending += 1;\n                        this.subscriber[type](channel).then(()=>{\n                            if (!--pending) {\n                                this.lastActiveSubscriber = this.subscriber;\n                            }\n                        }).catch(()=>{\n                            // TODO: should probably disconnect the subscriber and try again.\n                            debug(\"failed to ssubscribe to channel: %s\", channel);\n                        });\n                    }\n                } else {\n                    pending += 1;\n                    this.subscriber[type](channels).then(()=>{\n                        if (!--pending) {\n                            this.lastActiveSubscriber = this.subscriber;\n                        }\n                    }).catch(()=>{\n                        // TODO: should probably disconnect the subscriber and try again.\n                        debug(\"failed to %s %d channels\", type, channels.length);\n                    });\n                }\n            }\n        } else {\n            this.lastActiveSubscriber = this.subscriber;\n        }\n        for (const event of [\n            \"message\",\n            \"messageBuffer\"\n        ]){\n            this.subscriber.on(event, (arg1, arg2)=>{\n                this.emitter.emit(event, arg1, arg2);\n            });\n        }\n        for (const event of [\n            \"pmessage\",\n            \"pmessageBuffer\"\n        ]){\n            this.subscriber.on(event, (arg1, arg2, arg3)=>{\n                this.emitter.emit(event, arg1, arg2, arg3);\n            });\n        }\n        if (this.isSharded == true) {\n            for (const event of [\n                \"smessage\",\n                \"smessageBuffer\"\n            ]){\n                this.subscriber.on(event, (arg1, arg2)=>{\n                    this.emitter.emit(event, arg1, arg2);\n                });\n            }\n        }\n    }\n}\nexports[\"default\"] = ClusterSubscriber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0NsdXN0ZXJTdWJzY3JpYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLGtFQUFRO0FBQy9CLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLG1FQUFVO0FBQ2xDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLDZEQUFVO0FBQ2xDLE1BQU1HLFFBQVEsQ0FBQyxHQUFHRixRQUFRRyxLQUFLLEVBQUU7QUFDakMsTUFBTUM7SUFDRkMsWUFBWUMsY0FBYyxFQUFFQyxPQUFPLEVBQUVDLFlBQVksS0FBSyxDQUFFO1FBQ3BELElBQUksQ0FBQ0YsY0FBYyxHQUFHQTtRQUN0QixJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixrREFBa0Q7UUFDbEQsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIseURBQXlEO1FBQ3pELElBQUksQ0FBQ0MsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7WUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQ0gsT0FBTyxFQUFFO2dCQUNmUCxNQUFNO2dCQUNOO1lBQ0o7WUFDQSxvRUFBb0U7WUFDcEUsa0VBQWtFO1lBQ2xFLDJDQUEyQztZQUMzQ0EsTUFBTTtZQUNOLElBQUksQ0FBQ1csZ0JBQWdCO1FBQ3pCO1FBQ0EsK0RBQStEO1FBQy9ELCtEQUErRDtRQUMvRCxpQkFBaUI7UUFDakIsOERBQThEO1FBQzlELCtEQUErRDtRQUMvRCwrREFBK0Q7UUFDL0QsOENBQThDO1FBQzlDLGdEQUFnRDtRQUNoRCxJQUFJLENBQUNQLGNBQWMsQ0FBQ1EsRUFBRSxDQUFDLFNBQVMsQ0FBQ0MsR0FBR0M7WUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQ1As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SSxDQUFDdEQsU0FBUyxJQUFJLE1BQU07WUFDeEIsS0FBSyxNQUFNbUQsU0FBUztnQkFDaEI7Z0JBQ0E7YUFDSCxDQUFFO2dCQUNDLElBQUksQ0FBQ2pELFVBQVUsQ0FBQ0ksRUFBRSxDQUFDNkMsT0FBTyxDQUFDQyxNQUFNQztvQkFDN0IsSUFBSSxDQUFDdEQsT0FBTyxDQUFDcUMsSUFBSSxDQUFDZSxPQUFPQyxNQUFNQztnQkFDbkM7WUFDSjtRQUNKO0lBQ0o7QUFDSjtBQUNBakUsa0JBQWUsR0FBR1EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0LWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2NsdXN0ZXIvQ2x1c3RlclN1YnNjcmliZXIuanM/OTA3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgUmVkaXNfMSA9IHJlcXVpcmUoXCIuLi9SZWRpc1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiY2x1c3RlcjpzdWJzY3JpYmVyXCIpO1xuY2xhc3MgQ2x1c3RlclN1YnNjcmliZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25Qb29sLCBlbWl0dGVyLCBpc1NoYXJkZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sID0gY29ubmVjdGlvblBvb2w7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgICAgIHRoaXMuaXNTaGFyZGVkID0gaXNTaGFyZGVkO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy9UaGVyZSBpcyBvbmx5IG9uZSBjb25uZWN0aW9uIGZvciB0aGUgZW50aXJlIHBvb2xcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gbnVsbDtcbiAgICAgICAgLy9UaGUgc2xvdCByYW5nZSBmb3Igd2hpY2ggdGhpcyBzdWJzY3JpYmVyIGlzIHJlc3BvbnNpYmxlXG4gICAgICAgIHRoaXMuc2xvdFJhbmdlID0gW107XG4gICAgICAgIHRoaXMub25TdWJzY3JpYmVyRW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInN1YnNjcmliZXIgaGFzIGRpc2Nvbm5lY3RlZCwgYnV0IENsdXN0ZXJTdWJzY3JpYmVyIGlzIG5vdCBzdGFydGVkLCBzbyBub3QgcmVjb25uZWN0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3Vic2NyaWJlciBjbG9zZXMgd2hpbHN0IGl0J3Mgc3RpbGwgdGhlIGFjdGl2ZSBjb25uZWN0aW9uLFxuICAgICAgICAgICAgLy8gd2UgbWlnaHQgYXMgd2VsbCB0cnkgdG8gY29ubmVjdGluZyB0byBhIG5ldyBub2RlIGlmIHBvc3NpYmxlIHRvXG4gICAgICAgICAgICAvLyBtaW5pbWlzZSB0aGUgbnVtYmVyIG9mIG1pc3NlZCBwdWJsaXNoZXMuXG4gICAgICAgICAgICBkZWJ1ZyhcInN1YnNjcmliZXIgaGFzIGRpc2Nvbm5lY3RlZCwgc2VsZWN0aW5nIGEgbmV3IG9uZS4uLlwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0U3Vic2NyaWJlcigpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBub2RlIHdlJ3JlIHVzaW5nIGFzIHRoZSBzdWJzY3JpYmVyIGRpc2FwcGVhcnNcbiAgICAgICAgLy8gZnJvbSB0aGUgbm9kZSBwb29sIGZvciBzb21lIHJlYXNvbiwgd2Ugd2lsbCBzZWxlY3QgYSBuZXcgb25lXG4gICAgICAgIC8vIHRvIGNvbm5lY3QgdG8uXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGV2ZW50IGlzIG9ubHkgdHJpZ2dlcmVkIGlmIHRoZSBjb25uZWN0aW9uIHRvXG4gICAgICAgIC8vIHRoZSBub2RlIGhhcyBiZWVuIHVzZWQ7IGNsdXN0ZXIgc3Vic2NyaXB0aW9ucyBhcmUgc2V0dXAgd2l0aFxuICAgICAgICAvLyBsYXp5Q29ubmVjdCA9IHRydWUuIEl0J3MgcG9zc2libGUgZm9yIHRoZSBzdWJzY3JpYmVyIG5vZGUgdG9cbiAgICAgICAgLy8gZGlzYXBwZWFyIHdpdGhvdXQgdGhpcyBtZXRob2QgYmVpbmcgY2FsbGVkIVxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2x1aW4vaW9yZWRpcy9wdWxsLzE1ODlcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5vbihcIi1ub2RlXCIsIChfLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGFydGVkIHx8ICF0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxfMS5nZXROb2RlS2V5KSh0aGlzLnN1YnNjcmliZXIub3B0aW9ucykgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic3Vic2NyaWJlciBoYXMgbGVmdCwgc2VsZWN0aW5nIGEgbmV3IG9uZS4uLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFN1YnNjcmliZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wub24oXCIrbm9kZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCB8fCB0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZyhcImEgbmV3IG5vZGUgaXMgZGlzY292ZXJlZCBhbmQgdGhlcmUgaXMgbm8gc3Vic2NyaWJlciwgc2VsZWN0aW5nIGEgbmV3IG9uZS4uLlwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0U3Vic2NyaWJlcigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZSB0aGlzIHN1YnNjcmliZXIgdG8gYSBzcGVjaWZpYyBzbG90IHJhbmdlLlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgcmFuZ2Ugb3IgYW4gZW1wdHkgYXJyYXkgaWYgdGhlIHNsb3QgcmFuZ2UgY291bGRuJ3QgYmUgYXNzb2NpYXRlZC5cbiAgICAgKlxuICAgICAqIEJUVzogVGhpcyBpcyBtb3JlIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmcgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2VcbiAgICAgKi9cbiAgICBhc3NvY2lhdGVTbG90UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaGFyZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNsb3RSYW5nZSA9IHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNsb3RSYW5nZTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0U3Vic2NyaWJlcigpO1xuICAgICAgICBkZWJ1ZyhcInN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1N0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ZWQ7XG4gICAgfVxuICAgIHNlbGVjdFN1YnNjcmliZXIoKSB7XG4gICAgICAgIGNvbnN0IGxhc3RBY3RpdmVTdWJzY3JpYmVyID0gdGhpcy5sYXN0QWN0aXZlU3Vic2NyaWJlcjtcbiAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgcHJldmlvdXMgc3Vic2NyaWJlciBldmVuIGlmIHRoZXJlXG4gICAgICAgIC8vIHdpbGwgbm90IGJlIGEgbmV3IG9uZS5cbiAgICAgICAgaWYgKGxhc3RBY3RpdmVTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBsYXN0QWN0aXZlU3Vic2NyaWJlci5vZmYoXCJlbmRcIiwgdGhpcy5vblN1YnNjcmliZXJFbmQpO1xuICAgICAgICAgICAgbGFzdEFjdGl2ZVN1YnNjcmliZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5vZmYoXCJlbmRcIiwgdGhpcy5vblN1YnNjcmliZXJFbmQpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYW1wbGVOb2RlID0gKDAsIHV0aWxzXzEuc2FtcGxlKSh0aGlzLmNvbm5lY3Rpb25Qb29sLmdldE5vZGVzKCkpO1xuICAgICAgICBpZiAoIXNhbXBsZU5vZGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2VsZWN0aW5nIHN1YnNjcmliZXIgZmFpbGVkIHNpbmNlIHRoZXJlIGlzIG5vIG5vZGUgZGlzY292ZXJlZCBpbiB0aGUgY2x1c3RlciB5ZXRcIik7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gc2FtcGxlTm9kZTtcbiAgICAgICAgZGVidWcoXCJzZWxlY3RlZCBhIHN1YnNjcmliZXIgJXM6JXNcIiwgb3B0aW9ucy5ob3N0LCBvcHRpb25zLnBvcnQpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBDcmVhdGUgYSBzcGVjaWFsaXplZCBSZWRpcyBjb25uZWN0aW9uIGZvciB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICAgKiBOb3RlIHRoYXQgYXV0byByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBoZXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgZW5hYmxlUmVhZHlDaGVja2AgaXMgYWxzbyBlbmFibGVkIGJlY2F1c2UgYWx0aG91Z2ggc3Vic2NyaXB0aW9uIGlzIGFsbG93ZWRcbiAgICAgICAgICogd2hpbGUgcmVkaXMgaXMgbG9hZGluZyBkYXRhIGZyb20gdGhlIGRpc2ssIHdlIGNhbiBjaGVjayBpZiB0aGUgcGFzc3dvcmRcbiAgICAgICAgICogcHJvdmlkZWQgZm9yIHRoZSBzdWJzY3JpYmVyIGlzIGNvcnJlY3QsIGFuZCBpZiBub3QsIHRoZSBjdXJyZW50IHN1YnNjcmliZXJcbiAgICAgICAgICogd2lsbCBiZSBkaXNjb25uZWN0ZWQgYW5kIGEgbmV3IHN1YnNjcmliZXIgd2lsbCBiZSBzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBjb25uZWN0aW9uUHJlZml4ID0gXCJzdWJzY3JpYmVyXCI7XG4gICAgICAgIGlmICh0aGlzLmlzU2hhcmRlZClcbiAgICAgICAgICAgIGNvbm5lY3Rpb25QcmVmaXggPSBcInNzdWJzY3JpYmVyXCI7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBSZWRpc18xLmRlZmF1bHQoe1xuICAgICAgICAgICAgcG9ydDogb3B0aW9ucy5wb3J0LFxuICAgICAgICAgICAgaG9zdDogb3B0aW9ucy5ob3N0LFxuICAgICAgICAgICAgdXNlcm5hbWU6IG9wdGlvbnMudXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogb3B0aW9ucy5wYXNzd29yZCxcbiAgICAgICAgICAgIGVuYWJsZVJlYWR5Q2hlY2s6IHRydWUsXG4gICAgICAgICAgICBjb25uZWN0aW9uTmFtZTogKDAsIHV0aWxfMS5nZXRDb25uZWN0aW9uTmFtZSkoY29ubmVjdGlvblByZWZpeCwgb3B0aW9ucy5jb25uZWN0aW9uTmFtZSksXG4gICAgICAgICAgICBsYXp5Q29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgIHRsczogb3B0aW9ucy50bHMsXG4gICAgICAgICAgICAvLyBEb24ndCB0cnkgdG8gcmVjb25uZWN0IHRoZSBzdWJzY3JpYmVyIGNvbm5lY3Rpb24uIElmIHRoZSBjb25uZWN0aW9uIGZhaWxzXG4gICAgICAgICAgICAvLyB3ZSB3aWxsIGdldCBhbiBlbmQgZXZlbnQgKGhhbmRsZWQgYmVsb3cpLCBhdCB3aGljaCBwb2ludCB3ZSdsbCBwaWNrIGEgbmV3XG4gICAgICAgICAgICAvLyBub2RlIGZyb20gdGhlIHBvb2wgYW5kIHRyeSB0byBjb25uZWN0IHRvIHRoYXQgYXMgdGhlIHN1YnNjcmliZXIgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIHJldHJ5U3RyYXRlZ3k6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGVycm9ycyBzaW5jZSB0aGV5J3JlIGhhbmRsZWQgaW4gdGhlIGNvbm5lY3Rpb24gcG9vbC5cbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uKFwiZXJyb3JcIiwgdXRpbHNfMS5ub29wKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uKFwibW92ZWRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJmb3JjZVJlZnJlc2hcIik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgbm9kZSB3ZSBsb3N0IGNvbm5lY3Rpb24gdG8gbWF5IG5vdCBjb21lIGJhY2sgdXAgaW4gYVxuICAgICAgICAvLyByZWFzb25hYmxlIGFtb3VudCBvZiB0aW1lIChlLmcuIGEgc2xhdmUgdGhhdCdzIHRha2VuIGRvd25cbiAgICAgICAgLy8gZm9yIG1haW50YWluZW5jZSksIHdlIGNvdWxkIHBvdGVudGlhbGx5IG1pc3MgbWFueSBwdWJsaXNoZWRcbiAgICAgICAgLy8gbWVzc2FnZXMgc28gd2Ugc2hvdWxkIHJlY29ubmVjdCBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLCB0b1xuICAgICAgICAvLyBhIGRpZmZlcmVudCBub2RlIGlmIG5lZWRlZC5cbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uY2UoXCJlbmRcIiwgdGhpcy5vblN1YnNjcmliZXJFbmQpO1xuICAgICAgICAvLyBSZS1zdWJzY3JpYmUgcHJldmlvdXMgY2hhbm5lbHNcbiAgICAgICAgY29uc3QgcHJldmlvdXNDaGFubmVscyA9IHsgc3Vic2NyaWJlOiBbXSwgcHN1YnNjcmliZTogW10sIHNzdWJzY3JpYmU6IFtdIH07XG4gICAgICAgIGlmIChsYXN0QWN0aXZlU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gbGFzdEFjdGl2ZVN1YnNjcmliZXIuY29uZGl0aW9uIHx8IGxhc3RBY3RpdmVTdWJzY3JpYmVyLnByZXZDb25kaXRpb247XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uICYmIGNvbmRpdGlvbi5zdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNDaGFubmVscy5zdWJzY3JpYmUgPSBjb25kaXRpb24uc3Vic2NyaWJlci5jaGFubmVscyhcInN1YnNjcmliZVwiKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0NoYW5uZWxzLnBzdWJzY3JpYmUgPVxuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24uc3Vic2NyaWJlci5jaGFubmVscyhcInBzdWJzY3JpYmVcIik7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNDaGFubmVscy5zc3Vic2NyaWJlID1cbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uLnN1YnNjcmliZXIuY2hhbm5lbHMoXCJzc3Vic2NyaWJlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c0NoYW5uZWxzLnN1YnNjcmliZS5sZW5ndGggfHxcbiAgICAgICAgICAgIHByZXZpb3VzQ2hhbm5lbHMucHN1YnNjcmliZS5sZW5ndGggfHxcbiAgICAgICAgICAgIHByZXZpb3VzQ2hhbm5lbHMuc3N1YnNjcmliZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBwZW5kaW5nID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbXCJzdWJzY3JpYmVcIiwgXCJwc3Vic2NyaWJlXCIsIFwic3N1YnNjcmliZVwiXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxzID0gcHJldmlvdXNDaGFubmVsc1t0eXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlYnVnKFwiJXMgJWQgY2hhbm5lbHNcIiwgdHlwZSwgY2hhbm5lbHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJzc3Vic2NyaWJlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGFubmVsIG9mIGNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJbdHlwZV0oY2hhbm5lbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0QWN0aXZlU3Vic2NyaWJlciA9IHRoaXMuc3Vic2NyaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogc2hvdWxkIHByb2JhYmx5IGRpc2Nvbm5lY3QgdGhlIHN1YnNjcmliZXIgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImZhaWxlZCB0byBzc3Vic2NyaWJlIHRvIGNoYW5uZWw6ICVzXCIsIGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyW3R5cGVdKGNoYW5uZWxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RBY3RpdmVTdWJzY3JpYmVyID0gdGhpcy5zdWJzY3JpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZCBwcm9iYWJseSBkaXNjb25uZWN0IHRoZSBzdWJzY3JpYmVyIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImZhaWxlZCB0byAlcyAlZCBjaGFubmVsc1wiLCB0eXBlLCBjaGFubmVscy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RBY3RpdmVTdWJzY3JpYmVyID0gdGhpcy5zdWJzY3JpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgW1xuICAgICAgICAgICAgXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICBcIm1lc3NhZ2VCdWZmZXJcIixcbiAgICAgICAgXSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uKGV2ZW50LCAoYXJnMSwgYXJnMikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KGV2ZW50LCBhcmcxLCBhcmcyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgW1wicG1lc3NhZ2VcIiwgXCJwbWVzc2FnZUJ1ZmZlclwiXSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uKGV2ZW50LCAoYXJnMSwgYXJnMiwgYXJnMykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KGV2ZW50LCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU2hhcmRlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIFtcbiAgICAgICAgICAgICAgICBcInNtZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgXCJzbWVzc2FnZUJ1ZmZlclwiLFxuICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5vbihldmVudCwgKGFyZzEsIGFyZzIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoZXZlbnQsIGFyZzEsIGFyZzIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2x1c3RlclN1YnNjcmliZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1dGlsXzEiLCJyZXF1aXJlIiwidXRpbHNfMSIsIlJlZGlzXzEiLCJkZWJ1ZyIsIkRlYnVnIiwiQ2x1c3RlclN1YnNjcmliZXIiLCJjb25zdHJ1Y3RvciIsImNvbm5lY3Rpb25Qb29sIiwiZW1pdHRlciIsImlzU2hhcmRlZCIsInN0YXJ0ZWQiLCJzdWJzY3JpYmVyIiwic2xvdFJhbmdlIiwib25TdWJzY3JpYmVyRW5kIiwic2VsZWN0U3Vic2NyaWJlciIsIm9uIiwiXyIsImtleSIsImdldE5vZGVLZXkiLCJvcHRpb25zIiwiZ2V0SW5zdGFuY2UiLCJhc3NvY2lhdGVTbG90UmFuZ2UiLCJyYW5nZSIsInN0YXJ0Iiwic3RvcCIsImRpc2Nvbm5lY3QiLCJpc1N0YXJ0ZWQiLCJsYXN0QWN0aXZlU3Vic2NyaWJlciIsIm9mZiIsInNhbXBsZU5vZGUiLCJzYW1wbGUiLCJnZXROb2RlcyIsImhvc3QiLCJwb3J0IiwiY29ubmVjdGlvblByZWZpeCIsImRlZmF1bHQiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiZW5hYmxlUmVhZHlDaGVjayIsImNvbm5lY3Rpb25OYW1lIiwiZ2V0Q29ubmVjdGlvbk5hbWUiLCJsYXp5Q29ubmVjdCIsInRscyIsInJldHJ5U3RyYXRlZ3kiLCJub29wIiwiZW1pdCIsIm9uY2UiLCJwcmV2aW91c0NoYW5uZWxzIiwic3Vic2NyaWJlIiwicHN1YnNjcmliZSIsInNzdWJzY3JpYmUiLCJjb25kaXRpb24iLCJwcmV2Q29uZGl0aW9uIiwiY2hhbm5lbHMiLCJsZW5ndGgiLCJwZW5kaW5nIiwidHlwZSIsImNoYW5uZWwiLCJ0aGVuIiwiY2F0Y2giLCJldmVudCIsImFyZzEiLCJhcmcyIiwiYXJnMyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriber.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/ioredis/built/cluster/util.js\");\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/./node_modules/cluster-key-slot/lib/index.js\");\nconst ShardedSubscriber_1 = __webpack_require__(/*! ./ShardedSubscriber */ \"(rsc)/./node_modules/ioredis/built/cluster/ShardedSubscriber.js\");\nconst debug = (0, utils_1.Debug)(\"cluster:subscriberGroup\");\n/**\n * Redis distinguishes between \"normal\" and sharded PubSub. When using the normal PubSub feature,\n * exactly one subscriber exists per cluster instance because the Redis cluster bus forwards\n * messages between shards. Sharded PubSub removes this limitation by making each shard\n * responsible for its own messages.\n *\n * This class coordinates one ShardedSubscriber per master node in the cluster, providing\n * sharded PubSub support while keeping the public API backward compatible.\n */ class ClusterSubscriberGroup {\n    /**\n     * Register callbacks\n     *\n     * @param cluster\n     */ constructor(subscriberGroupEmitter){\n        this.subscriberGroupEmitter = subscriberGroupEmitter;\n        this.shardedSubscribers = new Map();\n        this.clusterSlots = [];\n        // Simple [min, max] slot ranges aren't enough because you can migrate single slots\n        this.subscriberToSlotsIndex = new Map();\n        this.channels = new Map();\n        this.failedAttemptsByNode = new Map();\n        // Only latest pending reset kept; throttled by refreshSlotsCache's isRefreshing + backoff delay\n        this.isResetting = false;\n        this.pendingReset = null;\n        /**\n         * Handles failed subscriber connections by emitting an event to refresh the slots cache\n         * after a backoff period.\n         *\n         * @param error\n         * @param nodeKey\n         */ this.handleSubscriberConnectFailed = (error, nodeKey)=>{\n            const currentAttempts = this.failedAttemptsByNode.get(nodeKey) || 0;\n            const failedAttempts = currentAttempts + 1;\n            this.failedAttemptsByNode.set(nodeKey, failedAttempts);\n            const attempts = Math.min(failedAttempts, ClusterSubscriberGroup.MAX_RETRY_ATTEMPTS);\n            const backoff = Math.min(ClusterSubscriberGroup.BASE_BACKOFF_MS * 2 ** attempts, ClusterSubscriberGroup.MAX_BACKOFF_MS);\n            const jitter = Math.floor((Math.random() - 0.5) * (backoff * 0.5));\n            const delay = Math.max(0, backoff + jitter);\n            debug(\"Failed to connect subscriber for %s. Refreshing slots in %dms\", nodeKey, delay);\n            this.subscriberGroupEmitter.emit(\"subscriberConnectFailed\", {\n                delay,\n                error\n            });\n        };\n        /**\n         * Handles successful subscriber connections by resetting the failed attempts counter.\n         *\n         * @param nodeKey\n         */ this.handleSubscriberConnectSucceeded = (nodeKey)=>{\n            this.failedAttemptsByNode.delete(nodeKey);\n        };\n    }\n    /**\n     * Get the responsible subscriber.\n     *\n     * @param slot\n     */ getResponsibleSubscriber(slot) {\n        const nodeKey = this.clusterSlots[slot][0];\n        return this.shardedSubscribers.get(nodeKey);\n    }\n    /**\n     * Adds a channel for which this subscriber group is responsible\n     *\n     * @param channels\n     */ addChannels(channels) {\n        const slot = calculateSlot(channels[0]);\n        // Check if the all channels belong to the same slot and otherwise reject the operation\n        for (const c of channels){\n            if (calculateSlot(c) !== slot) {\n                return -1;\n            }\n        }\n        const currChannels = this.channels.get(slot);\n        if (!currChannels) {\n            this.channels.set(slot, channels);\n        } else {\n            this.channels.set(slot, currChannels.concat(channels));\n        }\n        return Array.from(this.channels.values()).reduce((sum, array)=>sum + array.length, 0);\n    }\n    /**\n     * Removes channels for which the subscriber group is responsible by optionally unsubscribing\n     * @param channels\n     */ removeChannels(channels) {\n        const slot = calculateSlot(channels[0]);\n        // Check if the all channels belong to the same slot and otherwise reject the operation\n        for (const c of channels){\n            if (calculateSlot(c) !== slot) {\n                return -1;\n            }\n        }\n        const slotChannels = this.channels.get(slot);\n        if (slotChannels) {\n            const updatedChannels = slotChannels.filter((c)=>!channels.includes(c));\n            this.channels.set(slot, updatedChannels);\n        }\n        return Array.from(this.channels.values()).reduce((sum, array)=>sum + array.length, 0);\n    }\n    /**\n     * Disconnect all subscribers and clear some of the internal state.\n     */ stop() {\n        for (const s of this.shardedSubscribers.values()){\n            s.stop();\n        }\n        // Clear subscriber instances and pending operations.\n        // Channels are preserved for resubscription on reconnect.\n        this.pendingReset = null;\n        this.shardedSubscribers.clear();\n        this.subscriberToSlotsIndex.clear();\n    }\n    /**\n     * Start all not yet started subscribers\n     */ start() {\n        const startPromises = [];\n        for (const s of this.shardedSubscribers.values()){\n            if (!s.isStarted()) {\n                startPromises.push(s.start().then(()=>{\n                    this.handleSubscriberConnectSucceeded(s.getNodeKey());\n                }).catch((err)=>{\n                    this.handleSubscriberConnectFailed(err, s.getNodeKey());\n                }));\n            }\n        }\n        return Promise.all(startPromises);\n    }\n    /**\n     * Resets the subscriber group by disconnecting all subscribers that are no longer needed and connecting new ones.\n     */ async reset(clusterSlots, clusterNodes) {\n        if (this.isResetting) {\n            this.pendingReset = {\n                slots: clusterSlots,\n                nodes: clusterNodes\n            };\n            return;\n        }\n        this.isResetting = true;\n        try {\n            const hasTopologyChanged = this._refreshSlots(clusterSlots);\n            const hasFailedSubscribers = this.hasUnhealthySubscribers();\n            if (!hasTopologyChanged && !hasFailedSubscribers) {\n                debug(\"No topology change detected or failed subscribers. Skipping reset.\");\n                return;\n            }\n            // For each of the sharded subscribers\n            for (const [nodeKey, shardedSubscriber] of this.shardedSubscribers){\n                if (// If the subscriber is still responsible for a slot range and is running then keep it\n                this.subscriberToSlotsIndex.has(nodeKey) && shardedSubscriber.isStarted()) {\n                    debug(\"Skipping deleting subscriber for %s\", nodeKey);\n                    continue;\n                }\n                debug(\"Removing subscriber for %s\", nodeKey);\n                // Otherwise stop the subscriber and remove it\n                shardedSubscriber.stop();\n                this.shardedSubscribers.delete(nodeKey);\n                this.subscriberGroupEmitter.emit(\"-subscriber\");\n            }\n            const startPromises = [];\n            // For each node in slots cache\n            for (const [nodeKey, _] of this.subscriberToSlotsIndex){\n                // If we already have a subscriber for this node then keep it\n                if (this.shardedSubscribers.has(nodeKey)) {\n                    debug(\"Skipping creating new subscriber for %s\", nodeKey);\n                    continue;\n                }\n                debug(\"Creating new subscriber for %s\", nodeKey);\n                // Otherwise create a new subscriber\n                const redis = clusterNodes.find((node)=>{\n                    return (0, util_1.getNodeKey)(node.options) === nodeKey;\n                });\n                if (!redis) {\n                    debug(\"Failed to find node for key %s\", nodeKey);\n                    continue;\n                }\n                const sub = new ShardedSubscriber_1.default(this.subscriberGroupEmitter, redis.options);\n                this.shardedSubscribers.set(nodeKey, sub);\n                startPromises.push(sub.start().then(()=>{\n                    this.handleSubscriberConnectSucceeded(nodeKey);\n                }).catch((error)=>{\n                    this.handleSubscriberConnectFailed(error, nodeKey);\n                }));\n                this.subscriberGroupEmitter.emit(\"+subscriber\");\n            }\n            // It's vital to await the start promises before resubscribing\n            // Otherwise we might try to resubscribe to a subscriber that is not yet connected\n            // This can cause a race condition\n            await Promise.all(startPromises);\n            this._resubscribe();\n            this.subscriberGroupEmitter.emit(\"subscribersReady\");\n        } finally{\n            this.isResetting = false;\n            if (this.pendingReset) {\n                const { slots, nodes } = this.pendingReset;\n                this.pendingReset = null;\n                await this.reset(slots, nodes);\n            }\n        }\n    }\n    /**\n     * Refreshes the subscriber-related slot ranges\n     *\n     * Returns false if no refresh was needed\n     *\n     * @param targetSlots\n     */ _refreshSlots(targetSlots) {\n        //If there was an actual change, then reassign the slot ranges\n        if (this._slotsAreEqual(targetSlots)) {\n            debug(\"Nothing to refresh because the new cluster map is equal to the previous one.\");\n            return false;\n        }\n        debug(\"Refreshing the slots of the subscriber group.\");\n        //Rebuild the slots index\n        this.subscriberToSlotsIndex = new Map();\n        for(let slot = 0; slot < targetSlots.length; slot++){\n            const node = targetSlots[slot][0];\n            if (!this.subscriberToSlotsIndex.has(node)) {\n                this.subscriberToSlotsIndex.set(node, []);\n            }\n            this.subscriberToSlotsIndex.get(node).push(Number(slot));\n        }\n        //Update the cached slots map\n        this.clusterSlots = JSON.parse(JSON.stringify(targetSlots));\n        return true;\n    }\n    /**\n     * Resubscribes to the previous channels\n     *\n     * @private\n     */ _resubscribe() {\n        if (this.shardedSubscribers) {\n            this.shardedSubscribers.forEach((s, nodeKey)=>{\n                const subscriberSlots = this.subscriberToSlotsIndex.get(nodeKey);\n                if (subscriberSlots) {\n                    //Resubscribe on the underlying connection\n                    subscriberSlots.forEach((ss)=>{\n                        //Might return null if being disconnected\n                        const redis = s.getInstance();\n                        const channels = this.channels.get(ss);\n                        if (channels && channels.length > 0) {\n                            if (redis.status === \"end\") {\n                                return;\n                            }\n                            if (redis.status === \"ready\") {\n                                redis.ssubscribe(...channels).catch((err)=>{\n                                    // TODO: Should we emit an error event here?\n                                    debug(\"Failed to ssubscribe on node %s: %s\", nodeKey, err);\n                                });\n                            } else {\n                                redis.once(\"ready\", ()=>{\n                                    redis.ssubscribe(...channels).catch((err)=>{\n                                        // TODO: Should we emit an error event here?\n                                        debug(\"Failed to ssubscribe on node %s: %s\", nodeKey, err);\n                                    });\n                                });\n                            }\n                        }\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Deep equality of the cluster slots objects\n     *\n     * @param other\n     * @private\n     */ _slotsAreEqual(other) {\n        if (this.clusterSlots === undefined) {\n            return false;\n        } else {\n            return JSON.stringify(this.clusterSlots) === JSON.stringify(other);\n        }\n    }\n    /**\n     * Checks if any subscribers are in an unhealthy state.\n     *\n     * A subscriber is considered unhealthy if:\n     * - It exists but is not started (failed/disconnected)\n     * - It's missing entirely for a node that should have one\n     *\n     * @returns true if any subscribers need to be recreated\n     */ hasUnhealthySubscribers() {\n        const hasFailedSubscribers = Array.from(this.shardedSubscribers.values()).some((sub)=>!sub.isStarted());\n        const hasMissingSubscribers = Array.from(this.subscriberToSlotsIndex.keys()).some((nodeKey)=>!this.shardedSubscribers.has(nodeKey));\n        return hasFailedSubscribers || hasMissingSubscribers;\n    }\n}\nexports[\"default\"] = ClusterSubscriberGroup;\n// Retry strategy\nClusterSubscriberGroup.MAX_RETRY_ATTEMPTS = 10;\nClusterSubscriberGroup.MAX_BACKOFF_MS = 2000;\nClusterSubscriberGroup.BASE_BACKOFF_MS = 100;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0NsdXN0ZXJTdWJzY3JpYmVyR3JvdXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsbUVBQVU7QUFDbEMsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUMsa0VBQVE7QUFDL0IsTUFBTUUsZ0JBQWdCRixtQkFBT0EsQ0FBQyw0RUFBa0I7QUFDaEQsTUFBTUcsc0JBQXNCSCxtQkFBT0EsQ0FBQyw0RkFBcUI7QUFDekQsTUFBTUksUUFBUSxDQUFDLEdBQUdMLFFBQVFNLEtBQUssRUFBRTtBQUNqQzs7Ozs7Ozs7Q0FRQyxHQUNELE1BQU1DO0lBQ0Y7Ozs7S0FJQyxHQUNEQyxZQUFZQyxzQkFBc0IsQ0FBRTtRQUNoQyxJQUFJLENBQUNBLHNCQUFzQixHQUFHQTtRQUM5QixJQUFJLENBQUNDLGtCQUFrQixHQUFHLElBQUlDO1FBQzlCLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEVBQUU7UUFDdEIsbUZBQW1GO1FBQ25GLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUcsSUFBSUY7UUFDbEMsSUFBSSxDQUFDRyxRQUFRLEdBQUcsSUFBSUg7UUFDcEIsSUFBSSxDQUFDSSxvQkFBb0IsR0FBRyxJQUFJSjtRQUNoQyxnR0FBZ0c7UUFDaEcsSUFBSSxDQUFDSyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEI7Ozs7OztTQU1DLEdBQ0QsSUFBSSxDQUFDQyw2QkFBNkIsR0FBRyxDQUFDQyxPQUFPQztZQUN6QyxNQUFNQyxrQkFBa0IsSUFBSSxDQUFDTixvQkFBb0IsQ0FBQ08sR0FBRyxDQUFDRixZQUFZO1lBQ2xFLE1BQU1HLGlCQUFpQkYsa0JBQWtCO1lBQ3pDLElBQUksQ0FBQ04sb0JBQW9CLENBQUNTLEdBQUcsQ0FBQ0osU0FBU0c7WUFDdkMsTUFBTUUsV0FBV0MsS0FBS0Ms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QUFDbEYsWUFBWSxNQUFNZ0YsS0FBS0UsU0FBUyxDQUFDUTtRQUNoRTtJQUNKO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRHhCLDBCQUEwQjtRQUN0QixNQUFNRCx1QkFBdUIvQixNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDckMsa0JBQWtCLENBQUNzQyxNQUFNLElBQUl3RCxJQUFJLENBQUMsQ0FBQ2xCLE1BQVEsQ0FBQ0EsSUFBSXZCLFNBQVM7UUFDdEcsTUFBTTBDLHdCQUF3QjNELE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUNsQyxzQkFBc0IsQ0FBQzZGLElBQUksSUFBSUYsSUFBSSxDQUFDLENBQUNwRixVQUFZLENBQUMsSUFBSSxDQUFDVixrQkFBa0IsQ0FBQ3NFLEdBQUcsQ0FBQzVEO1FBQzVILE9BQU95RCx3QkFBd0I0QjtJQUNuQztBQUNKO0FBQ0EzRyxrQkFBZSxHQUFHUztBQUNsQixpQkFBaUI7QUFDakJBLHVCQUF1QnFCLGtCQUFrQixHQUFHO0FBQzVDckIsdUJBQXVCd0IsY0FBYyxHQUFHO0FBQ3hDeEIsdUJBQXVCdUIsZUFBZSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvZHVjdC1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0NsdXN0ZXJTdWJzY3JpYmVyR3JvdXAuanM/MzI0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgY2FsY3VsYXRlU2xvdCA9IHJlcXVpcmUoXCJjbHVzdGVyLWtleS1zbG90XCIpO1xuY29uc3QgU2hhcmRlZFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoXCIuL1NoYXJkZWRTdWJzY3JpYmVyXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJjbHVzdGVyOnN1YnNjcmliZXJHcm91cFwiKTtcbi8qKlxuICogUmVkaXMgZGlzdGluZ3Vpc2hlcyBiZXR3ZWVuIFwibm9ybWFsXCIgYW5kIHNoYXJkZWQgUHViU3ViLiBXaGVuIHVzaW5nIHRoZSBub3JtYWwgUHViU3ViIGZlYXR1cmUsXG4gKiBleGFjdGx5IG9uZSBzdWJzY3JpYmVyIGV4aXN0cyBwZXIgY2x1c3RlciBpbnN0YW5jZSBiZWNhdXNlIHRoZSBSZWRpcyBjbHVzdGVyIGJ1cyBmb3J3YXJkc1xuICogbWVzc2FnZXMgYmV0d2VlbiBzaGFyZHMuIFNoYXJkZWQgUHViU3ViIHJlbW92ZXMgdGhpcyBsaW1pdGF0aW9uIGJ5IG1ha2luZyBlYWNoIHNoYXJkXG4gKiByZXNwb25zaWJsZSBmb3IgaXRzIG93biBtZXNzYWdlcy5cbiAqXG4gKiBUaGlzIGNsYXNzIGNvb3JkaW5hdGVzIG9uZSBTaGFyZGVkU3Vic2NyaWJlciBwZXIgbWFzdGVyIG5vZGUgaW4gdGhlIGNsdXN0ZXIsIHByb3ZpZGluZ1xuICogc2hhcmRlZCBQdWJTdWIgc3VwcG9ydCB3aGlsZSBrZWVwaW5nIHRoZSBwdWJsaWMgQVBJIGJhY2t3YXJkIGNvbXBhdGlibGUuXG4gKi9cbmNsYXNzIENsdXN0ZXJTdWJzY3JpYmVyR3JvdXAge1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGNhbGxiYWNrc1xuICAgICAqXG4gICAgICogQHBhcmFtIGNsdXN0ZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdWJzY3JpYmVyR3JvdXBFbWl0dGVyKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlckdyb3VwRW1pdHRlciA9IHN1YnNjcmliZXJHcm91cEVtaXR0ZXI7XG4gICAgICAgIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNsdXN0ZXJTbG90cyA9IFtdO1xuICAgICAgICAvLyBTaW1wbGUgW21pbiwgbWF4XSBzbG90IHJhbmdlcyBhcmVuJ3QgZW5vdWdoIGJlY2F1c2UgeW91IGNhbiBtaWdyYXRlIHNpbmdsZSBzbG90c1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJUb1Nsb3RzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZmFpbGVkQXR0ZW1wdHNCeU5vZGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE9ubHkgbGF0ZXN0IHBlbmRpbmcgcmVzZXQga2VwdDsgdGhyb3R0bGVkIGJ5IHJlZnJlc2hTbG90c0NhY2hlJ3MgaXNSZWZyZXNoaW5nICsgYmFja29mZiBkZWxheVxuICAgICAgICB0aGlzLmlzUmVzZXR0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc2V0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgZmFpbGVkIHN1YnNjcmliZXIgY29ubmVjdGlvbnMgYnkgZW1pdHRpbmcgYW4gZXZlbnQgdG8gcmVmcmVzaCB0aGUgc2xvdHMgY2FjaGVcbiAgICAgICAgICogYWZ0ZXIgYSBiYWNrb2ZmIHBlcmlvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVycm9yXG4gICAgICAgICAqIEBwYXJhbSBub2RlS2V5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmliZXJDb25uZWN0RmFpbGVkID0gKGVycm9yLCBub2RlS2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QXR0ZW1wdHMgPSB0aGlzLmZhaWxlZEF0dGVtcHRzQnlOb2RlLmdldChub2RlS2V5KSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgZmFpbGVkQXR0ZW1wdHMgPSBjdXJyZW50QXR0ZW1wdHMgKyAxO1xuICAgICAgICAgICAgdGhpcy5mYWlsZWRBdHRlbXB0c0J5Tm9kZS5zZXQobm9kZUtleSwgZmFpbGVkQXR0ZW1wdHMpO1xuICAgICAgICAgICAgY29uc3QgYXR0ZW1wdHMgPSBNYXRoLm1pbihmYWlsZWRBdHRlbXB0cywgQ2x1c3RlclN1YnNjcmliZXJHcm91cC5NQVhfUkVUUllfQVRURU1QVFMpO1xuICAgICAgICAgICAgY29uc3QgYmFja29mZiA9IE1hdGgubWluKENsdXN0ZXJTdWJzY3JpYmVyR3JvdXAuQkFTRV9CQUNLT0ZGX01TICogMiAqKiBhdHRlbXB0cywgQ2x1c3RlclN1YnNjcmliZXJHcm91cC5NQVhfQkFDS09GRl9NUyk7XG4gICAgICAgICAgICBjb25zdCBqaXR0ZXIgPSBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIChiYWNrb2ZmICogMC41KSk7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgubWF4KDAsIGJhY2tvZmYgKyBqaXR0ZXIpO1xuICAgICAgICAgICAgZGVidWcoXCJGYWlsZWQgdG8gY29ubmVjdCBzdWJzY3JpYmVyIGZvciAlcy4gUmVmcmVzaGluZyBzbG90cyBpbiAlZG1zXCIsIG5vZGVLZXksIGRlbGF5KTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlckdyb3VwRW1pdHRlci5lbWl0KFwic3Vic2NyaWJlckNvbm5lY3RGYWlsZWRcIiwge1xuICAgICAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIHN1Y2Nlc3NmdWwgc3Vic2NyaWJlciBjb25uZWN0aW9ucyBieSByZXNldHRpbmcgdGhlIGZhaWxlZCBhdHRlbXB0cyBjb3VudGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbm9kZUtleVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVTdWJzY3JpYmVyQ29ubmVjdFN1Y2NlZWRlZCA9IChub2RlS2V5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZhaWxlZEF0dGVtcHRzQnlOb2RlLmRlbGV0ZShub2RlS2V5KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZXNwb25zaWJsZSBzdWJzY3JpYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNsb3RcbiAgICAgKi9cbiAgICBnZXRSZXNwb25zaWJsZVN1YnNjcmliZXIoc2xvdCkge1xuICAgICAgICBjb25zdCBub2RlS2V5ID0gdGhpcy5jbHVzdGVyU2xvdHNbc2xvdF1bMF07XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycy5nZXQobm9kZUtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjaGFubmVsIGZvciB3aGljaCB0aGlzIHN1YnNjcmliZXIgZ3JvdXAgaXMgcmVzcG9uc2libGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsc1xuICAgICAqL1xuICAgIGFkZENoYW5uZWxzKGNoYW5uZWxzKSB7XG4gICAgICAgIGNvbnN0IHNsb3QgPSBjYWxjdWxhdGVTbG90KGNoYW5uZWxzWzBdKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFsbCBjaGFubmVscyBiZWxvbmcgdG8gdGhlIHNhbWUgc2xvdCBhbmQgb3RoZXJ3aXNlIHJlamVjdCB0aGUgb3BlcmF0aW9uXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjaGFubmVscykge1xuICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZVNsb3QoYykgIT09IHNsb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VyckNoYW5uZWxzID0gdGhpcy5jaGFubmVscy5nZXQoc2xvdCk7XG4gICAgICAgIGlmICghY3VyckNoYW5uZWxzKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzLnNldChzbG90LCBjaGFubmVscyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzLnNldChzbG90LCBjdXJyQ2hhbm5lbHMuY29uY2F0KGNoYW5uZWxzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGFubmVscy52YWx1ZXMoKSkucmVkdWNlKChzdW0sIGFycmF5KSA9PiBzdW0gKyBhcnJheS5sZW5ndGgsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGNoYW5uZWxzIGZvciB3aGljaCB0aGUgc3Vic2NyaWJlciBncm91cCBpcyByZXNwb25zaWJsZSBieSBvcHRpb25hbGx5IHVuc3Vic2NyaWJpbmdcbiAgICAgKiBAcGFyYW0gY2hhbm5lbHNcbiAgICAgKi9cbiAgICByZW1vdmVDaGFubmVscyhjaGFubmVscykge1xuICAgICAgICBjb25zdCBzbG90ID0gY2FsY3VsYXRlU2xvdChjaGFubmVsc1swXSk7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhbGwgY2hhbm5lbHMgYmVsb25nIHRvIHRoZSBzYW1lIHNsb3QgYW5kIG90aGVyd2lzZSByZWplY3QgdGhlIG9wZXJhdGlvblxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGlmIChjYWxjdWxhdGVTbG90KGMpICE9PSBzbG90KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNsb3RDaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZ2V0KHNsb3QpO1xuICAgICAgICBpZiAoc2xvdENoYW5uZWxzKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkQ2hhbm5lbHMgPSBzbG90Q2hhbm5lbHMuZmlsdGVyKChjKSA9PiAhY2hhbm5lbHMuaW5jbHVkZXMoYykpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5zZXQoc2xvdCwgdXBkYXRlZENoYW5uZWxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoYW5uZWxzLnZhbHVlcygpKS5yZWR1Y2UoKHN1bSwgYXJyYXkpID0+IHN1bSArIGFycmF5Lmxlbmd0aCwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgYWxsIHN1YnNjcmliZXJzIGFuZCBjbGVhciBzb21lIG9mIHRoZSBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIHN1YnNjcmliZXIgaW5zdGFuY2VzIGFuZCBwZW5kaW5nIG9wZXJhdGlvbnMuXG4gICAgICAgIC8vIENoYW5uZWxzIGFyZSBwcmVzZXJ2ZWQgZm9yIHJlc3Vic2NyaXB0aW9uIG9uIHJlY29ubmVjdC5cbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycy5jbGVhcigpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJUb1Nsb3RzSW5kZXguY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYWxsIG5vdCB5ZXQgc3RhcnRlZCBzdWJzY3JpYmVyc1xuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICBjb25zdCBzdGFydFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKCFzLmlzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlcy5wdXNoKHNcbiAgICAgICAgICAgICAgICAgICAgLnN0YXJ0KClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmliZXJDb25uZWN0U3VjY2VlZGVkKHMuZ2V0Tm9kZUtleSgpKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmliZXJDb25uZWN0RmFpbGVkKGVyciwgcy5nZXROb2RlS2V5KCkpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoc3RhcnRQcm9taXNlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgc3Vic2NyaWJlciBncm91cCBieSBkaXNjb25uZWN0aW5nIGFsbCBzdWJzY3JpYmVycyB0aGF0IGFyZSBubyBsb25nZXIgbmVlZGVkIGFuZCBjb25uZWN0aW5nIG5ldyBvbmVzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc2V0KGNsdXN0ZXJTbG90cywgY2x1c3Rlck5vZGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVzZXR0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNldCA9IHsgc2xvdHM6IGNsdXN0ZXJTbG90cywgbm9kZXM6IGNsdXN0ZXJOb2RlcyB9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZXNldHRpbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaGFzVG9wb2xvZ3lDaGFuZ2VkID0gdGhpcy5fcmVmcmVzaFNsb3RzKGNsdXN0ZXJTbG90cyk7XG4gICAgICAgICAgICBjb25zdCBoYXNGYWlsZWRTdWJzY3JpYmVycyA9IHRoaXMuaGFzVW5oZWFsdGh5U3Vic2NyaWJlcnMoKTtcbiAgICAgICAgICAgIGlmICghaGFzVG9wb2xvZ3lDaGFuZ2VkICYmICFoYXNGYWlsZWRTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiTm8gdG9wb2xvZ3kgY2hhbmdlIGRldGVjdGVkIG9yIGZhaWxlZCBzdWJzY3JpYmVycy4gU2tpcHBpbmcgcmVzZXQuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciBlYWNoIG9mIHRoZSBzaGFyZGVkIHN1YnNjcmliZXJzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtub2RlS2V5LCBzaGFyZGVkU3Vic2NyaWJlcl0gb2YgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN1YnNjcmliZXIgaXMgc3RpbGwgcmVzcG9uc2libGUgZm9yIGEgc2xvdCByYW5nZSBhbmQgaXMgcnVubmluZyB0aGVuIGtlZXAgaXRcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJUb1Nsb3RzSW5kZXguaGFzKG5vZGVLZXkpICYmXG4gICAgICAgICAgICAgICAgICAgIHNoYXJkZWRTdWJzY3JpYmVyLmlzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiU2tpcHBpbmcgZGVsZXRpbmcgc3Vic2NyaWJlciBmb3IgJXNcIiwgbm9kZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlJlbW92aW5nIHN1YnNjcmliZXIgZm9yICVzXCIsIG5vZGVLZXkpO1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBzdG9wIHRoZSBzdWJzY3JpYmVyIGFuZCByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICBzaGFyZGVkU3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMuZGVsZXRlKG5vZGVLZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlckdyb3VwRW1pdHRlci5lbWl0KFwiLXN1YnNjcmliZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGFydFByb21pc2VzID0gW107XG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBub2RlIGluIHNsb3RzIGNhY2hlXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtub2RlS2V5LCBfXSBvZiB0aGlzLnN1YnNjcmliZXJUb1Nsb3RzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdWJzY3JpYmVyIGZvciB0aGlzIG5vZGUgdGhlbiBrZWVwIGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzLmhhcyhub2RlS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIlNraXBwaW5nIGNyZWF0aW5nIG5ldyBzdWJzY3JpYmVyIGZvciAlc1wiLCBub2RlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlYnVnKFwiQ3JlYXRpbmcgbmV3IHN1YnNjcmliZXIgZm9yICVzXCIsIG5vZGVLZXkpO1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgc3Vic2NyaWJlclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZGlzID0gY2x1c3Rlck5vZGVzLmZpbmQoKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuZ2V0Tm9kZUtleSkobm9kZS5vcHRpb25zKSA9PT0gbm9kZUtleTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiRmFpbGVkIHRvIGZpbmQgbm9kZSBmb3Iga2V5ICVzXCIsIG5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gbmV3IFNoYXJkZWRTdWJzY3JpYmVyXzEuZGVmYXVsdCh0aGlzLnN1YnNjcmliZXJHcm91cEVtaXR0ZXIsIHJlZGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzLnNldChub2RlS2V5LCBzdWIpO1xuICAgICAgICAgICAgICAgIHN0YXJ0UHJvbWlzZXMucHVzaChzdWJcbiAgICAgICAgICAgICAgICAgICAgLnN0YXJ0KClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmliZXJDb25uZWN0U3VjY2VlZGVkKG5vZGVLZXkpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdWJzY3JpYmVyQ29ubmVjdEZhaWxlZChlcnJvciwgbm9kZUtleSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlckdyb3VwRW1pdHRlci5lbWl0KFwiK3N1YnNjcmliZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJdCdzIHZpdGFsIHRvIGF3YWl0IHRoZSBzdGFydCBwcm9taXNlcyBiZWZvcmUgcmVzdWJzY3JpYmluZ1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG1pZ2h0IHRyeSB0byByZXN1YnNjcmliZSB0byBhIHN1YnNjcmliZXIgdGhhdCBpcyBub3QgeWV0IGNvbm5lY3RlZFxuICAgICAgICAgICAgLy8gVGhpcyBjYW4gY2F1c2UgYSByYWNlIGNvbmRpdGlvblxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc3RhcnRQcm9taXNlcyk7XG4gICAgICAgICAgICB0aGlzLl9yZXN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyR3JvdXBFbWl0dGVyLmVtaXQoXCJzdWJzY3JpYmVyc1JlYWR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5pc1Jlc2V0dGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzbG90cywgbm9kZXMgfSA9IHRoaXMucGVuZGluZ1Jlc2V0O1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Jlc2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlc2V0KHNsb3RzLCBub2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBzdWJzY3JpYmVyLXJlbGF0ZWQgc2xvdCByYW5nZXNcbiAgICAgKlxuICAgICAqIFJldHVybnMgZmFsc2UgaWYgbm8gcmVmcmVzaCB3YXMgbmVlZGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0U2xvdHNcbiAgICAgKi9cbiAgICBfcmVmcmVzaFNsb3RzKHRhcmdldFNsb3RzKSB7XG4gICAgICAgIC8vSWYgdGhlcmUgd2FzIGFuIGFjdHVhbCBjaGFuZ2UsIHRoZW4gcmVhc3NpZ24gdGhlIHNsb3QgcmFuZ2VzXG4gICAgICAgIGlmICh0aGlzLl9zbG90c0FyZUVxdWFsKHRhcmdldFNsb3RzKSkge1xuICAgICAgICAgICAgZGVidWcoXCJOb3RoaW5nIHRvIHJlZnJlc2ggYmVjYXVzZSB0aGUgbmV3IGNsdXN0ZXIgbWFwIGlzIGVxdWFsIHRvIHRoZSBwcmV2aW91cyBvbmUuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwiUmVmcmVzaGluZyB0aGUgc2xvdHMgb2YgdGhlIHN1YnNjcmliZXIgZ3JvdXAuXCIpO1xuICAgICAgICAvL1JlYnVpbGQgdGhlIHNsb3RzIGluZGV4XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlclRvU2xvdHNJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgc2xvdCA9IDA7IHNsb3QgPCB0YXJnZXRTbG90cy5sZW5ndGg7IHNsb3QrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRhcmdldFNsb3RzW3Nsb3RdWzBdO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmliZXJUb1Nsb3RzSW5kZXguaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyVG9TbG90c0luZGV4LnNldChub2RlLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJUb1Nsb3RzSW5kZXguZ2V0KG5vZGUpLnB1c2goTnVtYmVyKHNsb3QpKTtcbiAgICAgICAgfVxuICAgICAgICAvL1VwZGF0ZSB0aGUgY2FjaGVkIHNsb3RzIG1hcFxuICAgICAgICB0aGlzLmNsdXN0ZXJTbG90cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGFyZ2V0U2xvdHMpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3Vic2NyaWJlcyB0byB0aGUgcHJldmlvdXMgY2hhbm5lbHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAodGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzLmZvckVhY2goKHMsIG5vZGVLZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyU2xvdHMgPSB0aGlzLnN1YnNjcmliZXJUb1Nsb3RzSW5kZXguZ2V0KG5vZGVLZXkpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyU2xvdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9SZXN1YnNjcmliZSBvbiB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJTbG90cy5mb3JFYWNoKChzcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9NaWdodCByZXR1cm4gbnVsbCBpZiBiZWluZyBkaXNjb25uZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZGlzID0gcy5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmdldChzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbHMgJiYgY2hhbm5lbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWRpcy5zdGF0dXMgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVkaXMuc3RhdHVzID09PSBcInJlYWR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMuc3N1YnNjcmliZSguLi5jaGFubmVscykuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIGVtaXQgYW4gZXJyb3IgZXZlbnQgaGVyZT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiRmFpbGVkIHRvIHNzdWJzY3JpYmUgb24gbm9kZSAlczogJXNcIiwgbm9kZUtleSwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcy5vbmNlKFwicmVhZHlcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMuc3N1YnNjcmliZSguLi5jaGFubmVscykuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSBlbWl0IGFuIGVycm9yIGV2ZW50IGhlcmU/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJGYWlsZWQgdG8gc3N1YnNjcmliZSBvbiBub2RlICVzOiAlc1wiLCBub2RlS2V5LCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVlcCBlcXVhbGl0eSBvZiB0aGUgY2x1c3RlciBzbG90cyBvYmplY3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zbG90c0FyZUVxdWFsKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsdXN0ZXJTbG90cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5jbHVzdGVyU2xvdHMpID09PSBKU09OLnN0cmluZ2lmeShvdGhlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGFueSBzdWJzY3JpYmVycyBhcmUgaW4gYW4gdW5oZWFsdGh5IHN0YXRlLlxuICAgICAqXG4gICAgICogQSBzdWJzY3JpYmVyIGlzIGNvbnNpZGVyZWQgdW5oZWFsdGh5IGlmOlxuICAgICAqIC0gSXQgZXhpc3RzIGJ1dCBpcyBub3Qgc3RhcnRlZCAoZmFpbGVkL2Rpc2Nvbm5lY3RlZClcbiAgICAgKiAtIEl0J3MgbWlzc2luZyBlbnRpcmVseSBmb3IgYSBub2RlIHRoYXQgc2hvdWxkIGhhdmUgb25lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGFueSBzdWJzY3JpYmVycyBuZWVkIHRvIGJlIHJlY3JlYXRlZFxuICAgICAqL1xuICAgIGhhc1VuaGVhbHRoeVN1YnNjcmliZXJzKCkge1xuICAgICAgICBjb25zdCBoYXNGYWlsZWRTdWJzY3JpYmVycyA9IEFycmF5LmZyb20odGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMudmFsdWVzKCkpLnNvbWUoKHN1YikgPT4gIXN1Yi5pc1N0YXJ0ZWQoKSk7XG4gICAgICAgIGNvbnN0IGhhc01pc3NpbmdTdWJzY3JpYmVycyA9IEFycmF5LmZyb20odGhpcy5zdWJzY3JpYmVyVG9TbG90c0luZGV4LmtleXMoKSkuc29tZSgobm9kZUtleSkgPT4gIXRoaXMuc2hhcmRlZFN1YnNjcmliZXJzLmhhcyhub2RlS2V5KSk7XG4gICAgICAgIHJldHVybiBoYXNGYWlsZWRTdWJzY3JpYmVycyB8fCBoYXNNaXNzaW5nU3Vic2NyaWJlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2x1c3RlclN1YnNjcmliZXJHcm91cDtcbi8vIFJldHJ5IHN0cmF0ZWd5XG5DbHVzdGVyU3Vic2NyaWJlckdyb3VwLk1BWF9SRVRSWV9BVFRFTVBUUyA9IDEwO1xuQ2x1c3RlclN1YnNjcmliZXJHcm91cC5NQVhfQkFDS09GRl9NUyA9IDIwMDA7XG5DbHVzdGVyU3Vic2NyaWJlckdyb3VwLkJBU0VfQkFDS09GRl9NUyA9IDEwMDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInV0aWxzXzEiLCJyZXF1aXJlIiwidXRpbF8xIiwiY2FsY3VsYXRlU2xvdCIsIlNoYXJkZWRTdWJzY3JpYmVyXzEiLCJkZWJ1ZyIsIkRlYnVnIiwiQ2x1c3RlclN1YnNjcmliZXJHcm91cCIsImNvbnN0cnVjdG9yIiwic3Vic2NyaWJlckdyb3VwRW1pdHRlciIsInNoYXJkZWRTdWJzY3JpYmVycyIsIk1hcCIsImNsdXN0ZXJTbG90cyIsInN1YnNjcmliZXJUb1Nsb3RzSW5kZXgiLCJjaGFubmVscyIsImZhaWxlZEF0dGVtcHRzQnlOb2RlIiwiaXNSZXNldHRpbmciLCJwZW5kaW5nUmVzZXQiLCJoYW5kbGVTdWJzY3JpYmVyQ29ubmVjdEZhaWxlZCIsImVycm9yIiwibm9kZUtleSIsImN1cnJlbnRBdHRlbXB0cyIsImdldCIsImZhaWxlZEF0dGVtcHRzIiwic2V0IiwiYXR0ZW1wdHMiLCJNYXRoIiwibWluIiwiTUFYX1JFVFJZX0FUVEVNUFRTIiwiYmFja29mZiIsIkJBU0VfQkFDS09GRl9NUyIsIk1BWF9CQUNLT0ZGX01TIiwiaml0dGVyIiwiZmxvb3IiLCJyYW5kb20iLCJkZWxheSIsIm1heCIsImVtaXQiLCJoYW5kbGVTdWJzY3JpYmVyQ29ubmVjdFN1Y2NlZWRlZCIsImRlbGV0ZSIsImdldFJlc3BvbnNpYmxlU3Vic2NyaWJlciIsInNsb3QiLCJhZGRDaGFubmVscyIsImMiLCJjdXJyQ2hhbm5lbHMiLCJjb25jYXQiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJzdW0iLCJhcnJheSIsImxlbmd0aCIsInJlbW92ZUNoYW5uZWxzIiwic2xvdENoYW5uZWxzIiwidXBkYXRlZENoYW5uZWxzIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJzdG9wIiwicyIsImNsZWFyIiwic3RhcnQiLCJzdGFydFByb21pc2VzIiwiaXNTdGFydGVkIiwicHVzaCIsInRoZW4iLCJnZXROb2RlS2V5IiwiY2F0Y2giLCJlcnIiLCJQcm9taXNlIiwiYWxsIiwicmVzZXQiLCJjbHVzdGVyTm9kZXMiLCJzbG90cyIsIm5vZGVzIiwiaGFzVG9wb2xvZ3lDaGFuZ2VkIiwiX3JlZnJlc2hTbG90cyIsImhhc0ZhaWxlZFN1YnNjcmliZXJzIiwiaGFzVW5oZWFsdGh5U3Vic2NyaWJlcnMiLCJzaGFyZGVkU3Vic2NyaWJlciIsImhhcyIsIl8iLCJyZWRpcyIsImZpbmQiLCJub2RlIiwib3B0aW9ucyIsInN1YiIsImRlZmF1bHQiLCJfcmVzdWJzY3JpYmUiLCJ0YXJnZXRTbG90cyIsIl9zbG90c0FyZUVxdWFsIiwiTnVtYmVyIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiZm9yRWFjaCIsInN1YnNjcmliZXJTbG90cyIsInNzIiwiZ2V0SW5zdGFuY2UiLCJzdGF0dXMiLCJzc3Vic2NyaWJlIiwib25jZSIsIm90aGVyIiwidW5kZWZpbmVkIiwic29tZSIsImhhc01pc3NpbmdTdWJzY3JpYmVycyIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/ConnectionPool.js":
/*!**************************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/ConnectionPool.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/ioredis/built/cluster/util.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst debug = (0, utils_1.Debug)(\"cluster:connectionPool\");\nclass ConnectionPool extends events_1.EventEmitter {\n    constructor(redisOptions){\n        super();\n        this.redisOptions = redisOptions;\n        // master + slave = all\n        this.nodes = {\n            all: {},\n            master: {},\n            slave: {}\n        };\n        this.specifiedOptions = {};\n    }\n    getNodes(role = \"all\") {\n        const nodes = this.nodes[role];\n        return Object.keys(nodes).map((key)=>nodes[key]);\n    }\n    getInstanceByKey(key) {\n        return this.nodes.all[key];\n    }\n    getSampleInstance(role) {\n        const keys = Object.keys(this.nodes[role]);\n        const sampleKey = (0, utils_1.sample)(keys);\n        return this.nodes[role][sampleKey];\n    }\n    /**\n     * Add a master node to the pool\n     * @param node\n     */ addMasterNode(node) {\n        const key = (0, util_1.getNodeKey)(node.options);\n        const redis = this.createRedisFromOptions(node, node.options.readOnly);\n        //Master nodes aren't read-only\n        if (!node.options.readOnly) {\n            this.nodes.all[key] = redis;\n            this.nodes.master[key] = redis;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Creates a Redis connection instance from the node options\n     * @param node\n     * @param readOnly\n     */ createRedisFromOptions(node, readOnly) {\n        const redis = new Redis_1.default((0, utils_1.defaults)({\n            // Never try to reconnect when a node is lose,\n            // instead, waiting for a `MOVED` error and\n            // fetch the slots again.\n            retryStrategy: null,\n            // Offline queue should be enabled so that\n            // we don't need to wait for the `ready` event\n            // before sending commands to the node.\n            enableOfflineQueue: true,\n            readOnly: readOnly\n        }, node, this.redisOptions, {\n            lazyConnect: true\n        }));\n        return redis;\n    }\n    /**\n     * Find or create a connection to the node\n     */ findOrCreate(node, readOnly = false) {\n        const key = (0, util_1.getNodeKey)(node);\n        readOnly = Boolean(readOnly);\n        if (this.specifiedOptions[key]) {\n            Object.assign(node, this.specifiedOptions[key]);\n        } else {\n            this.specifiedOptions[key] = node;\n        }\n        let redis;\n        if (this.nodes.all[key]) {\n            redis = this.nodes.all[key];\n            if (redis.options.readOnly !== readOnly) {\n                redis.options.readOnly = readOnly;\n                debug(\"Change role of %s to %s\", key, readOnly ? \"slave\" : \"master\");\n                redis[readOnly ? \"readonly\" : \"readwrite\"]().catch(utils_1.noop);\n                if (readOnly) {\n                    delete this.nodes.master[key];\n                    this.nodes.slave[key] = redis;\n                } else {\n                    delete this.nodes.slave[key];\n                    this.nodes.master[key] = redis;\n                }\n            }\n        } else {\n            debug(\"Connecting to %s as %s\", key, readOnly ? \"slave\" : \"master\");\n            redis = this.createRedisFromOptions(node, readOnly);\n            this.nodes.all[key] = redis;\n            this.nodes[readOnly ? \"slave\" : \"master\"][key] = redis;\n            redis.once(\"end\", ()=>{\n                this.removeNode(key);\n                this.emit(\"-node\", redis, key);\n                if (!Object.keys(this.nodes.all).length) {\n                    this.emit(\"drain\");\n                }\n            });\n            this.emit(\"+node\", redis, key);\n            redis.on(\"error\", function(error) {\n                this.emit(\"nodeError\", error, key);\n            });\n        }\n        return redis;\n    }\n    /**\n     * Reset the pool with a set of nodes.\n     * The old node will be removed.\n     */ reset(nodes) {\n        debug(\"Reset with %O\", nodes);\n        const newNodes = {};\n        nodes.forEach((node)=>{\n            const key = (0, util_1.getNodeKey)(node);\n            // Don't override the existing (master) node\n            // when the current one is slave.\n            if (!(node.readOnly && newNodes[key])) {\n                newNodes[key] = node;\n            }\n        });\n        Object.keys(this.nodes.all).forEach((key)=>{\n            if (!newNodes[key]) {\n                debug(\"Disconnect %s because the node does not hold any slot\", key);\n                this.nodes.all[key].disconnect();\n                this.removeNode(key);\n            }\n        });\n        Object.keys(newNodes).forEach((key)=>{\n            const node = newNodes[key];\n            this.findOrCreate(node, node.readOnly);\n        });\n    }\n    /**\n     * Remove a node from the pool.\n     */ removeNode(key) {\n        const { nodes } = this;\n        if (nodes.all[key]) {\n            debug(\"Remove %s from the pool\", key);\n            delete nodes.all[key];\n        }\n        delete nodes.master[key];\n        delete nodes.slave[key];\n    }\n}\nexports[\"default\"] = ConnectionPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0Nvbm5lY3Rpb25Qb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLG1FQUFVO0FBQ2xDLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDLGtFQUFRO0FBQy9CLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLDZEQUFVO0FBQ2xDLE1BQU1JLFFBQVEsQ0FBQyxHQUFHSCxRQUFRSSxLQUFLLEVBQUU7QUFDakMsTUFBTUMsdUJBQXVCUCxTQUFTUSxZQUFZO0lBQzlDQyxZQUFZQyxZQUFZLENBQUU7UUFDdEIsS0FBSztRQUNMLElBQUksQ0FBQ0EsWUFBWSxHQUFHQTtRQUNwQix1QkFBdUI7UUFDdkIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDVEMsS0FBSyxDQUFDO1lBQ05DLFFBQVEsQ0FBQztZQUNUQyxPQUFPLENBQUM7UUFDWjtRQUNBLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsQ0FBQztJQUM3QjtJQUNBQyxTQUFTQyxPQUFPLEtBQUssRUFBRTtRQUNuQixNQUFNTixRQUFRLElBQUksQ0FBQ0EsS0FBSyxDQUFDTSxLQUFLO1FBQzlCLE9BQU9yQixPQUFPc0IsSUFBSSxDQUFDUCxPQUFPUSxHQUFHLENBQUMsQ0FBQ0MsTUFBUVQsS0FBSyxDQUFDUyxJQUFJO0lBQ3JEO0lBQ0FDLGlCQUFpQkQsR0FBRyxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDVCxLQUFLLENBQUNDLEdBQUcsQ0FBQ1EsSUFBSTtJQUM5QjtJQUNBRSxrQkFBa0JMLElBQUksRUFBRTtRQUNwQixNQUFNQyxPQUFPdEIsT0FBT3NCLElBQUksQ0FBQyxJQUFJLENBQUNQLEtBQUssQ0FBQ00sS0FBSztRQUN6QyxNQUFNTSxZQUFZLENBQUMsR0FBR3JCLFFB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dUIsUUFBUSxDQUFDN0IsSUFBSTtZQUMxQixJQUFJLENBQUNpQixZQUFZLENBQUNYLE1BQU1BLEtBQUtLLFFBQVE7UUFDekM7SUFDSjtJQUNBOztLQUVDLEdBQ0RZLFdBQVd2QixHQUFHLEVBQUU7UUFDWixNQUFNLEVBQUVULEtBQUssRUFBRSxHQUFHLElBQUk7UUFDdEIsSUFBSUEsTUFBTUMsR0FBRyxDQUFDUSxJQUFJLEVBQUU7WUFDaEJmLE1BQU0sMkJBQTJCZTtZQUNqQyxPQUFPVCxNQUFNQyxHQUFHLENBQUNRLElBQUk7UUFDekI7UUFDQSxPQUFPVCxNQUFNRSxNQUFNLENBQUNPLElBQUk7UUFDeEIsT0FBT1QsTUFBTUcsS0FBSyxDQUFDTSxJQUFJO0lBQzNCO0FBQ0o7QUFDQXRCLGtCQUFlLEdBQUdTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvZHVjdC1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0Nvbm5lY3Rpb25Qb29sLmpzPzBkM2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IFJlZGlzXzEgPSByZXF1aXJlKFwiLi4vUmVkaXNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCB1dGlsc18xLkRlYnVnKShcImNsdXN0ZXI6Y29ubmVjdGlvblBvb2xcIik7XG5jbGFzcyBDb25uZWN0aW9uUG9vbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IocmVkaXNPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVkaXNPcHRpb25zID0gcmVkaXNPcHRpb25zO1xuICAgICAgICAvLyBtYXN0ZXIgKyBzbGF2ZSA9IGFsbFxuICAgICAgICB0aGlzLm5vZGVzID0ge1xuICAgICAgICAgICAgYWxsOiB7fSxcbiAgICAgICAgICAgIG1hc3Rlcjoge30sXG4gICAgICAgICAgICBzbGF2ZToge30sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3BlY2lmaWVkT3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBnZXROb2Rlcyhyb2xlID0gXCJhbGxcIikge1xuICAgICAgICBjb25zdCBub2RlcyA9IHRoaXMubm9kZXNbcm9sZV07XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhub2RlcykubWFwKChrZXkpID0+IG5vZGVzW2tleV0pO1xuICAgIH1cbiAgICBnZXRJbnN0YW5jZUJ5S2V5KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5hbGxba2V5XTtcbiAgICB9XG4gICAgZ2V0U2FtcGxlSW5zdGFuY2Uocm9sZSkge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5ub2Rlc1tyb2xlXSk7XG4gICAgICAgIGNvbnN0IHNhbXBsZUtleSA9ICgwLCB1dGlsc18xLnNhbXBsZSkoa2V5cyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzW3JvbGVdW3NhbXBsZUtleV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG1hc3RlciBub2RlIHRvIHRoZSBwb29sXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKi9cbiAgICBhZGRNYXN0ZXJOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIHV0aWxfMS5nZXROb2RlS2V5KShub2RlLm9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZWRpcyA9IHRoaXMuY3JlYXRlUmVkaXNGcm9tT3B0aW9ucyhub2RlLCBub2RlLm9wdGlvbnMucmVhZE9ubHkpO1xuICAgICAgICAvL01hc3RlciBub2RlcyBhcmVuJ3QgcmVhZC1vbmx5XG4gICAgICAgIGlmICghbm9kZS5vcHRpb25zLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmFsbFtrZXldID0gcmVkaXM7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLm1hc3RlcltrZXldID0gcmVkaXM7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBSZWRpcyBjb25uZWN0aW9uIGluc3RhbmNlIGZyb20gdGhlIG5vZGUgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICogQHBhcmFtIHJlYWRPbmx5XG4gICAgICovXG4gICAgY3JlYXRlUmVkaXNGcm9tT3B0aW9ucyhub2RlLCByZWFkT25seSkge1xuICAgICAgICBjb25zdCByZWRpcyA9IG5ldyBSZWRpc18xLmRlZmF1bHQoKDAsIHV0aWxzXzEuZGVmYXVsdHMpKHtcbiAgICAgICAgICAgIC8vIE5ldmVyIHRyeSB0byByZWNvbm5lY3Qgd2hlbiBhIG5vZGUgaXMgbG9zZSxcbiAgICAgICAgICAgIC8vIGluc3RlYWQsIHdhaXRpbmcgZm9yIGEgYE1PVkVEYCBlcnJvciBhbmRcbiAgICAgICAgICAgIC8vIGZldGNoIHRoZSBzbG90cyBhZ2Fpbi5cbiAgICAgICAgICAgIHJldHJ5U3RyYXRlZ3k6IG51bGwsXG4gICAgICAgICAgICAvLyBPZmZsaW5lIHF1ZXVlIHNob3VsZCBiZSBlbmFibGVkIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gd2FpdCBmb3IgdGhlIGByZWFkeWAgZXZlbnRcbiAgICAgICAgICAgIC8vIGJlZm9yZSBzZW5kaW5nIGNvbW1hbmRzIHRvIHRoZSBub2RlLlxuICAgICAgICAgICAgZW5hYmxlT2ZmbGluZVF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgcmVhZE9ubHk6IHJlYWRPbmx5LFxuICAgICAgICB9LCBub2RlLCB0aGlzLnJlZGlzT3B0aW9ucywgeyBsYXp5Q29ubmVjdDogdHJ1ZSB9KSk7XG4gICAgICAgIHJldHVybiByZWRpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBvciBjcmVhdGUgYSBjb25uZWN0aW9uIHRvIHRoZSBub2RlXG4gICAgICovXG4gICAgZmluZE9yQ3JlYXRlKG5vZGUsIHJlYWRPbmx5ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIHV0aWxfMS5nZXROb2RlS2V5KShub2RlKTtcbiAgICAgICAgcmVhZE9ubHkgPSBCb29sZWFuKHJlYWRPbmx5KTtcbiAgICAgICAgaWYgKHRoaXMuc3BlY2lmaWVkT3B0aW9uc1trZXldKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5vZGUsIHRoaXMuc3BlY2lmaWVkT3B0aW9uc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3BlY2lmaWVkT3B0aW9uc1trZXldID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVkaXM7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzLmFsbFtrZXldKSB7XG4gICAgICAgICAgICByZWRpcyA9IHRoaXMubm9kZXMuYWxsW2tleV07XG4gICAgICAgICAgICBpZiAocmVkaXMub3B0aW9ucy5yZWFkT25seSAhPT0gcmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZWRpcy5vcHRpb25zLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJDaGFuZ2Ugcm9sZSBvZiAlcyB0byAlc1wiLCBrZXksIHJlYWRPbmx5ID8gXCJzbGF2ZVwiIDogXCJtYXN0ZXJcIik7XG4gICAgICAgICAgICAgICAgcmVkaXNbcmVhZE9ubHkgPyBcInJlYWRvbmx5XCIgOiBcInJlYWR3cml0ZVwiXSgpLmNhdGNoKHV0aWxzXzEubm9vcCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVzLm1hc3RlcltrZXldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnNsYXZlW2tleV0gPSByZWRpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVzLnNsYXZlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMubWFzdGVyW2tleV0gPSByZWRpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIkNvbm5lY3RpbmcgdG8gJXMgYXMgJXNcIiwga2V5LCByZWFkT25seSA/IFwic2xhdmVcIiA6IFwibWFzdGVyXCIpO1xuICAgICAgICAgICAgcmVkaXMgPSB0aGlzLmNyZWF0ZVJlZGlzRnJvbU9wdGlvbnMobm9kZSwgcmVhZE9ubHkpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5hbGxba2V5XSA9IHJlZGlzO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1tyZWFkT25seSA/IFwic2xhdmVcIiA6IFwibWFzdGVyXCJdW2tleV0gPSByZWRpcztcbiAgICAgICAgICAgIHJlZGlzLm9uY2UoXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShrZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIi1ub2RlXCIsIHJlZGlzLCBrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5ub2Rlcy5hbGwpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIitub2RlXCIsIHJlZGlzLCBrZXkpO1xuICAgICAgICAgICAgcmVkaXMub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJub2RlRXJyb3JcIiwgZXJyb3IsIGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVkaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBwb29sIHdpdGggYSBzZXQgb2Ygbm9kZXMuXG4gICAgICogVGhlIG9sZCBub2RlIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICByZXNldChub2Rlcykge1xuICAgICAgICBkZWJ1ZyhcIlJlc2V0IHdpdGggJU9cIiwgbm9kZXMpO1xuICAgICAgICBjb25zdCBuZXdOb2RlcyA9IHt9O1xuICAgICAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSAoMCwgdXRpbF8xLmdldE5vZGVLZXkpKG5vZGUpO1xuICAgICAgICAgICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgdGhlIGV4aXN0aW5nIChtYXN0ZXIpIG5vZGVcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIGN1cnJlbnQgb25lIGlzIHNsYXZlLlxuICAgICAgICAgICAgaWYgKCEobm9kZS5yZWFkT25seSAmJiBuZXdOb2Rlc1trZXldKSkge1xuICAgICAgICAgICAgICAgIG5ld05vZGVzW2tleV0gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5ub2Rlcy5hbGwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFuZXdOb2Rlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJEaXNjb25uZWN0ICVzIGJlY2F1c2UgdGhlIG5vZGUgZG9lcyBub3QgaG9sZCBhbnkgc2xvdFwiLCBrZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuYWxsW2tleV0uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmtleXMobmV3Tm9kZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ld05vZGVzW2tleV07XG4gICAgICAgICAgICB0aGlzLmZpbmRPckNyZWF0ZShub2RlLCBub2RlLnJlYWRPbmx5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIG5vZGUgZnJvbSB0aGUgcG9vbC5cbiAgICAgKi9cbiAgICByZW1vdmVOb2RlKGtleSkge1xuICAgICAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBpZiAobm9kZXMuYWxsW2tleV0pIHtcbiAgICAgICAgICAgIGRlYnVnKFwiUmVtb3ZlICVzIGZyb20gdGhlIHBvb2xcIiwga2V5KTtcbiAgICAgICAgICAgIGRlbGV0ZSBub2Rlcy5hbGxba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgbm9kZXMubWFzdGVyW2tleV07XG4gICAgICAgIGRlbGV0ZSBub2Rlcy5zbGF2ZVtrZXldO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25Qb29sO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZXZlbnRzXzEiLCJyZXF1aXJlIiwidXRpbHNfMSIsInV0aWxfMSIsIlJlZGlzXzEiLCJkZWJ1ZyIsIkRlYnVnIiwiQ29ubmVjdGlvblBvb2wiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsInJlZGlzT3B0aW9ucyIsIm5vZGVzIiwiYWxsIiwibWFzdGVyIiwic2xhdmUiLCJzcGVjaWZpZWRPcHRpb25zIiwiZ2V0Tm9kZXMiLCJyb2xlIiwia2V5cyIsIm1hcCIsImtleSIsImdldEluc3RhbmNlQnlLZXkiLCJnZXRTYW1wbGVJbnN0YW5jZSIsInNhbXBsZUtleSIsInNhbXBsZSIsImFkZE1hc3Rlck5vZGUiLCJub2RlIiwiZ2V0Tm9kZUtleSIsIm9wdGlvbnMiLCJyZWRpcyIsImNyZWF0ZVJlZGlzRnJvbU9wdGlvbnMiLCJyZWFkT25seSIsImRlZmF1bHQiLCJkZWZhdWx0cyIsInJldHJ5U3RyYXRlZ3kiLCJlbmFibGVPZmZsaW5lUXVldWUiLCJsYXp5Q29ubmVjdCIsImZpbmRPckNyZWF0ZSIsIkJvb2xlYW4iLCJhc3NpZ24iLCJjYXRjaCIsIm5vb3AiLCJvbmNlIiwicmVtb3ZlTm9kZSIsImVtaXQiLCJsZW5ndGgiLCJvbiIsImVycm9yIiwicmVzZXQiLCJuZXdOb2RlcyIsImZvckVhY2giLCJkaXNjb25uZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/ConnectionPool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/DelayQueue.js":
/*!**********************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/DelayQueue.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst Deque = __webpack_require__(/*! denque */ \"(rsc)/./node_modules/denque/index.js\");\nconst debug = (0, utils_1.Debug)(\"delayqueue\");\n/**\n * Queue that runs items after specified duration\n */ class DelayQueue {\n    constructor(){\n        this.queues = {};\n        this.timeouts = {};\n    }\n    /**\n     * Add a new item to the queue\n     *\n     * @param bucket bucket name\n     * @param item function that will run later\n     * @param options\n     */ push(bucket, item, options) {\n        const callback = options.callback || process.nextTick;\n        if (!this.queues[bucket]) {\n            this.queues[bucket] = new Deque();\n        }\n        const queue = this.queues[bucket];\n        queue.push(item);\n        if (!this.timeouts[bucket]) {\n            this.timeouts[bucket] = setTimeout(()=>{\n                callback(()=>{\n                    this.timeouts[bucket] = null;\n                    this.execute(bucket);\n                });\n            }, options.timeout);\n        }\n    }\n    execute(bucket) {\n        const queue = this.queues[bucket];\n        if (!queue) {\n            return;\n        }\n        const { length } = queue;\n        if (!length) {\n            return;\n        }\n        debug(\"send %d commands in %s queue\", length, bucket);\n        this.queues[bucket] = null;\n        while(queue.length > 0){\n            queue.shift()();\n        }\n    }\n}\nexports[\"default\"] = DelayQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0RlbGF5UXVldWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsbUVBQVU7QUFDbEMsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUMsb0RBQVE7QUFDOUIsTUFBTUUsUUFBUSxDQUFDLEdBQUdILFFBQVFJLEtBQUssRUFBRTtBQUNqQzs7Q0FFQyxHQUNELE1BQU1DO0lBQ0ZDLGFBQWM7UUFDVixJQUFJLENBQUNDLE1BQU0sR0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDQyxRQUFRLEdBQUcsQ0FBQztJQUNyQjtJQUNBOzs7Ozs7S0FNQyxHQUNEQyxLQUFLQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsT0FBTyxFQUFFO1FBQ3hCLE1BQU1DLFdBQVdELFFBQVFDLFFBQVEsSUFBSUMsUUFBUUMsUUFBUTtRQUNyRCxJQUFJLENBQUMsSUFBSSxDQUFDUixNQUFNLENBQUNHLE9BQU8sRUFBRTtZQUN0QixJQUFJLENBQUNILE1BQU0sQ0FBQ0csT0FBTyxHQUFHLElBQUlSO1FBQzlCO1FBQ0EsTUFBTWMsUUFBUSxJQUFJLENBQUNULE1BQU0sQ0FBQ0csT0FBTztRQUNqQ00sTUFBTVAsSUFBSSxDQUFDRTtRQUNYLElBQUksQ0FBQyxJQUFJLENBQUNILFFBQVEsQ0FBQ0UsT0FBTyxFQUFFO1lBQ3hCLElBQUksQ0FBQ0YsUUFBUSxDQUFDRSxPQUFPLEdBQUdPLFdBQVc7Z0JBQy9CSixTQUFTO29CQUNMLElBQUksQ0FBQ0wsUUFBUSxDQUFDRSxPQUFPLEdBQUc7b0JBQ3hCLElBQUksQ0FBQ1EsT0FBTyxDQUFDUjtnQkFDakI7WUFDSixHQUFHRSxRQUFRTyxPQUFPO1FBQ3RCO0lBQ0o7SUFDQUQsUUFBUVIsTUFBTSxFQUFFO1FBQ1osTUFBTU0sUUFBUSxJQUFJLENBQUNULE1BQU0sQ0FBQ0csT0FBTztRQUNqQyxJQUFJLENBQUNNLE9BQU87WUFDUjtRQUNKO1FBQ0EsTUFBTSxFQUFFSSxNQUFNLEVBQUUsR0FBR0o7UUFDbkIsSUFBSSxDQUFDSSxRQUFRO1lBQ1Q7UUFDSjtRQUNBakIsTUFBTSxnQ0FBZ0NpQixRQUFRVjtRQUM5QyxJQUFJLENBQUNILE1BQU0sQ0FBQ0csT0FBTyxHQUFHO1FBQ3RCLE1BQU9NLE1BQU1JLE1BQU0sR0FBRyxFQUFHO1lBQ3JCSixNQUFNSyxLQUFLO1FBQ2Y7SUFDSjtBQUNKO0FBQ0F2QixrQkFBZSxHQUFHTyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci9EZWxheVF1ZXVlLmpzP2M1ZWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgRGVxdWUgPSByZXF1aXJlKFwiZGVucXVlXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJkZWxheXF1ZXVlXCIpO1xuLyoqXG4gKiBRdWV1ZSB0aGF0IHJ1bnMgaXRlbXMgYWZ0ZXIgc3BlY2lmaWVkIGR1cmF0aW9uXG4gKi9cbmNsYXNzIERlbGF5UXVldWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnF1ZXVlcyA9IHt9O1xuICAgICAgICB0aGlzLnRpbWVvdXRzID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBpdGVtIHRvIHRoZSBxdWV1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1Y2tldCBidWNrZXQgbmFtZVxuICAgICAqIEBwYXJhbSBpdGVtIGZ1bmN0aW9uIHRoYXQgd2lsbCBydW4gbGF0ZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIHB1c2goYnVja2V0LCBpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBwcm9jZXNzLm5leHRUaWNrO1xuICAgICAgICBpZiAoIXRoaXMucXVldWVzW2J1Y2tldF0pIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVzW2J1Y2tldF0gPSBuZXcgRGVxdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzW2J1Y2tldF07XG4gICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgIGlmICghdGhpcy50aW1lb3V0c1tidWNrZXRdKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRzW2J1Y2tldF0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZW91dHNbYnVja2V0XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0ZShidWNrZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGVjdXRlKGJ1Y2tldCkge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzW2J1Y2tldF07XG4gICAgICAgIGlmICghcXVldWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gcXVldWU7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJzZW5kICVkIGNvbW1hbmRzIGluICVzIHF1ZXVlXCIsIGxlbmd0aCwgYnVja2V0KTtcbiAgICAgICAgdGhpcy5xdWV1ZXNbYnVja2V0XSA9IG51bGw7XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBxdWV1ZS5zaGlmdCgpKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEZWxheVF1ZXVlO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXRpbHNfMSIsInJlcXVpcmUiLCJEZXF1ZSIsImRlYnVnIiwiRGVidWciLCJEZWxheVF1ZXVlIiwiY29uc3RydWN0b3IiLCJxdWV1ZXMiLCJ0aW1lb3V0cyIsInB1c2giLCJidWNrZXQiLCJpdGVtIiwib3B0aW9ucyIsImNhbGxiYWNrIiwicHJvY2VzcyIsIm5leHRUaWNrIiwicXVldWUiLCJzZXRUaW1lb3V0IiwiZXhlY3V0ZSIsInRpbWVvdXQiLCJsZW5ndGgiLCJzaGlmdCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/DelayQueue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/ShardedSubscriber.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/ShardedSubscriber.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/ioredis/built/cluster/util.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst debug = (0, utils_1.Debug)(\"cluster:subscriberGroup:shardedSubscriber\");\nclass ShardedSubscriber {\n    constructor(emitter, options){\n        this.emitter = emitter;\n        this.started = false;\n        this.instance = null;\n        // Store listener references for cleanup\n        this.messageListeners = new Map();\n        this.onEnd = ()=>{\n            this.started = false;\n            this.emitter.emit(\"-node\", this.instance, this.nodeKey);\n        };\n        this.onError = (error)=>{\n            this.emitter.emit(\"nodeError\", error, this.nodeKey);\n        };\n        this.onMoved = ()=>{\n            this.emitter.emit(\"moved\");\n        };\n        this.instance = new Redis_1.default({\n            port: options.port,\n            host: options.host,\n            username: options.username,\n            password: options.password,\n            enableReadyCheck: false,\n            offlineQueue: true,\n            connectionName: (0, util_1.getConnectionName)(\"ssubscriber\", options.connectionName),\n            lazyConnect: true,\n            tls: options.tls,\n            /**\n             * Disable auto reconnection for subscribers.\n             * The ClusterSubscriberGroup will handle the reconnection.\n             */ retryStrategy: null\n        });\n        this.nodeKey = (0, util_1.getNodeKey)(options);\n        // Register listeners\n        this.instance.once(\"end\", this.onEnd);\n        this.instance.on(\"error\", this.onError);\n        this.instance.on(\"moved\", this.onMoved);\n        for (const event of [\n            \"smessage\",\n            \"smessageBuffer\"\n        ]){\n            const listener = (...args)=>{\n                this.emitter.emit(event, ...args);\n            };\n            this.messageListeners.set(event, listener);\n            this.instance.on(event, listener);\n        }\n    }\n    async start() {\n        if (this.started) {\n            debug(\"already started %s\", this.nodeKey);\n            return;\n        }\n        try {\n            await this.instance.connect();\n            debug(\"started %s\", this.nodeKey);\n            this.started = true;\n        } catch (err) {\n            debug(\"failed to start %s: %s\", this.nodeKey, err);\n            this.started = false;\n            throw err; // Re-throw so caller knows it failed\n        }\n    }\n    stop() {\n        this.started = false;\n        if (this.instance) {\n            this.instance.disconnect();\n            this.instance.removeAllListeners();\n            this.messageListeners.clear();\n            this.instance = null;\n        }\n        debug(\"stopped %s\", this.nodeKey);\n    }\n    isStarted() {\n        return this.started;\n    }\n    getInstance() {\n        return this.instance;\n    }\n    getNodeKey() {\n        return this.nodeKey;\n    }\n}\nexports[\"default\"] = ShardedSubscriber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL1NoYXJkZWRTdWJzY3JpYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLGtFQUFRO0FBQy9CLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLG1FQUFVO0FBQ2xDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLDZEQUFVO0FBQ2xDLE1BQU1HLFFBQVEsQ0FBQyxHQUFHRixRQUFRRyxLQUFLLEVBQUU7QUFDakMsTUFBTUM7SUFDRkMsWUFBWUMsT0FBTyxFQUFFQyxPQUFPLENBQUU7UUFDMUIsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDRSxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQix3Q0FBd0M7UUFDeEMsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxJQUFJQztRQUM1QixJQUFJLENBQUNDLEtBQUssR0FBRztZQUNULElBQUksQ0FBQ0osT0FBTyxHQUFHO1lBQ2YsSUFBSSxDQUFDRixPQUFPLENBQUNPLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQ0osUUFBUSxFQUFFLElBQUksQ0FBQ0ssT0FBTztRQUMxRDtRQUNBLElBQUksQ0FBQ0MsT0FBTyxHQUFHLENBQUNDO1lBQ1osSUFBSSxDQUFDVixPQUFPLENBQUNPLElBQUksQ0FBQyxhQUFhRyxPQUFPLElBQUksQ0FBQ0YsT0FBTztRQUN0RDtRQUNBLElBQUksQ0FBQ0csT0FBTyxHQUFHO1lBQ1gsSUFBSSxDQUFDWCxPQUFPLENBQUNPLElBQUksQ0FBQztRQUN0QjtRQUNBLElBQUksQ0FBQ0osUUFBUSxHQUFHLElBQUlSLFFBQVFpQixPQUFPLENBQUM7WUFDaENDLE1BQU1aLFFBQVFZLElBQUk7WUFDbEJDLE1BQU1iLFFBQVFhLElBQUk7WUFDbEJDLFVBQVVkLFFBQVFjLFFBQVE7WUFDMUJDLFVBQVVmLFFBQVFlLFFBQVE7WUFDMUJDLGtCQUFrQjtZQUNsQkMsY0FBYztZQUNkQyxnQkFBZ0IsQ0FBQyxHQUFHM0IsT0FBTzRCLGlCQUFpQixFQUFFLGVBQWVuQixRQUFRa0IsY0FBYztZQUNuRkUsYUFBYTtZQUNiQyxLQUFLckIsUUFBUXFCLEdBQUc7WUFDaEI7OzthQUdDLEdBQ0RDLGVBQWU7UUFDbkI7UUFDQSxJQUFJLENBQUNmLE9BQU8sR0FBRyxDQUFDLEdBQUdoQixPQUFPZ0MsVUFBVSxFQUFFdkI7UUFDdEMscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0UsUUFBUSxDQUFDc0IsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDbkIsS0FBSztRQUNwQyxJQUFJLENBQUNILFFBQVEsQ0FBQ3VCLEVBQUUsQ0FBQyxTQUFTLElBQUksQ0FBQ2pCLE9BQU87UUFDdEMsSUFBSSxDQUFDTixRQUFRLENBQUN1QixFQUFFLENBQUMsU0FBUyxJQUFJLENBQUNmLE9BQU87UUFDdEMsS0FBSyxNQUFNZ0IsU0FBUztZQUFDO1lBQVk7U0FBaUIsQ0FBRTtZQUNoRCxNQUFNQyxXQUFXLENBQUMsR0FBR0M7Z0JBQ2pCLElBQUksQ0FBQzdCLE9BQU8sQ0FBQ08sSUFBSSxDQUFDb0IsVUFBVUU7WUFDaEM7WUFDQSxJQUFJLENBQUN6QixnQkFBZ0IsQ0FBQzBCLEdBQUcsQ0FBQ0gsT0FBT0M7WUFDakMsSUFBSSxDQUFDekIsUUFBUSxDQUFDdUIsRUFBRSxDQUFDQyxPQUFPQztRQUM1QjtJQUNKO0lBQ0EsTUFBTUcsUUFBUTtRQUNWLElBQUksSUFBSSxDQUFDN0IsT0FBTyxFQUFFO1lBQ2ROLE1BQU0sc0JBQXNCLElBQUksQ0FBQ1ksT0FBTztZQUN4QztRQUNKO1FBQ0EsSUFBSTtZQUNBLE1BQU0sSUFBSSxDQUFDTCxRQUFRLENBQUM2QixPQUFPO1lBQzNCcEMsTUFBTSxjQUFjLElBQUksQ0FBQ1ksT0FBTztZQUNoQyxJQUFJLENBQUNOLE9BQU8sR0FBRztRQUNuQixFQUNBLE9BQU8rQixLQUFLO1lBQ1JyQyxNQUFNLDBCQUEwQixJQUFJLENBQUNZLE9BQU8sRUFBRXlCO1lBQzlDLElBQUksQ0FBQy9CLE9BQU8sR0FBRztZQUNmLE1BQU0rQixLQUFLLHFDQUFxQztRQUNwRDtJQUNKO0lBQ0FDLE9BQU87UUFDSCxJQUFJLENBQUNoQyxPQUFPLEdBQUc7UUFDZixJQUFJLElBQUksQ0FBQ0MsUUFBUSxFQUFFO1lBQ2YsSUFBSSxDQUFDQSxRQUFRLENBQUNnQyxVQUFVO1lBQ3hCLElBQUksQ0FBQ2hDLFFBQVEsQ0FBQ2lDLGtCQUFrQjtZQUNoQyxJQUFJLENBQUNoQyxnQkFBZ0IsQ0FBQ2lDLEtBQUs7WUFDM0IsSUFBSSxDQUFDbEMsUUFBUSxHQUFHO1FBQ3BCO1FBQ0FQLE1BQU0sY0FBYyxJQUFJLENBQUNZLE9BQU87SUFDcEM7SUFDQThCLFlBQVk7UUFDUixPQUFPLElBQUksQ0FBQ3BDLE9BQU87SUFDdkI7SUFDQXFDLGNBQWM7UUFDVixPQUFPLElBQUksQ0FBQ3BDLFFBQVE7SUFDeEI7SUFDQXFCLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ2hCLE9BQU87SUFDdkI7QUFDSjtBQUNBbEIsa0JBQWUsR0FBR1EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0LWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2NsdXN0ZXIvU2hhcmRlZFN1YnNjcmliZXIuanM/NWIzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgUmVkaXNfMSA9IHJlcXVpcmUoXCIuLi9SZWRpc1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiY2x1c3RlcjpzdWJzY3JpYmVyR3JvdXA6c2hhcmRlZFN1YnNjcmliZXJcIik7XG5jbGFzcyBTaGFyZGVkU3Vic2NyaWJlciB7XG4gICAgY29uc3RydWN0b3IoZW1pdHRlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIC8vIFN0b3JlIGxpc3RlbmVyIHJlZmVyZW5jZXMgZm9yIGNsZWFudXBcbiAgICAgICAgdGhpcy5tZXNzYWdlTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9uRW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChcIi1ub2RlXCIsIHRoaXMuaW5zdGFuY2UsIHRoaXMubm9kZUtleSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25FcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJub2RlRXJyb3JcIiwgZXJyb3IsIHRoaXMubm9kZUtleSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Nb3ZlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KFwibW92ZWRcIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgUmVkaXNfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHBvcnQ6IG9wdGlvbnMucG9ydCxcbiAgICAgICAgICAgIGhvc3Q6IG9wdGlvbnMuaG9zdCxcbiAgICAgICAgICAgIHVzZXJuYW1lOiBvcHRpb25zLnVzZXJuYW1lLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IG9wdGlvbnMucGFzc3dvcmQsXG4gICAgICAgICAgICBlbmFibGVSZWFkeUNoZWNrOiBmYWxzZSxcbiAgICAgICAgICAgIG9mZmxpbmVRdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25OYW1lOiAoMCwgdXRpbF8xLmdldENvbm5lY3Rpb25OYW1lKShcInNzdWJzY3JpYmVyXCIsIG9wdGlvbnMuY29ubmVjdGlvbk5hbWUpLFxuICAgICAgICAgICAgbGF6eUNvbm5lY3Q6IHRydWUsXG4gICAgICAgICAgICB0bHM6IG9wdGlvbnMudGxzLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaXNhYmxlIGF1dG8gcmVjb25uZWN0aW9uIGZvciBzdWJzY3JpYmVycy5cbiAgICAgICAgICAgICAqIFRoZSBDbHVzdGVyU3Vic2NyaWJlckdyb3VwIHdpbGwgaGFuZGxlIHRoZSByZWNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHJ5U3RyYXRlZ3k6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5vZGVLZXkgPSAoMCwgdXRpbF8xLmdldE5vZGVLZXkpKG9wdGlvbnMpO1xuICAgICAgICAvLyBSZWdpc3RlciBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5vbmNlKFwiZW5kXCIsIHRoaXMub25FbmQpO1xuICAgICAgICB0aGlzLmluc3RhbmNlLm9uKFwiZXJyb3JcIiwgdGhpcy5vbkVycm9yKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5vbihcIm1vdmVkXCIsIHRoaXMub25Nb3ZlZCk7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgW1wic21lc3NhZ2VcIiwgXCJzbWVzc2FnZUJ1ZmZlclwiXSkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VMaXN0ZW5lcnMuc2V0KGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiYWxyZWFkeSBzdGFydGVkICVzXCIsIHRoaXMubm9kZUtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5zdGFuY2UuY29ubmVjdCgpO1xuICAgICAgICAgICAgZGVidWcoXCJzdGFydGVkICVzXCIsIHRoaXMubm9kZUtleSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZmFpbGVkIHRvIHN0YXJ0ICVzOiAlc1wiLCB0aGlzLm5vZGVLZXksIGVycik7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93IGVycjsgLy8gUmUtdGhyb3cgc28gY2FsbGVyIGtub3dzIGl0IGZhaWxlZFxuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlTGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInN0b3BwZWQgJXNcIiwgdGhpcy5ub2RlS2V5KTtcbiAgICB9XG4gICAgaXNTdGFydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydGVkO1xuICAgIH1cbiAgICBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgfVxuICAgIGdldE5vZGVLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVLZXk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2hhcmRlZFN1YnNjcmliZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1dGlsXzEiLCJyZXF1aXJlIiwidXRpbHNfMSIsIlJlZGlzXzEiLCJkZWJ1ZyIsIkRlYnVnIiwiU2hhcmRlZFN1YnNjcmliZXIiLCJjb25zdHJ1Y3RvciIsImVtaXR0ZXIiLCJvcHRpb25zIiwic3RhcnRlZCIsImluc3RhbmNlIiwibWVzc2FnZUxpc3RlbmVycyIsIk1hcCIsIm9uRW5kIiwiZW1pdCIsIm5vZGVLZXkiLCJvbkVycm9yIiwiZXJyb3IiLCJvbk1vdmVkIiwiZGVmYXVsdCIsInBvcnQiLCJob3N0IiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImVuYWJsZVJlYWR5Q2hlY2siLCJvZmZsaW5lUXVldWUiLCJjb25uZWN0aW9uTmFtZSIsImdldENvbm5lY3Rpb25OYW1lIiwibGF6eUNvbm5lY3QiLCJ0bHMiLCJyZXRyeVN0cmF0ZWd5IiwiZ2V0Tm9kZUtleSIsIm9uY2UiLCJvbiIsImV2ZW50IiwibGlzdGVuZXIiLCJhcmdzIiwic2V0Iiwic3RhcnQiLCJjb25uZWN0IiwiZXJyIiwic3RvcCIsImRpc2Nvbm5lY3QiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJjbGVhciIsImlzU3RhcnRlZCIsImdldEluc3RhbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/ShardedSubscriber.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst Command_1 = __webpack_require__(/*! ../Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst ClusterAllFailedError_1 = __webpack_require__(/*! ../errors/ClusterAllFailedError */ \"(rsc)/./node_modules/ioredis/built/errors/ClusterAllFailedError.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst ScanStream_1 = __webpack_require__(/*! ../ScanStream */ \"(rsc)/./node_modules/ioredis/built/ScanStream.js\");\nconst transaction_1 = __webpack_require__(/*! ../transaction */ \"(rsc)/./node_modules/ioredis/built/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst applyMixin_1 = __webpack_require__(/*! ../utils/applyMixin */ \"(rsc)/./node_modules/ioredis/built/utils/applyMixin.js\");\nconst Commander_1 = __webpack_require__(/*! ../utils/Commander */ \"(rsc)/./node_modules/ioredis/built/utils/Commander.js\");\nconst ClusterOptions_1 = __webpack_require__(/*! ./ClusterOptions */ \"(rsc)/./node_modules/ioredis/built/cluster/ClusterOptions.js\");\nconst ClusterSubscriber_1 = __webpack_require__(/*! ./ClusterSubscriber */ \"(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriber.js\");\nconst ConnectionPool_1 = __webpack_require__(/*! ./ConnectionPool */ \"(rsc)/./node_modules/ioredis/built/cluster/ConnectionPool.js\");\nconst DelayQueue_1 = __webpack_require__(/*! ./DelayQueue */ \"(rsc)/./node_modules/ioredis/built/cluster/DelayQueue.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/ioredis/built/cluster/util.js\");\nconst Deque = __webpack_require__(/*! denque */ \"(rsc)/./node_modules/denque/index.js\");\nconst ClusterSubscriberGroup_1 = __webpack_require__(/*! ./ClusterSubscriberGroup */ \"(rsc)/./node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js\");\nconst debug = (0, utils_1.Debug)(\"cluster\");\nconst REJECT_OVERWRITTEN_COMMANDS = new WeakSet();\n/**\n * Client for the official Redis Cluster\n */ class Cluster extends Commander_1.default {\n    /**\n     * Creates an instance of Cluster.\n     */ //TODO: Add an option that enables or disables sharded PubSub\n    constructor(startupNodes, options = {}){\n        super();\n        this.slots = [];\n        /**\n         * @ignore\n         */ this._groupsIds = {};\n        /**\n         * @ignore\n         */ this._groupsBySlot = Array(16384);\n        /**\n         * @ignore\n         */ this.isCluster = true;\n        this.retryAttempts = 0;\n        this.delayQueue = new DelayQueue_1.default();\n        this.offlineQueue = new Deque();\n        this.isRefreshing = false;\n        this._refreshSlotsCacheCallbacks = [];\n        this._autoPipelines = new Map();\n        this._runningAutoPipelines = new Set();\n        this._readyDelayedCallbacks = [];\n        /**\n         * Every time Cluster#connect() is called, this value will be\n         * auto-incrementing. The purpose of this value is used for\n         * discarding previous connect attampts when creating a new\n         * connection.\n         */ this.connectionEpoch = 0;\n        events_1.EventEmitter.call(this);\n        this.startupNodes = startupNodes;\n        this.options = (0, utils_1.defaults)({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);\n        if (this.options.shardedSubscribers) {\n            this.createShardedSubscriberGroup();\n        }\n        if (this.options.redisOptions && this.options.redisOptions.keyPrefix && !this.options.keyPrefix) {\n            this.options.keyPrefix = this.options.redisOptions.keyPrefix;\n        }\n        // validate options\n        if (typeof this.options.scaleReads !== \"function\" && [\n            \"all\",\n            \"master\",\n            \"slave\"\n        ].indexOf(this.options.scaleReads) === -1) {\n            throw new Error('Invalid option scaleReads \"' + this.options.scaleReads + '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n        }\n        this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);\n        this.connectionPool.on(\"-node\", (redis, key)=>{\n            this.emit(\"-node\", redis);\n        });\n        this.connectionPool.on(\"+node\", (redis)=>{\n            this.emit(\"+node\", redis);\n        });\n        this.connectionPool.on(\"drain\", ()=>{\n            this.setStatus(\"close\");\n        });\n        this.connectionPool.on(\"nodeError\", (error, key)=>{\n            this.emit(\"node error\", error, key);\n        });\n        this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);\n        if (this.options.scripts) {\n            Object.entries(this.options.scripts).forEach(([name, definition])=>{\n                this.defineCommand(name, definition);\n            });\n        }\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        } else {\n            this.connect().catch((err)=>{\n                debug(\"connecting failed: %s\", err);\n            });\n        }\n    }\n    /**\n     * Connect to a cluster\n     */ connect() {\n        return new Promise((resolve, reject)=>{\n            if (this.status === \"connecting\" || this.status === \"connect\" || this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            const epoch = ++this.connectionEpoch;\n            this.setStatus(\"connecting\");\n            this.resolveStartupNodeHostnames().then((nodes)=>{\n                if (this.connectionEpoch !== epoch) {\n                    debug(\"discard connecting after resolving startup nodes because epoch not match: %d != %d\", epoch, this.connectionEpoch);\n                    reject(new redis_errors_1.RedisError(\"Connection is discarded because a new connection is made\"));\n                    return;\n                }\n                if (this.status !== \"connecting\") {\n                    debug(\"discard connecting after resolving startup nodes because the status changed to %s\", this.status);\n                    reject(new redis_errors_1.RedisError(\"Connection is aborted\"));\n                    return;\n                }\n                this.connectionPool.reset(nodes);\n                if (this.options.shardedSubscribers) {\n                    this.shardedSubscribers.reset(this.slots, this.connectionPool.getNodes(\"all\")).catch((err)=>{\n                        // TODO should we emit an error event here?\n                        debug(\"Error while starting subscribers: %s\", err);\n                    });\n                }\n                const readyHandler = ()=>{\n                    this.setStatus(\"ready\");\n                    this.retryAttempts = 0;\n                    this.executeOfflineCommands();\n                    this.resetNodesRefreshInterval();\n                    resolve();\n                };\n                let closeListener = undefined;\n                const refreshListener = ()=>{\n                    this.invokeReadyDelayedCallbacks(undefined);\n                    this.removeListener(\"close\", closeListener);\n                    this.manuallyClosing = false;\n                    this.setStatus(\"connect\");\n                    if (this.options.enableReadyCheck) {\n                        this.readyCheck((err, fail)=>{\n                            if (err || fail) {\n                                debug(\"Ready check failed (%s). Reconnecting...\", err || fail);\n                                if (this.status === \"connect\") {\n                                    this.disconnect(true);\n                                }\n                            } else {\n                                readyHandler();\n                            }\n                        });\n                    } else {\n                        readyHandler();\n                    }\n                };\n                closeListener = ()=>{\n                    const error = new Error(\"None of startup nodes is available\");\n                    this.removeListener(\"refresh\", refreshListener);\n                    this.invokeReadyDelayedCallbacks(error);\n                    reject(error);\n                };\n                this.once(\"refresh\", refreshListener);\n                this.once(\"close\", closeListener);\n                this.once(\"close\", this.handleCloseEvent.bind(this));\n                this.refreshSlotsCache((err)=>{\n                    if (err && err.message === ClusterAllFailedError_1.default.defaultMessage) {\n                        Redis_1.default.prototype.silentEmit.call(this, \"error\", err);\n                        this.connectionPool.reset([]);\n                    }\n                });\n                this.subscriber.start();\n                if (this.options.shardedSubscribers) {\n                    this.shardedSubscribers.start().catch((err)=>{\n                        // TODO should we emit an error event here?\n                        debug(\"Error while starting subscribers: %s\", err);\n                    });\n                }\n            }).catch((err)=>{\n                this.setStatus(\"close\");\n                this.handleCloseEvent(err);\n                this.invokeReadyDelayedCallbacks(err);\n                reject(err);\n            });\n        });\n    }\n    /**\n     * Disconnect from every node in the cluster.\n     */ disconnect(reconnect = false) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout && !reconnect) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n            debug(\"Canceled reconnecting attempts\");\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (this.options.shardedSubscribers) {\n            this.shardedSubscribers.stop();\n        }\n        if (status === \"wait\") {\n            this.setStatus(\"close\");\n            this.handleCloseEvent();\n        } else {\n            this.connectionPool.reset([]);\n        }\n    }\n    /**\n     * Quit the cluster gracefully.\n     */ quit(callback) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        this.manuallyClosing = true;\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (this.options.shardedSubscribers) {\n            this.shardedSubscribers.stop();\n        }\n        if (status === \"wait\") {\n            const ret = (0, standard_as_callback_1.default)(Promise.resolve(\"OK\"), callback);\n            // use setImmediate to make sure \"close\" event\n            // being emitted after quit() is returned\n            setImmediate((function() {\n                this.setStatus(\"close\");\n                this.handleCloseEvent();\n            }).bind(this));\n            return ret;\n        }\n        return (0, standard_as_callback_1.default)(Promise.all(this.nodes().map((node)=>node.quit().catch((err)=>{\n                // Ignore the error caused by disconnecting since\n                // we're disconnecting...\n                if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {\n                    return \"OK\";\n                }\n                throw err;\n            }))).then(()=>\"OK\"), callback);\n    }\n    /**\n     * Create a new instance with the same startup nodes and options as the current one.\n     *\n     * @example\n     * ```js\n     * var cluster = new Redis.Cluster([{ host: \"127.0.0.1\", port: \"30001\" }]);\n     * var anotherCluster = cluster.duplicate();\n     * ```\n     */ duplicate(overrideStartupNodes = [], overrideOptions = {}) {\n        const startupNodes = overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);\n        const options = Object.assign({}, this.options, overrideOptions);\n        return new Cluster(startupNodes, options);\n    }\n    /**\n     * Get nodes with the specified role\n     */ nodes(role = \"all\") {\n        if (role !== \"all\" && role !== \"master\" && role !== \"slave\") {\n            throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n        }\n        return this.connectionPool.getNodes(role);\n    }\n    /**\n     * This is needed in order not to install a listener for each auto pipeline\n     *\n     * @ignore\n     */ delayUntilReady(callback) {\n        this._readyDelayedCallbacks.push(callback);\n    }\n    /**\n     * Get the number of commands queued in automatic pipelines.\n     *\n     * This is not available (and returns 0) until the cluster is connected and slots information have been received.\n     */ get autoPipelineQueueSize() {\n        let queued = 0;\n        for (const pipeline of this._autoPipelines.values()){\n            queued += pipeline.length;\n        }\n        return queued;\n    }\n    /**\n     * Refresh the slot cache\n     *\n     * @ignore\n     */ refreshSlotsCache(callback) {\n        if (callback) {\n            this._refreshSlotsCacheCallbacks.push(callback);\n        }\n        if (this.isRefreshing) {\n            return;\n        }\n        this.isRefreshing = true;\n        const _this = this;\n        const wrapper = (error)=>{\n            this.isRefreshing = false;\n            for (const callback of this._refreshSlotsCacheCallbacks){\n                callback(error);\n            }\n            this._refreshSlotsCacheCallbacks = [];\n        };\n        const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());\n        let lastNodeError = null;\n        function tryNode(index) {\n            if (index === nodes.length) {\n                const error = new ClusterAllFailedError_1.default(ClusterAllFailedError_1.default.defaultMessage, lastNodeError);\n                return wrapper(error);\n            }\n            const node = nodes[index];\n            const key = `${node.options.host}:${node.options.port}`;\n            debug(\"getting slot cache from %s\", key);\n            _this.getInfoFromNode(node, function(err) {\n                switch(_this.status){\n                    case \"close\":\n                    case \"end\":\n                        return wrapper(new Error(\"Cluster is disconnected.\"));\n                    case \"disconnecting\":\n                        return wrapper(new Error(\"Cluster is disconnecting.\"));\n                }\n                if (err) {\n                    _this.emit(\"node error\", err, key);\n                    lastNodeError = err;\n                    tryNode(index + 1);\n                } else {\n                    _this.emit(\"refresh\");\n                    wrapper();\n                }\n            });\n        }\n        tryNode(0);\n    }\n    /**\n     * @ignore\n     */ sendCommand(command, stream, node) {\n        if (this.status === \"wait\") {\n            this.connect().catch(utils_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        let to = this.options.scaleReads;\n        if (to !== \"master\") {\n            const isCommandReadOnly = command.isReadOnly || (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\");\n            if (!isCommandReadOnly) {\n                to = \"master\";\n            }\n        }\n        let targetSlot = node ? node.slot : command.getSlot();\n        const ttl = {};\n        const _this = this;\n        if (!node && !REJECT_OVERWRITTEN_COMMANDS.has(command)) {\n            REJECT_OVERWRITTEN_COMMANDS.add(command);\n            const reject = command.reject;\n            command.reject = function(err) {\n                const partialTry = tryConnection.bind(null, true);\n                _this.handleError(err, ttl, {\n                    moved: function(slot, key) {\n                        debug(\"command %s is moved to %s\", command.name, key);\n                        targetSlot = Number(slot);\n                        if (_this.slots[slot]) {\n                            _this.slots[slot][0] = key;\n                        } else {\n                            _this.slots[slot] = [\n                                key\n                            ];\n                        }\n                        _this._groupsBySlot[slot] = _this._groupsIds[_this.slots[slot].join(\";\")];\n                        _this.connectionPool.findOrCreate(_this.natMapper(key));\n                        tryConnection();\n                        debug(\"refreshing slot caches... (triggered by MOVED error)\");\n                        _this.refreshSlotsCache();\n                    },\n                    ask: function(slot, key) {\n                        debug(\"command %s is required to ask %s:%s\", command.name, key);\n                        const mapped = _this.natMapper(key);\n                        _this.connectionPool.findOrCreate(mapped);\n                        tryConnection(false, `${mapped.host}:${mapped.port}`);\n                    },\n                    tryagain: partialTry,\n                    clusterDown: partialTry,\n                    connectionClosed: partialTry,\n                    maxRedirections: function(redirectionError) {\n                        reject.call(command, redirectionError);\n                    },\n                    defaults: function() {\n                        reject.call(command, err);\n                    }\n                });\n            };\n        }\n        tryConnection();\n        function tryConnection(random, asking) {\n            if (_this.status === \"end\") {\n                command.reject(new redis_errors_1.AbortError(\"Cluster is ended.\"));\n                return;\n            }\n            let redis;\n            if (_this.status === \"ready\" || command.name === \"cluster\") {\n                if (node && node.redis) {\n                    redis = node.redis;\n                } else if (Command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", command.name) || Command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", command.name)) {\n                    if (_this.options.shardedSubscribers && (command.name == \"ssubscribe\" || command.name == \"sunsubscribe\")) {\n                        const sub = _this.shardedSubscribers.getResponsibleSubscriber(targetSlot);\n                        if (!sub) {\n                            command.reject(new redis_errors_1.AbortError(`No sharded subscriber for slot: ${targetSlot}`));\n                            return;\n                        }\n                        let status = -1;\n                        if (command.name == \"ssubscribe\") {\n                            status = _this.shardedSubscribers.addChannels(command.getKeys());\n                        }\n                        if (command.name == \"sunsubscribe\") {\n                            status = _this.shardedSubscribers.removeChannels(command.getKeys());\n                        }\n                        if (status !== -1) {\n                            redis = sub.getInstance();\n                        } else {\n                            command.reject(new redis_errors_1.AbortError(\"Possible CROSSSLOT error: All channels must hash to the same slot\"));\n                        }\n                    } else {\n                        redis = _this.subscriber.getInstance();\n                    }\n                    if (!redis) {\n                        command.reject(new redis_errors_1.AbortError(\"No subscriber for the cluster\"));\n                        return;\n                    }\n                } else {\n                    if (!random) {\n                        if (typeof targetSlot === \"number\" && _this.slots[targetSlot]) {\n                            const nodeKeys = _this.slots[targetSlot];\n                            if (typeof to === \"function\") {\n                                const nodes = nodeKeys.map(function(key) {\n                                    return _this.connectionPool.getInstanceByKey(key);\n                                });\n                                redis = to(nodes, command);\n                                if (Array.isArray(redis)) {\n                                    redis = (0, utils_1.sample)(redis);\n                                }\n                                if (!redis) {\n                                    redis = nodes[0];\n                                }\n                            } else {\n                                let key;\n                                if (to === \"all\") {\n                                    key = (0, utils_1.sample)(nodeKeys);\n                                } else if (to === \"slave\" && nodeKeys.length > 1) {\n                                    key = (0, utils_1.sample)(nodeKeys, 1);\n                                } else {\n                                    key = nodeKeys[0];\n                                }\n                                redis = _this.connectionPool.getInstanceByKey(key);\n                            }\n                        }\n                        if (asking) {\n                            redis = _this.connectionPool.getInstanceByKey(asking);\n                            redis.asking();\n                        }\n                    }\n                    if (!redis) {\n                        redis = (typeof to === \"function\" ? null : _this.connectionPool.getSampleInstance(to)) || _this.connectionPool.getSampleInstance(\"all\");\n                    }\n                }\n                if (node && !node.redis) {\n                    node.redis = redis;\n                }\n            }\n            if (redis) {\n                redis.sendCommand(command, stream);\n            } else if (_this.options.enableOfflineQueue) {\n                _this.offlineQueue.push({\n                    command: command,\n                    stream: stream,\n                    node: node\n                });\n            } else {\n                command.reject(new Error(\"Cluster isn't ready and enableOfflineQueue options is false\"));\n            }\n        }\n        return command.promise;\n    }\n    sscanStream(key, options) {\n        return this.createScanStream(\"sscan\", {\n            key,\n            options\n        });\n    }\n    sscanBufferStream(key, options) {\n        return this.createScanStream(\"sscanBuffer\", {\n            key,\n            options\n        });\n    }\n    hscanStream(key, options) {\n        return this.createScanStream(\"hscan\", {\n            key,\n            options\n        });\n    }\n    hscanBufferStream(key, options) {\n        return this.createScanStream(\"hscanBuffer\", {\n            key,\n            options\n        });\n    }\n    zscanStream(key, options) {\n        return this.createScanStream(\"zscan\", {\n            key,\n            options\n        });\n    }\n    zscanBufferStream(key, options) {\n        return this.createScanStream(\"zscanBuffer\", {\n            key,\n            options\n        });\n    }\n    /**\n     * @ignore\n     */ handleError(error, ttl, handlers) {\n        if (typeof ttl.value === \"undefined\") {\n            ttl.value = this.options.maxRedirections;\n        } else {\n            ttl.value -= 1;\n        }\n        if (ttl.value <= 0) {\n            handlers.maxRedirections(new Error(\"Too many Cluster redirections. Last error: \" + error));\n            return;\n        }\n        const errv = error.message.split(\" \");\n        if (errv[0] === \"MOVED\") {\n            const timeout = this.options.retryDelayOnMoved;\n            if (timeout && typeof timeout === \"number\") {\n                this.delayQueue.push(\"moved\", handlers.moved.bind(null, errv[1], errv[2]), {\n                    timeout\n                });\n            } else {\n                handlers.moved(errv[1], errv[2]);\n            }\n        } else if (errv[0] === \"ASK\") {\n            handlers.ask(errv[1], errv[2]);\n        } else if (errv[0] === \"TRYAGAIN\") {\n            this.delayQueue.push(\"tryagain\", handlers.tryagain, {\n                timeout: this.options.retryDelayOnTryAgain\n            });\n        } else if (errv[0] === \"CLUSTERDOWN\" && this.options.retryDelayOnClusterDown > 0) {\n            this.delayQueue.push(\"clusterdown\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnClusterDown,\n                callback: this.refreshSlotsCache.bind(this)\n            });\n        } else if (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0 && this.status === \"ready\") {\n            this.delayQueue.push(\"failover\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnFailover,\n                callback: this.refreshSlotsCache.bind(this)\n            });\n        } else {\n            handlers.defaults();\n        }\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    clearNodesRefreshInterval() {\n        if (this.slotsTimer) {\n            clearTimeout(this.slotsTimer);\n            this.slotsTimer = null;\n        }\n    }\n    resetNodesRefreshInterval() {\n        if (this.slotsTimer || !this.options.slotsRefreshInterval) {\n            return;\n        }\n        const nextRound = ()=>{\n            this.slotsTimer = setTimeout(()=>{\n                debug('refreshing slot caches... (triggered by \"slotsRefreshInterval\" option)');\n                this.refreshSlotsCache(()=>{\n                    nextRound();\n                });\n            }, this.options.slotsRefreshInterval);\n        };\n        nextRound();\n    }\n    /**\n     * Change cluster instance's status\n     */ setStatus(status) {\n        debug(\"status: %s -> %s\", this.status || \"[empty]\", status);\n        this.status = status;\n        process.nextTick(()=>{\n            this.emit(status);\n        });\n    }\n    /**\n     * Called when closed to check whether a reconnection should be made\n     */ handleCloseEvent(reason) {\n        var _a;\n        if (reason) {\n            debug(\"closed because %s\", reason);\n        }\n        let retryDelay;\n        if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === \"function\") {\n            retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);\n        }\n        if (typeof retryDelay === \"number\") {\n            this.setStatus(\"reconnecting\");\n            this.reconnectTimeout = setTimeout(()=>{\n                this.reconnectTimeout = null;\n                debug(\"Cluster is disconnected. Retrying after %dms\", retryDelay);\n                this.connect().catch(function(err) {\n                    debug(\"Got error %s when reconnecting. Ignoring...\", err);\n                });\n            }, retryDelay);\n        } else {\n            if (this.options.shardedSubscribers) {\n                (_a = this.subscriberGroupEmitter) === null || _a === void 0 ? void 0 : _a.removeAllListeners();\n            }\n            this.setStatus(\"end\");\n            this.flushQueue(new Error(\"None of startup nodes is available\"));\n        }\n    }\n    /**\n     * Flush offline queue with error.\n     */ flushQueue(error) {\n        let item;\n        while(item = this.offlineQueue.shift()){\n            item.command.reject(error);\n        }\n    }\n    executeOfflineCommands() {\n        if (this.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", this.offlineQueue.length);\n            const offlineQueue = this.offlineQueue;\n            this.resetOfflineQueue();\n            let item;\n            while(item = offlineQueue.shift()){\n                this.sendCommand(item.command, item.stream, item.node);\n            }\n        }\n    }\n    natMapper(nodeKey) {\n        const key = typeof nodeKey === \"string\" ? nodeKey : `${nodeKey.host}:${nodeKey.port}`;\n        let mapped = null;\n        if (this.options.natMap && typeof this.options.natMap === \"function\") {\n            mapped = this.options.natMap(key);\n        } else if (this.options.natMap && typeof this.options.natMap === \"object\") {\n            mapped = this.options.natMap[key];\n        }\n        if (mapped) {\n            debug(\"NAT mapping %s -> %O\", key, mapped);\n            return Object.assign({}, mapped);\n        }\n        return typeof nodeKey === \"string\" ? (0, util_1.nodeKeyToRedisOptions)(nodeKey) : nodeKey;\n    }\n    getInfoFromNode(redis, callback) {\n        if (!redis) {\n            return callback(new Error(\"Node is disconnected\"));\n        }\n        // Use a duplication of the connection to avoid\n        // timeouts when the connection is in the blocking\n        // mode (e.g. waiting for BLPOP).\n        const duplicatedConnection = redis.duplicate({\n            enableOfflineQueue: true,\n            enableReadyCheck: false,\n            retryStrategy: null,\n            connectionName: (0, util_1.getConnectionName)(\"refresher\", this.options.redisOptions && this.options.redisOptions.connectionName)\n        });\n        // Ignore error events since we will handle\n        // exceptions for the CLUSTER SLOTS command.\n        duplicatedConnection.on(\"error\", utils_1.noop);\n        duplicatedConnection.cluster(\"SLOTS\", (0, utils_1.timeout)((err, result)=>{\n            duplicatedConnection.disconnect();\n            if (err) {\n                debug(\"error encountered running CLUSTER.SLOTS: %s\", err);\n                return callback(err);\n            }\n            if (this.status === \"disconnecting\" || this.status === \"close\" || this.status === \"end\") {\n                debug(\"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s\", result.length, this.status);\n                callback();\n                return;\n            }\n            const nodes = [];\n            debug(\"cluster slots result count: %d\", result.length);\n            for(let i = 0; i < result.length; ++i){\n                const items = result[i];\n                const slotRangeStart = items[0];\n                const slotRangeEnd = items[1];\n                const keys = [];\n                for(let j = 2; j < items.length; j++){\n                    if (!items[j][0]) {\n                        continue;\n                    }\n                    const node = this.natMapper({\n                        host: items[j][0],\n                        port: items[j][1]\n                    });\n                    node.readOnly = j !== 2;\n                    nodes.push(node);\n                    keys.push(node.host + \":\" + node.port);\n                }\n                debug(\"cluster slots result [%d]: slots %d~%d served by %s\", i, slotRangeStart, slotRangeEnd, keys);\n                for(let slot = slotRangeStart; slot <= slotRangeEnd; slot++){\n                    this.slots[slot] = keys;\n                }\n            }\n            // Assign to each node keys a numeric value to make autopipeline comparison faster.\n            this._groupsIds = Object.create(null);\n            let j = 0;\n            for(let i = 0; i < 16384; i++){\n                const target = (this.slots[i] || []).join(\";\");\n                if (!target.length) {\n                    this._groupsBySlot[i] = undefined;\n                    continue;\n                }\n                if (!this._groupsIds[target]) {\n                    this._groupsIds[target] = ++j;\n                }\n                this._groupsBySlot[i] = this._groupsIds[target];\n            }\n            this.connectionPool.reset(nodes);\n            if (this.options.shardedSubscribers) {\n                this.shardedSubscribers.reset(this.slots, this.connectionPool.getNodes(\"all\")).catch((err)=>{\n                    // TODO should we emit an error event here?\n                    debug(\"Error while starting subscribers: %s\", err);\n                });\n            }\n            callback();\n        }, this.options.slotsRefreshTimeout));\n    }\n    invokeReadyDelayedCallbacks(err) {\n        for (const c of this._readyDelayedCallbacks){\n            process.nextTick(c, err);\n        }\n        this._readyDelayedCallbacks = [];\n    }\n    /**\n     * Check whether Cluster is able to process commands\n     */ readyCheck(callback) {\n        this.cluster(\"INFO\", (err, res)=>{\n            if (err) {\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback();\n            }\n            let state;\n            const lines = res.split(\"\\r\\n\");\n            for(let i = 0; i < lines.length; ++i){\n                const parts = lines[i].split(\":\");\n                if (parts[0] === \"cluster_state\") {\n                    state = parts[1];\n                    break;\n                }\n            }\n            if (state === \"fail\") {\n                debug(\"cluster state not ok (%s)\", state);\n                callback(null, state);\n            } else {\n                callback();\n            }\n        });\n    }\n    resolveSrv(hostname) {\n        return new Promise((resolve, reject)=>{\n            this.options.resolveSrv(hostname, (err, records)=>{\n                if (err) {\n                    return reject(err);\n                }\n                const self = this, groupedRecords = (0, util_1.groupSrvRecords)(records), sortedKeys = Object.keys(groupedRecords).sort((a, b)=>parseInt(a) - parseInt(b));\n                function tryFirstOne(err) {\n                    if (!sortedKeys.length) {\n                        return reject(err);\n                    }\n                    const key = sortedKeys[0], group = groupedRecords[key], record = (0, util_1.weightSrvRecords)(group);\n                    if (!group.records.length) {\n                        sortedKeys.shift();\n                    }\n                    self.dnsLookup(record.name).then((host)=>resolve({\n                            host,\n                            port: record.port\n                        }), tryFirstOne);\n                }\n                tryFirstOne();\n            });\n        });\n    }\n    dnsLookup(hostname) {\n        return new Promise((resolve, reject)=>{\n            this.options.dnsLookup(hostname, (err, address)=>{\n                if (err) {\n                    debug(\"failed to resolve hostname %s to IP: %s\", hostname, err.message);\n                    reject(err);\n                } else {\n                    debug(\"resolved hostname %s to IP %s\", hostname, address);\n                    resolve(address);\n                }\n            });\n        });\n    }\n    /**\n     * Normalize startup nodes, and resolving hostnames to IPs.\n     *\n     * This process happens every time when #connect() is called since\n     * #startupNodes and DNS records may chanage.\n     */ async resolveStartupNodeHostnames() {\n        if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n            throw new Error(\"`startupNodes` should contain at least one node.\");\n        }\n        const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);\n        const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);\n        if (hostnames.length === 0) {\n            return startupNodes;\n        }\n        const configs = await Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)));\n        const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);\n        return startupNodes.map((node)=>{\n            const config = hostnameToConfig.get(node.host);\n            if (!config) {\n                return node;\n            }\n            if (this.options.useSRVRecords) {\n                return Object.assign({}, node, config);\n            }\n            return Object.assign({}, node, {\n                host: config\n            });\n        });\n    }\n    createScanStream(command, { key, options = {} }) {\n        return new ScanStream_1.default({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command,\n            ...options\n        });\n    }\n    createShardedSubscriberGroup() {\n        this.subscriberGroupEmitter = new events_1.EventEmitter();\n        this.shardedSubscribers = new ClusterSubscriberGroup_1.default(this.subscriberGroupEmitter);\n        // Error handler used only for sharded-subscriber-triggered slots cache refreshes.\n        // Normal (non-subscriber) connections are created with lazyConnect: true and can\n        // become zombied. For sharded subscribers, a ClusterAllFailedError means\n        // we have lost all nodes from the subscriber perspective and must tear down.\n        const refreshSlotsCacheCallback = (err)=>{\n            // Disconnect only when refreshing the slots cache fails with ClusterAllFailedError\n            if (err instanceof ClusterAllFailedError_1.default) {\n                this.disconnect(true);\n            }\n        };\n        this.subscriberGroupEmitter.on(\"-node\", (redis, nodeKey)=>{\n            this.emit(\"-node\", redis, nodeKey);\n            this.refreshSlotsCache(refreshSlotsCacheCallback);\n        });\n        this.subscriberGroupEmitter.on(\"subscriberConnectFailed\", ({ delay, error })=>{\n            this.emit(\"error\", error);\n            setTimeout(()=>{\n                this.refreshSlotsCache(refreshSlotsCacheCallback);\n            }, delay);\n        });\n        this.subscriberGroupEmitter.on(\"moved\", ()=>{\n            this.refreshSlotsCache(refreshSlotsCacheCallback);\n        });\n        this.subscriberGroupEmitter.on(\"-subscriber\", ()=>{\n            this.emit(\"-subscriber\");\n        });\n        this.subscriberGroupEmitter.on(\"+subscriber\", ()=>{\n            this.emit(\"+subscriber\");\n        });\n        this.subscriberGroupEmitter.on(\"nodeError\", (error, nodeKey)=>{\n            this.emit(\"nodeError\", error, nodeKey);\n        });\n        this.subscriberGroupEmitter.on(\"subscribersReady\", ()=>{\n            this.emit(\"subscribersReady\");\n        });\n        for (const event of [\n            \"smessage\",\n            \"smessageBuffer\"\n        ]){\n            this.subscriberGroupEmitter.on(event, (arg1, arg2, arg3)=>{\n                this.emit(event, arg1, arg2, arg3);\n            });\n        }\n    }\n}\n(0, applyMixin_1.default)(Cluster, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Cluster.prototype);\nexports[\"default\"] = Cluster;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGFBQWFDLG1CQUFPQSxDQUFDLGdGQUFtQjtBQUM5QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNRSxpQkFBaUJGLG1CQUFPQSxDQUFDLGdFQUFjO0FBQzdDLE1BQU1HLHlCQUF5QkgsbUJBQU9BLENBQUMsc0ZBQXNCO0FBQzdELE1BQU1JLFlBQVlKLG1CQUFPQSxDQUFDLGlFQUFZO0FBQ3RDLE1BQU1LLDBCQUEwQkwsbUJBQU9BLENBQUMsMkdBQWlDO0FBQ3pFLE1BQU1NLFVBQVVOLG1CQUFPQSxDQUFDLDZEQUFVO0FBQ2xDLE1BQU1PLGVBQWVQLG1CQUFPQSxDQUFDLHVFQUFlO0FBQzVDLE1BQU1RLGdCQUFnQlIsbUJBQU9BLENBQUMseUVBQWdCO0FBQzlDLE1BQU1TLFVBQVVULG1CQUFPQSxDQUFDLG1FQUFVO0FBQ2xDLE1BQU1VLGVBQWVWLG1CQUFPQSxDQUFDLG1GQUFxQjtBQUNsRCxNQUFNVyxjQUFjWCxtQkFBT0EsQ0FBQyxpRkFBb0I7QUFDaEQsTUFBTVksbUJBQW1CWixtQkFBT0EsQ0FBQyxzRkFBa0I7QUFDbkQsTUFBTWEsc0JBQXNCYixtQkFBT0EsQ0FBQyw0RkFBcUI7QUFDekQsTUFBTWMsbUJBQW1CZCxtQkFBT0EsQ0FBQyxzRkFBa0I7QUFDbkQsTUFBTWUsZUFBZWYsbUJBQU9BLENBQUMsOEVBQWM7QUFDM0MsTUFBTWdCLFNBQVNoQixtQkFBT0EsQ0FBQyxrRUFBUTtBQUMvQixNQUFNaUIsUUFBUWpCLG1CQUFPQSxDQUFDLG9EQUFRO0FBQzlCLE1BQU1rQiwyQkFBMkJsQixtQkFBT0EsQ0FBQyxzR0FBMEI7QUFDbkUsTUFBTW1CLFFBQVEsQ0FBQyxHQUFHVixRQUFRVyxLQUFLLEVBQUU7QUFDakMsTUFB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LENBQUM7UUFDZDtRQUNBLEtBQUssTUFBTXFOLFNBQVM7WUFBQztZQUFZO1NBQWlCLENBQUU7WUFDaEQsSUFBSSxDQUFDMUQsc0JBQXNCLENBQUM5SixFQUFFLENBQUN3TixPQUFPLENBQUNDLE1BQU1DLE1BQU1DO2dCQUMvQyxJQUFJLENBQUN4TixJQUFJLENBQUNxTixPQUFPQyxNQUFNQyxNQUFNQztZQUNqQztRQUNKO0lBQ0o7QUFDSjtBQUNDLElBQUd6USxhQUFhYyxPQUFPLEVBQUVELFNBQVN0QixTQUFTMkMsWUFBWTtBQUN2RCxJQUFHcEMsY0FBYzRRLHFCQUFxQixFQUFFN1AsUUFBUWdGLFNBQVM7QUFDMUQxRyxrQkFBZSxHQUFHMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0LWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2NsdXN0ZXIvaW5kZXguanM/MDY0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiQGlvcmVkaXMvY29tbWFuZHNcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCByZWRpc19lcnJvcnNfMSA9IHJlcXVpcmUoXCJyZWRpcy1lcnJvcnNcIik7XG5jb25zdCBzdGFuZGFyZF9hc19jYWxsYmFja18xID0gcmVxdWlyZShcInN0YW5kYXJkLWFzLWNhbGxiYWNrXCIpO1xuY29uc3QgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4uL0NvbW1hbmRcIik7XG5jb25zdCBDbHVzdGVyQWxsRmFpbGVkRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnMvQ2x1c3RlckFsbEZhaWxlZEVycm9yXCIpO1xuY29uc3QgUmVkaXNfMSA9IHJlcXVpcmUoXCIuLi9SZWRpc1wiKTtcbmNvbnN0IFNjYW5TdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi9TY2FuU3RyZWFtXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBhcHBseU1peGluXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvYXBwbHlNaXhpblwiKTtcbmNvbnN0IENvbW1hbmRlcl8xID0gcmVxdWlyZShcIi4uL3V0aWxzL0NvbW1hbmRlclwiKTtcbmNvbnN0IENsdXN0ZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi9DbHVzdGVyT3B0aW9uc1wiKTtcbmNvbnN0IENsdXN0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKFwiLi9DbHVzdGVyU3Vic2NyaWJlclwiKTtcbmNvbnN0IENvbm5lY3Rpb25Qb29sXzEgPSByZXF1aXJlKFwiLi9Db25uZWN0aW9uUG9vbFwiKTtcbmNvbnN0IERlbGF5UXVldWVfMSA9IHJlcXVpcmUoXCIuL0RlbGF5UXVldWVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgRGVxdWUgPSByZXF1aXJlKFwiZGVucXVlXCIpO1xuY29uc3QgQ2x1c3RlclN1YnNjcmliZXJHcm91cF8xID0gcmVxdWlyZShcIi4vQ2x1c3RlclN1YnNjcmliZXJHcm91cFwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiY2x1c3RlclwiKTtcbmNvbnN0IFJFSkVDVF9PVkVSV1JJVFRFTl9DT01NQU5EUyA9IG5ldyBXZWFrU2V0KCk7XG4vKipcbiAqIENsaWVudCBmb3IgdGhlIG9mZmljaWFsIFJlZGlzIENsdXN0ZXJcbiAqL1xuY2xhc3MgQ2x1c3RlciBleHRlbmRzIENvbW1hbmRlcl8xLmRlZmF1bHQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ2x1c3Rlci5cbiAgICAgKi9cbiAgICAvL1RPRE86IEFkZCBhbiBvcHRpb24gdGhhdCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXJkZWQgUHViU3ViXG4gICAgY29uc3RydWN0b3Ioc3RhcnR1cE5vZGVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zbG90cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ3JvdXBzSWRzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ncm91cHNCeVNsb3QgPSBBcnJheSgxNjM4NCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQ2x1c3RlciA9IHRydWU7XG4gICAgICAgIHRoaXMucmV0cnlBdHRlbXB0cyA9IDA7XG4gICAgICAgIHRoaXMuZGVsYXlRdWV1ZSA9IG5ldyBEZWxheVF1ZXVlXzEuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzLm9mZmxpbmVRdWV1ZSA9IG5ldyBEZXF1ZSgpO1xuICAgICAgICB0aGlzLmlzUmVmcmVzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZWZyZXNoU2xvdHNDYWNoZUNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLl9hdXRvUGlwZWxpbmVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ydW5uaW5nQXV0b1BpcGVsaW5lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fcmVhZHlEZWxheWVkQ2FsbGJhY2tzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVyeSB0aW1lIENsdXN0ZXIjY29ubmVjdCgpIGlzIGNhbGxlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlXG4gICAgICAgICAqIGF1dG8taW5jcmVtZW50aW5nLiBUaGUgcHVycG9zZSBvZiB0aGlzIHZhbHVlIGlzIHVzZWQgZm9yXG4gICAgICAgICAqIGRpc2NhcmRpbmcgcHJldmlvdXMgY29ubmVjdCBhdHRhbXB0cyB3aGVuIGNyZWF0aW5nIGEgbmV3XG4gICAgICAgICAqIGNvbm5lY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25FcG9jaCA9IDA7XG4gICAgICAgIGV2ZW50c18xLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXJ0dXBOb2RlcyA9IHN0YXJ0dXBOb2RlcztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gKDAsIHV0aWxzXzEuZGVmYXVsdHMpKHt9LCBvcHRpb25zLCBDbHVzdGVyT3B0aW9uc18xLkRFRkFVTFRfQ0xVU1RFUl9PUFRJT05TLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXJkZWRTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVTaGFyZGVkU3Vic2NyaWJlckdyb3VwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWRpc09wdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yZWRpc09wdGlvbnMua2V5UHJlZml4ICYmXG4gICAgICAgICAgICAhdGhpcy5vcHRpb25zLmtleVByZWZpeCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmtleVByZWZpeCA9IHRoaXMub3B0aW9ucy5yZWRpc09wdGlvbnMua2V5UHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhbGlkYXRlIG9wdGlvbnNcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc2NhbGVSZWFkcyAhPT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICBbXCJhbGxcIiwgXCJtYXN0ZXJcIiwgXCJzbGF2ZVwiXS5pbmRleE9mKHRoaXMub3B0aW9ucy5zY2FsZVJlYWRzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcHRpb24gc2NhbGVSZWFkcyBcIicgK1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zY2FsZVJlYWRzICtcbiAgICAgICAgICAgICAgICAnXCIuIEV4cGVjdGVkIFwiYWxsXCIsIFwibWFzdGVyXCIsIFwic2xhdmVcIiBvciBhIGN1c3RvbSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wgPSBuZXcgQ29ubmVjdGlvblBvb2xfMS5kZWZhdWx0KHRoaXMub3B0aW9ucy5yZWRpc09wdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLm9uKFwiLW5vZGVcIiwgKHJlZGlzLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIi1ub2RlXCIsIHJlZGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wub24oXCIrbm9kZVwiLCAocmVkaXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIitub2RlXCIsIHJlZGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wub24oXCJkcmFpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImNsb3NlXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5vbihcIm5vZGVFcnJvclwiLCAoZXJyb3IsIGtleSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwibm9kZSBlcnJvclwiLCBlcnJvciwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBDbHVzdGVyU3Vic2NyaWJlcl8xLmRlZmF1bHQodGhpcy5jb25uZWN0aW9uUG9vbCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NyaXB0cykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5vcHRpb25zLnNjcmlwdHMpLmZvckVhY2goKFtuYW1lLCBkZWZpbml0aW9uXSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ29tbWFuZChuYW1lLCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF6eUNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwid2FpdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3RpbmcgZmFpbGVkOiAlc1wiLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byBhIGNsdXN0ZXJcbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImNvbm5lY3RpbmdcIiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBcImNvbm5lY3RcIiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBcInJlYWR5XCIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVkaXMgaXMgYWxyZWFkeSBjb25uZWN0aW5nL2Nvbm5lY3RlZFwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXBvY2ggPSArK3RoaXMuY29ubmVjdGlvbkVwb2NoO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJjb25uZWN0aW5nXCIpO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlU3RhcnR1cE5vZGVIb3N0bmFtZXMoKVxuICAgICAgICAgICAgICAgIC50aGVuKChub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25FcG9jaCAhPT0gZXBvY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJkaXNjYXJkIGNvbm5lY3RpbmcgYWZ0ZXIgcmVzb2x2aW5nIHN0YXJ0dXAgbm9kZXMgYmVjYXVzZSBlcG9jaCBub3QgbWF0Y2g6ICVkICE9ICVkXCIsIGVwb2NoLCB0aGlzLmNvbm5lY3Rpb25FcG9jaCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgcmVkaXNfZXJyb3JzXzEuUmVkaXNFcnJvcihcIkNvbm5lY3Rpb24gaXMgZGlzY2FyZGVkIGJlY2F1c2UgYSBuZXcgY29ubmVjdGlvbiBpcyBtYWRlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwiY29ubmVjdGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiZGlzY2FyZCBjb25uZWN0aW5nIGFmdGVyIHJlc29sdmluZyBzdGFydHVwIG5vZGVzIGJlY2F1c2UgdGhlIHN0YXR1cyBjaGFuZ2VkIHRvICVzXCIsIHRoaXMuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyByZWRpc19lcnJvcnNfMS5SZWRpc0Vycm9yKFwiQ29ubmVjdGlvbiBpcyBhYm9ydGVkXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLnJlc2V0KG5vZGVzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXJkZWRTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYXJkZWRTdWJzY3JpYmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnJlc2V0KHRoaXMuc2xvdHMsIHRoaXMuY29ubmVjdGlvblBvb2wuZ2V0Tm9kZXMoXCJhbGxcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgd2UgZW1pdCBhbiBlcnJvciBldmVudCBoZXJlP1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJFcnJvciB3aGlsZSBzdGFydGluZyBzdWJzY3JpYmVyczogJXNcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJyZWFkeVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeUF0dGVtcHRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leGVjdXRlT2ZmbGluZUNvbW1hbmRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXROb2Rlc1JlZnJlc2hJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsZXQgY2xvc2VMaXN0ZW5lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlUmVhZHlEZWxheWVkQ2FsbGJhY2tzKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBjbG9zZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW51YWxseUNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJjb25uZWN0XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZVJlYWR5Q2hlY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZHlDaGVjaygoZXJyLCBmYWlsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciB8fCBmYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiUmVhZHkgY2hlY2sgZmFpbGVkICglcykuIFJlY29ubmVjdGluZy4uLlwiLCBlcnIgfHwgZmFpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJjb25uZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZHlIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkeUhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2xvc2VMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJOb25lIG9mIHN0YXJ0dXAgbm9kZXMgaXMgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwicmVmcmVzaFwiLCByZWZyZXNoTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludm9rZVJlYWR5RGVsYXllZENhbGxiYWNrcyhlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJyZWZyZXNoXCIsIHJlZnJlc2hMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiY2xvc2VcIiwgY2xvc2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiY2xvc2VcIiwgdGhpcy5oYW5kbGVDbG9zZUV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaFNsb3RzQ2FjaGUoKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBDbHVzdGVyQWxsRmFpbGVkRXJyb3JfMS5kZWZhdWx0LmRlZmF1bHRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWRpc18xLmRlZmF1bHQucHJvdG90eXBlLnNpbGVudEVtaXQuY2FsbCh0aGlzLCBcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLnJlc2V0KFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5zdGFydCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcmRlZFN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzLnN0YXJ0KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgd2UgZW1pdCBhbiBlcnJvciBldmVudCBoZXJlP1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJFcnJvciB3aGlsZSBzdGFydGluZyBzdWJzY3JpYmVyczogJXNcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwiY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUV2ZW50KGVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZva2VSZWFkeURlbGF5ZWRDYWxsYmFja3MoZXJyKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBmcm9tIGV2ZXJ5IG5vZGUgaW4gdGhlIGNsdXN0ZXIuXG4gICAgICovXG4gICAgZGlzY29ubmVjdChyZWNvbm5lY3QgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJkaXNjb25uZWN0aW5nXCIpO1xuICAgICAgICBpZiAoIXJlY29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5tYW51YWxseUNsb3NpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQgJiYgIXJlY29ubmVjdCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgZGVidWcoXCJDYW5jZWxlZCByZWNvbm5lY3RpbmcgYXR0ZW1wdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhck5vZGVzUmVmcmVzaEludGVydmFsKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcmRlZFN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJ3YWl0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwiY2xvc2VcIik7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlRXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wucmVzZXQoW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aXQgdGhlIGNsdXN0ZXIgZ3JhY2VmdWxseS5cbiAgICAgKi9cbiAgICBxdWl0KGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhcImRpc2Nvbm5lY3RpbmdcIik7XG4gICAgICAgIHRoaXMubWFudWFsbHlDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJOb2Rlc1JlZnJlc2hJbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXJkZWRTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IFwid2FpdFwiKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShQcm9taXNlLnJlc29sdmUoXCJPS1wiKSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgLy8gdXNlIHNldEltbWVkaWF0ZSB0byBtYWtlIHN1cmUgXCJjbG9zZVwiIGV2ZW50XG4gICAgICAgICAgICAvLyBiZWluZyBlbWl0dGVkIGFmdGVyIHF1aXQoKSBpcyByZXR1cm5lZFxuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImNsb3NlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VFdmVudCgpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKFByb21pc2UuYWxsKHRoaXMubm9kZXMoKS5tYXAoKG5vZGUpID0+IG5vZGUucXVpdCgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgZXJyb3IgY2F1c2VkIGJ5IGRpc2Nvbm5lY3Rpbmcgc2luY2VcbiAgICAgICAgICAgIC8vIHdlJ3JlIGRpc2Nvbm5lY3RpbmcuLi5cbiAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gdXRpbHNfMS5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJPS1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KSkpLnRoZW4oKCkgPT4gXCJPS1wiKSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBzdGFydHVwIG5vZGVzIGFuZCBvcHRpb25zIGFzIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgY2x1c3RlciA9IG5ldyBSZWRpcy5DbHVzdGVyKFt7IGhvc3Q6IFwiMTI3LjAuMC4xXCIsIHBvcnQ6IFwiMzAwMDFcIiB9XSk7XG4gICAgICogdmFyIGFub3RoZXJDbHVzdGVyID0gY2x1c3Rlci5kdXBsaWNhdGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkdXBsaWNhdGUob3ZlcnJpZGVTdGFydHVwTm9kZXMgPSBbXSwgb3ZlcnJpZGVPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgc3RhcnR1cE5vZGVzID0gb3ZlcnJpZGVTdGFydHVwTm9kZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyBvdmVycmlkZVN0YXJ0dXBOb2Rlc1xuICAgICAgICAgICAgOiB0aGlzLnN0YXJ0dXBOb2Rlcy5zbGljZSgwKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgb3ZlcnJpZGVPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDbHVzdGVyKHN0YXJ0dXBOb2Rlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBub2RlcyB3aXRoIHRoZSBzcGVjaWZpZWQgcm9sZVxuICAgICAqL1xuICAgIG5vZGVzKHJvbGUgPSBcImFsbFwiKSB7XG4gICAgICAgIGlmIChyb2xlICE9PSBcImFsbFwiICYmIHJvbGUgIT09IFwibWFzdGVyXCIgJiYgcm9sZSAhPT0gXCJzbGF2ZVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcm9sZSBcIicgKyByb2xlICsgJ1wiLiBFeHBlY3RlZCBcImFsbFwiLCBcIm1hc3RlclwiIG9yIFwic2xhdmVcIicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qb29sLmdldE5vZGVzKHJvbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIG5lZWRlZCBpbiBvcmRlciBub3QgdG8gaW5zdGFsbCBhIGxpc3RlbmVyIGZvciBlYWNoIGF1dG8gcGlwZWxpbmVcbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBkZWxheVVudGlsUmVhZHkoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fcmVhZHlEZWxheWVkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBjb21tYW5kcyBxdWV1ZWQgaW4gYXV0b21hdGljIHBpcGVsaW5lcy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbm90IGF2YWlsYWJsZSAoYW5kIHJldHVybnMgMCkgdW50aWwgdGhlIGNsdXN0ZXIgaXMgY29ubmVjdGVkIGFuZCBzbG90cyBpbmZvcm1hdGlvbiBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gICAgICovXG4gICAgZ2V0IGF1dG9QaXBlbGluZVF1ZXVlU2l6ZSgpIHtcbiAgICAgICAgbGV0IHF1ZXVlZCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcGlwZWxpbmUgb2YgdGhpcy5fYXV0b1BpcGVsaW5lcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcXVldWVkICs9IHBpcGVsaW5lLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVldWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoIHRoZSBzbG90IGNhY2hlXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmVmcmVzaFNsb3RzQ2FjaGUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoU2xvdHNDYWNoZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1JlZnJlc2hpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVmcmVzaGluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc1JlZnJlc2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5fcmVmcmVzaFNsb3RzQ2FjaGVDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoU2xvdHNDYWNoZUNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBub2RlcyA9ICgwLCB1dGlsc18xLnNodWZmbGUpKHRoaXMuY29ubmVjdGlvblBvb2wuZ2V0Tm9kZXMoKSk7XG4gICAgICAgIGxldCBsYXN0Tm9kZUVycm9yID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gdHJ5Tm9kZShpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBDbHVzdGVyQWxsRmFpbGVkRXJyb3JfMS5kZWZhdWx0KENsdXN0ZXJBbGxGYWlsZWRFcnJvcl8xLmRlZmF1bHQuZGVmYXVsdE1lc3NhZ2UsIGxhc3ROb2RlRXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVyKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtub2RlLm9wdGlvbnMuaG9zdH06JHtub2RlLm9wdGlvbnMucG9ydH1gO1xuICAgICAgICAgICAgZGVidWcoXCJnZXR0aW5nIHNsb3QgY2FjaGUgZnJvbSAlc1wiLCBrZXkpO1xuICAgICAgICAgICAgX3RoaXMuZ2V0SW5mb0Zyb21Ob2RlKG5vZGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF90aGlzLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIobmV3IEVycm9yKFwiQ2x1c3RlciBpcyBkaXNjb25uZWN0ZWQuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRpc2Nvbm5lY3RpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVyKG5ldyBFcnJvcihcIkNsdXN0ZXIgaXMgZGlzY29ubmVjdGluZy5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJub2RlIGVycm9yXCIsIGVyciwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE5vZGVFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgdHJ5Tm9kZShpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlZnJlc2hcIik7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cnlOb2RlKDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgc2VuZENvbW1hbmQoY29tbWFuZCwgc3RyZWFtLCBub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJ3YWl0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKHV0aWxzXzEubm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICBjb21tYW5kLnJlamVjdChuZXcgRXJyb3IodXRpbHNfMS5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cpKTtcbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kLnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvID0gdGhpcy5vcHRpb25zLnNjYWxlUmVhZHM7XG4gICAgICAgIGlmICh0byAhPT0gXCJtYXN0ZXJcIikge1xuICAgICAgICAgICAgY29uc3QgaXNDb21tYW5kUmVhZE9ubHkgPSBjb21tYW5kLmlzUmVhZE9ubHkgfHxcbiAgICAgICAgICAgICAgICAoKDAsIGNvbW1hbmRzXzEuZXhpc3RzKShjb21tYW5kLm5hbWUpICYmICgwLCBjb21tYW5kc18xLmhhc0ZsYWcpKGNvbW1hbmQubmFtZSwgXCJyZWFkb25seVwiKSk7XG4gICAgICAgICAgICBpZiAoIWlzQ29tbWFuZFJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgdG8gPSBcIm1hc3RlclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0YXJnZXRTbG90ID0gbm9kZSA/IG5vZGUuc2xvdCA6IGNvbW1hbmQuZ2V0U2xvdCgpO1xuICAgICAgICBjb25zdCB0dGwgPSB7fTtcbiAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIW5vZGUgJiYgIVJFSkVDVF9PVkVSV1JJVFRFTl9DT01NQU5EUy5oYXMoY29tbWFuZCkpIHtcbiAgICAgICAgICAgIFJFSkVDVF9PVkVSV1JJVFRFTl9DT01NQU5EUy5hZGQoY29tbWFuZCk7XG4gICAgICAgICAgICBjb25zdCByZWplY3QgPSBjb21tYW5kLnJlamVjdDtcbiAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0ID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxUcnkgPSB0cnlDb25uZWN0aW9uLmJpbmQobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlRXJyb3IoZXJyLCB0dGwsIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQ6IGZ1bmN0aW9uIChzbG90LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiY29tbWFuZCAlcyBpcyBtb3ZlZCB0byAlc1wiLCBjb21tYW5kLm5hbWUsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTbG90ID0gTnVtYmVyKHNsb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNsb3RzW3Nsb3RdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2xvdHNbc2xvdF1bMF0gPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zbG90c1tzbG90XSA9IFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2dyb3Vwc0J5U2xvdFtzbG90XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2dyb3Vwc0lkc1tfdGhpcy5zbG90c1tzbG90XS5qb2luKFwiO1wiKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0aW9uUG9vbC5maW5kT3JDcmVhdGUoX3RoaXMubmF0TWFwcGVyKGtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJyZWZyZXNoaW5nIHNsb3QgY2FjaGVzLi4uICh0cmlnZ2VyZWQgYnkgTU9WRUQgZXJyb3IpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmcmVzaFNsb3RzQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXNrOiBmdW5jdGlvbiAoc2xvdCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImNvbW1hbmQgJXMgaXMgcmVxdWlyZWQgdG8gYXNrICVzOiVzXCIsIGNvbW1hbmQubmFtZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBlZCA9IF90aGlzLm5hdE1hcHBlcihrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdGlvblBvb2wuZmluZE9yQ3JlYXRlKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnlDb25uZWN0aW9uKGZhbHNlLCBgJHttYXBwZWQuaG9zdH06JHttYXBwZWQucG9ydH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdHJ5YWdhaW46IHBhcnRpYWxUcnksXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJEb3duOiBwYXJ0aWFsVHJ5LFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ2xvc2VkOiBwYXJ0aWFsVHJ5LFxuICAgICAgICAgICAgICAgICAgICBtYXhSZWRpcmVjdGlvbnM6IGZ1bmN0aW9uIChyZWRpcmVjdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QuY2FsbChjb21tYW5kLCByZWRpcmVjdGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdC5jYWxsKGNvbW1hbmQsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRyeUNvbm5lY3Rpb24oKTtcbiAgICAgICAgZnVuY3Rpb24gdHJ5Q29ubmVjdGlvbihyYW5kb20sIGFza2luZykge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXR1cyA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KG5ldyByZWRpc19lcnJvcnNfMS5BYm9ydEVycm9yKFwiQ2x1c3RlciBpcyBlbmRlZC5cIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZWRpcztcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXMgPT09IFwicmVhZHlcIiB8fCBjb21tYW5kLm5hbWUgPT09IFwiY2x1c3RlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5yZWRpcykge1xuICAgICAgICAgICAgICAgICAgICByZWRpcyA9IG5vZGUucmVkaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKENvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIkVOVEVSX1NVQlNDUklCRVJfTU9ERVwiLCBjb21tYW5kLm5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIENvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIkVYSVRfU1VCU0NSSUJFUl9NT0RFXCIsIGNvbW1hbmQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuc2hhcmRlZFN1YnNjcmliZXJzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tbWFuZC5uYW1lID09IFwic3N1YnNjcmliZVwiIHx8IGNvbW1hbmQubmFtZSA9PSBcInN1bnN1YnNjcmliZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gX3RoaXMuc2hhcmRlZFN1YnNjcmliZXJzLmdldFJlc3BvbnNpYmxlU3Vic2NyaWJlcih0YXJnZXRTbG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IHJlZGlzX2Vycm9yc18xLkFib3J0RXJyb3IoYE5vIHNoYXJkZWQgc3Vic2NyaWJlciBmb3Igc2xvdDogJHt0YXJnZXRTbG90fWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdHVzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC5uYW1lID09IFwic3N1YnNjcmliZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gX3RoaXMuc2hhcmRlZFN1YnNjcmliZXJzLmFkZENoYW5uZWxzKGNvbW1hbmQuZ2V0S2V5cygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kLm5hbWUgPT0gXCJzdW5zdWJzY3JpYmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IF90aGlzLnNoYXJkZWRTdWJzY3JpYmVycy5yZW1vdmVDaGFubmVscyhjb21tYW5kLmdldEtleXMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID0gc3ViLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLnJlamVjdChuZXcgcmVkaXNfZXJyb3JzXzEuQWJvcnRFcnJvcihcIlBvc3NpYmxlIENST1NTU0xPVCBlcnJvcjogQWxsIGNoYW5uZWxzIG11c3QgaGFzaCB0byB0aGUgc2FtZSBzbG90XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID0gX3RoaXMuc3Vic2NyaWJlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVkaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KG5ldyByZWRpc19lcnJvcnNfMS5BYm9ydEVycm9yKFwiTm8gc3Vic2NyaWJlciBmb3IgdGhlIGNsdXN0ZXJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJhbmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRTbG90ID09PSBcIm51bWJlclwiICYmIF90aGlzLnNsb3RzW3RhcmdldFNsb3RdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZUtleXMgPSBfdGhpcy5zbG90c1t0YXJnZXRTbG90XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBub2RlS2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbm5lY3Rpb25Qb29sLmdldEluc3RhbmNlQnlLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID0gdG8obm9kZXMsIGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWRpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID0gKDAsIHV0aWxzXzEuc2FtcGxlKShyZWRpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWRpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMgPSBub2Rlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSAoMCwgdXRpbHNfMS5zYW1wbGUpKG5vZGVLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0byA9PT0gXCJzbGF2ZVwiICYmIG5vZGVLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9ICgwLCB1dGlsc18xLnNhbXBsZSkobm9kZUtleXMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbm9kZUtleXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMgPSBfdGhpcy5jb25uZWN0aW9uUG9vbC5nZXRJbnN0YW5jZUJ5S2V5KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFza2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID0gX3RoaXMuY29ubmVjdGlvblBvb2wuZ2V0SW5zdGFuY2VCeUtleShhc2tpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzLmFza2luZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVkaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHRvID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogX3RoaXMuY29ubmVjdGlvblBvb2wuZ2V0U2FtcGxlSW5zdGFuY2UodG8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0aW9uUG9vbC5nZXRTYW1wbGVJbnN0YW5jZShcImFsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiAhbm9kZS5yZWRpcykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlZGlzID0gcmVkaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlZGlzKSB7XG4gICAgICAgICAgICAgICAgcmVkaXMuc2VuZENvbW1hbmQoY29tbWFuZCwgc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLm9wdGlvbnMuZW5hYmxlT2ZmbGluZVF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub2ZmbGluZVF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KG5ldyBFcnJvcihcIkNsdXN0ZXIgaXNuJ3QgcmVhZHkgYW5kIGVuYWJsZU9mZmxpbmVRdWV1ZSBvcHRpb25zIGlzIGZhbHNlXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgIH1cbiAgICBzc2NhblN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInNzY2FuXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBzc2NhbkJ1ZmZlclN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInNzY2FuQnVmZmVyXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBoc2NhblN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcImhzY2FuXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBoc2NhbkJ1ZmZlclN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcImhzY2FuQnVmZmVyXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICB6c2NhblN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInpzY2FuXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICB6c2NhbkJ1ZmZlclN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInpzY2FuQnVmZmVyXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIHR0bCwgaGFuZGxlcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0dGwudmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHR0bC52YWx1ZSA9IHRoaXMub3B0aW9ucy5tYXhSZWRpcmVjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0dGwudmFsdWUgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHRsLnZhbHVlIDw9IDApIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLm1heFJlZGlyZWN0aW9ucyhuZXcgRXJyb3IoXCJUb28gbWFueSBDbHVzdGVyIHJlZGlyZWN0aW9ucy4gTGFzdCBlcnJvcjogXCIgKyBlcnJvcikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycnYgPSBlcnJvci5tZXNzYWdlLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgaWYgKGVycnZbMF0gPT09IFwiTU9WRURcIikge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5T25Nb3ZlZDtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICYmIHR5cGVvZiB0aW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheVF1ZXVlLnB1c2goXCJtb3ZlZFwiLCBoYW5kbGVycy5tb3ZlZC5iaW5kKG51bGwsIGVycnZbMV0sIGVycnZbMl0pLCB7IHRpbWVvdXQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5tb3ZlZChlcnJ2WzFdLCBlcnJ2WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJ2WzBdID09PSBcIkFTS1wiKSB7XG4gICAgICAgICAgICBoYW5kbGVycy5hc2soZXJydlsxXSwgZXJydlsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJydlswXSA9PT0gXCJUUllBR0FJTlwiKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5UXVldWUucHVzaChcInRyeWFnYWluXCIsIGhhbmRsZXJzLnRyeWFnYWluLCB7XG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5vcHRpb25zLnJldHJ5RGVsYXlPblRyeUFnYWluLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJydlswXSA9PT0gXCJDTFVTVEVSRE9XTlwiICYmXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucmV0cnlEZWxheU9uQ2x1c3RlckRvd24gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5UXVldWUucHVzaChcImNsdXN0ZXJkb3duXCIsIGhhbmRsZXJzLmNvbm5lY3Rpb25DbG9zZWQsIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLm9wdGlvbnMucmV0cnlEZWxheU9uQ2x1c3RlckRvd24sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMucmVmcmVzaFNsb3RzQ2FjaGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UgPT09IHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHICYmXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucmV0cnlEZWxheU9uRmFpbG92ZXIgPiAwICYmXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5UXVldWUucHVzaChcImZhaWxvdmVyXCIsIGhhbmRsZXJzLmNvbm5lY3Rpb25DbG9zZWQsIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLm9wdGlvbnMucmV0cnlEZWxheU9uRmFpbG92ZXIsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMucmVmcmVzaFNsb3RzQ2FjaGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlcnMuZGVmYXVsdHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldE9mZmxpbmVRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5vZmZsaW5lUXVldWUgPSBuZXcgRGVxdWUoKTtcbiAgICB9XG4gICAgY2xlYXJOb2Rlc1JlZnJlc2hJbnRlcnZhbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2xvdHNUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2xvdHNUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnNsb3RzVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0Tm9kZXNSZWZyZXNoSW50ZXJ2YWwoKSB7XG4gICAgICAgIGlmICh0aGlzLnNsb3RzVGltZXIgfHwgIXRoaXMub3B0aW9ucy5zbG90c1JlZnJlc2hJbnRlcnZhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRSb3VuZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2xvdHNUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdyZWZyZXNoaW5nIHNsb3QgY2FjaGVzLi4uICh0cmlnZ2VyZWQgYnkgXCJzbG90c1JlZnJlc2hJbnRlcnZhbFwiIG9wdGlvbiknKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hTbG90c0NhY2hlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJvdW5kKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMuc2xvdHNSZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgICB9O1xuICAgICAgICBuZXh0Um91bmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGNsdXN0ZXIgaW5zdGFuY2UncyBzdGF0dXNcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIGRlYnVnKFwic3RhdHVzOiAlcyAtPiAlc1wiLCB0aGlzLnN0YXR1cyB8fCBcIltlbXB0eV1cIiwgc3RhdHVzKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBjbG9zZWQgdG8gY2hlY2sgd2hldGhlciBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgbWFkZVxuICAgICAqL1xuICAgIGhhbmRsZUNsb3NlRXZlbnQocmVhc29uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHJlYXNvbikge1xuICAgICAgICAgICAgZGVidWcoXCJjbG9zZWQgYmVjYXVzZSAlc1wiLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXRyeURlbGF5O1xuICAgICAgICBpZiAoIXRoaXMubWFudWFsbHlDbG9zaW5nICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLmNsdXN0ZXJSZXRyeVN0cmF0ZWd5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHJ5RGVsYXkgPSB0aGlzLm9wdGlvbnMuY2x1c3RlclJldHJ5U3RyYXRlZ3kuY2FsbCh0aGlzLCArK3RoaXMucmV0cnlBdHRlbXB0cywgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJldHJ5RGVsYXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwicmVjb25uZWN0aW5nXCIpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIkNsdXN0ZXIgaXMgZGlzY29ubmVjdGVkLiBSZXRyeWluZyBhZnRlciAlZG1zXCIsIHJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJHb3QgZXJyb3IgJXMgd2hlbiByZWNvbm5lY3RpbmcuIElnbm9yaW5nLi4uXCIsIGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCByZXRyeURlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcmRlZFN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5zdWJzY3JpYmVyR3JvdXBFbWl0dGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImVuZFwiKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hRdWV1ZShuZXcgRXJyb3IoXCJOb25lIG9mIHN0YXJ0dXAgbm9kZXMgaXMgYXZhaWxhYmxlXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaCBvZmZsaW5lIHF1ZXVlIHdpdGggZXJyb3IuXG4gICAgICovXG4gICAgZmx1c2hRdWV1ZShlcnJvcikge1xuICAgICAgICBsZXQgaXRlbTtcbiAgICAgICAgd2hpbGUgKChpdGVtID0gdGhpcy5vZmZsaW5lUXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4ZWN1dGVPZmZsaW5lQ29tbWFuZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9mZmxpbmVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2VuZCAlZCBjb21tYW5kcyBpbiBvZmZsaW5lIHF1ZXVlXCIsIHRoaXMub2ZmbGluZVF1ZXVlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBvZmZsaW5lUXVldWUgPSB0aGlzLm9mZmxpbmVRdWV1ZTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRPZmZsaW5lUXVldWUoKTtcbiAgICAgICAgICAgIGxldCBpdGVtO1xuICAgICAgICAgICAgd2hpbGUgKChpdGVtID0gb2ZmbGluZVF1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kQ29tbWFuZChpdGVtLmNvbW1hbmQsIGl0ZW0uc3RyZWFtLCBpdGVtLm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5hdE1hcHBlcihub2RlS2V5KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHR5cGVvZiBub2RlS2V5ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IG5vZGVLZXlcbiAgICAgICAgICAgIDogYCR7bm9kZUtleS5ob3N0fToke25vZGVLZXkucG9ydH1gO1xuICAgICAgICBsZXQgbWFwcGVkID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5uYXRNYXAgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5uYXRNYXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbWFwcGVkID0gdGhpcy5vcHRpb25zLm5hdE1hcChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5uYXRNYXAgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5uYXRNYXAgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG1hcHBlZCA9IHRoaXMub3B0aW9ucy5uYXRNYXBba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIk5BVCBtYXBwaW5nICVzIC0+ICVPXCIsIGtleSwgbWFwcGVkKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2Ygbm9kZUtleSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyAoMCwgdXRpbF8xLm5vZGVLZXlUb1JlZGlzT3B0aW9ucykobm9kZUtleSlcbiAgICAgICAgICAgIDogbm9kZUtleTtcbiAgICB9XG4gICAgZ2V0SW5mb0Zyb21Ob2RlKHJlZGlzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXJlZGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiTm9kZSBpcyBkaXNjb25uZWN0ZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBhIGR1cGxpY2F0aW9uIG9mIHRoZSBjb25uZWN0aW9uIHRvIGF2b2lkXG4gICAgICAgIC8vIHRpbWVvdXRzIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgaW4gdGhlIGJsb2NraW5nXG4gICAgICAgIC8vIG1vZGUgKGUuZy4gd2FpdGluZyBmb3IgQkxQT1ApLlxuICAgICAgICBjb25zdCBkdXBsaWNhdGVkQ29ubmVjdGlvbiA9IHJlZGlzLmR1cGxpY2F0ZSh7XG4gICAgICAgICAgICBlbmFibGVPZmZsaW5lUXVldWU6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVSZWFkeUNoZWNrOiBmYWxzZSxcbiAgICAgICAgICAgIHJldHJ5U3RyYXRlZ3k6IG51bGwsXG4gICAgICAgICAgICBjb25uZWN0aW9uTmFtZTogKDAsIHV0aWxfMS5nZXRDb25uZWN0aW9uTmFtZSkoXCJyZWZyZXNoZXJcIiwgdGhpcy5vcHRpb25zLnJlZGlzT3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucmVkaXNPcHRpb25zLmNvbm5lY3Rpb25OYW1lKSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElnbm9yZSBlcnJvciBldmVudHMgc2luY2Ugd2Ugd2lsbCBoYW5kbGVcbiAgICAgICAgLy8gZXhjZXB0aW9ucyBmb3IgdGhlIENMVVNURVIgU0xPVFMgY29tbWFuZC5cbiAgICAgICAgZHVwbGljYXRlZENvbm5lY3Rpb24ub24oXCJlcnJvclwiLCB1dGlsc18xLm5vb3ApO1xuICAgICAgICBkdXBsaWNhdGVkQ29ubmVjdGlvbi5jbHVzdGVyKFwiU0xPVFNcIiwgKDAsIHV0aWxzXzEudGltZW91dCkoKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBkdXBsaWNhdGVkQ29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJlcnJvciBlbmNvdW50ZXJlZCBydW5uaW5nIENMVVNURVIuU0xPVFM6ICVzXCIsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwiZGlzY29ubmVjdGluZ1wiIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IFwiY2xvc2VcIiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJpZ25vcmUgQ0xVU1RFUi5TTE9UUyByZXN1bHRzIChjb3VudDogJWQpIHNpbmNlIGNsdXN0ZXIgc3RhdHVzIGlzICVzXCIsIHJlc3VsdC5sZW5ndGgsIHRoaXMuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICAgICAgICBkZWJ1ZyhcImNsdXN0ZXIgc2xvdHMgcmVzdWx0IGNvdW50OiAlZFwiLCByZXN1bHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSByZXN1bHRbaV07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdFJhbmdlU3RhcnQgPSBpdGVtc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90UmFuZ2VFbmQgPSBpdGVtc1sxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI7IGogPCBpdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zW2pdWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5uYXRNYXBwZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogaXRlbXNbal1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBpdGVtc1tqXVsxXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVhZE9ubHkgPSBqICE9PSAyO1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2gobm9kZS5ob3N0ICsgXCI6XCIgKyBub2RlLnBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImNsdXN0ZXIgc2xvdHMgcmVzdWx0IFslZF06IHNsb3RzICVkfiVkIHNlcnZlZCBieSAlc1wiLCBpLCBzbG90UmFuZ2VTdGFydCwgc2xvdFJhbmdlRW5kLCBrZXlzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzbG90ID0gc2xvdFJhbmdlU3RhcnQ7IHNsb3QgPD0gc2xvdFJhbmdlRW5kOyBzbG90KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbG90c1tzbG90XSA9IGtleXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXNzaWduIHRvIGVhY2ggbm9kZSBrZXlzIGEgbnVtZXJpYyB2YWx1ZSB0byBtYWtlIGF1dG9waXBlbGluZSBjb21wYXJpc29uIGZhc3Rlci5cbiAgICAgICAgICAgIHRoaXMuX2dyb3Vwc0lkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2Mzg0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAodGhpcy5zbG90c1tpXSB8fCBbXSkuam9pbihcIjtcIik7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyb3Vwc0J5U2xvdFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZ3JvdXBzSWRzW3RhcmdldF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JvdXBzSWRzW3RhcmdldF0gPSArK2o7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2dyb3Vwc0J5U2xvdFtpXSA9IHRoaXMuX2dyb3Vwc0lkc1t0YXJnZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5yZXNldChub2Rlcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXJkZWRTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzXG4gICAgICAgICAgICAgICAgICAgIC5yZXNldCh0aGlzLnNsb3RzLCB0aGlzLmNvbm5lY3Rpb25Qb29sLmdldE5vZGVzKFwiYWxsXCIpKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHNob3VsZCB3ZSBlbWl0IGFuIGVycm9yIGV2ZW50IGhlcmU/XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiRXJyb3Igd2hpbGUgc3RhcnRpbmcgc3Vic2NyaWJlcnM6ICVzXCIsIGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuc2xvdHNSZWZyZXNoVGltZW91dCkpO1xuICAgIH1cbiAgICBpbnZva2VSZWFkeURlbGF5ZWRDYWxsYmFja3MoZXJyKSB7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLl9yZWFkeURlbGF5ZWRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soYywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWFkeURlbGF5ZWRDYWxsYmFja3MgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciBDbHVzdGVyIGlzIGFibGUgdG8gcHJvY2VzcyBjb21tYW5kc1xuICAgICAqL1xuICAgIHJlYWR5Q2hlY2soY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyKFwiSU5GT1wiLCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHJlcy5zcGxpdChcIlxcclxcblwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmVzW2ldLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbMF0gPT09IFwiY2x1c3Rlcl9zdGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gXCJmYWlsXCIpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImNsdXN0ZXIgc3RhdGUgbm90IG9rICglcylcIiwgc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNvbHZlU3J2KGhvc3RuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVzb2x2ZVNydihob3N0bmFtZSwgKGVyciwgcmVjb3JkcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcywgZ3JvdXBlZFJlY29yZHMgPSAoMCwgdXRpbF8xLmdyb3VwU3J2UmVjb3JkcykocmVjb3JkcyksIHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyhncm91cGVkUmVjb3Jkcykuc29ydCgoYSwgYikgPT4gcGFyc2VJbnQoYSkgLSBwYXJzZUludChiKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdHJ5Rmlyc3RPbmUoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc29ydGVkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBzb3J0ZWRLZXlzWzBdLCBncm91cCA9IGdyb3VwZWRSZWNvcmRzW2tleV0sIHJlY29yZCA9ICgwLCB1dGlsXzEud2VpZ2h0U3J2UmVjb3JkcykoZ3JvdXApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyb3VwLnJlY29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRLZXlzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kbnNMb29rdXAocmVjb3JkLm5hbWUpLnRoZW4oKGhvc3QpID0+IHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IHJlY29yZC5wb3J0LFxuICAgICAgICAgICAgICAgICAgICB9KSwgdHJ5Rmlyc3RPbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnlGaXJzdE9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkbnNMb29rdXAoaG9zdG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kbnNMb29rdXAoaG9zdG5hbWUsIChlcnIsIGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiZmFpbGVkIHRvIHJlc29sdmUgaG9zdG5hbWUgJXMgdG8gSVA6ICVzXCIsIGhvc3RuYW1lLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJyZXNvbHZlZCBob3N0bmFtZSAlcyB0byBJUCAlc1wiLCBob3N0bmFtZSwgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgc3RhcnR1cCBub2RlcywgYW5kIHJlc29sdmluZyBob3N0bmFtZXMgdG8gSVBzLlxuICAgICAqXG4gICAgICogVGhpcyBwcm9jZXNzIGhhcHBlbnMgZXZlcnkgdGltZSB3aGVuICNjb25uZWN0KCkgaXMgY2FsbGVkIHNpbmNlXG4gICAgICogI3N0YXJ0dXBOb2RlcyBhbmQgRE5TIHJlY29yZHMgbWF5IGNoYW5hZ2UuXG4gICAgICovXG4gICAgYXN5bmMgcmVzb2x2ZVN0YXJ0dXBOb2RlSG9zdG5hbWVzKCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5zdGFydHVwTm9kZXMpIHx8IHRoaXMuc3RhcnR1cE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHN0YXJ0dXBOb2Rlc2Agc2hvdWxkIGNvbnRhaW4gYXQgbGVhc3Qgb25lIG5vZGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0dXBOb2RlcyA9ICgwLCB1dGlsXzEubm9ybWFsaXplTm9kZU9wdGlvbnMpKHRoaXMuc3RhcnR1cE5vZGVzKTtcbiAgICAgICAgY29uc3QgaG9zdG5hbWVzID0gKDAsIHV0aWxfMS5nZXRVbmlxdWVIb3N0bmFtZXNGcm9tT3B0aW9ucykoc3RhcnR1cE5vZGVzKTtcbiAgICAgICAgaWYgKGhvc3RuYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydHVwTm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlncyA9IGF3YWl0IFByb21pc2UuYWxsKGhvc3RuYW1lcy5tYXAoKHRoaXMub3B0aW9ucy51c2VTUlZSZWNvcmRzID8gdGhpcy5yZXNvbHZlU3J2IDogdGhpcy5kbnNMb29rdXApLmJpbmQodGhpcykpKTtcbiAgICAgICAgY29uc3QgaG9zdG5hbWVUb0NvbmZpZyA9ICgwLCB1dGlsc18xLnppcE1hcCkoaG9zdG5hbWVzLCBjb25maWdzKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0dXBOb2Rlcy5tYXAoKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGhvc3RuYW1lVG9Db25maWcuZ2V0KG5vZGUuaG9zdCk7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VTUlZSZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgeyBob3N0OiBjb25maWcgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVTY2FuU3RyZWFtKGNvbW1hbmQsIHsga2V5LCBvcHRpb25zID0ge30gfSkge1xuICAgICAgICByZXR1cm4gbmV3IFNjYW5TdHJlYW1fMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHJlZGlzOiB0aGlzLFxuICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVTaGFyZGVkU3Vic2NyaWJlckdyb3VwKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJHcm91cEVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzID0gbmV3IENsdXN0ZXJTdWJzY3JpYmVyR3JvdXBfMS5kZWZhdWx0KHRoaXMuc3Vic2NyaWJlckdyb3VwRW1pdHRlcik7XG4gICAgICAgIC8vIEVycm9yIGhhbmRsZXIgdXNlZCBvbmx5IGZvciBzaGFyZGVkLXN1YnNjcmliZXItdHJpZ2dlcmVkIHNsb3RzIGNhY2hlIHJlZnJlc2hlcy5cbiAgICAgICAgLy8gTm9ybWFsIChub24tc3Vic2NyaWJlcikgY29ubmVjdGlvbnMgYXJlIGNyZWF0ZWQgd2l0aCBsYXp5Q29ubmVjdDogdHJ1ZSBhbmQgY2FuXG4gICAgICAgIC8vIGJlY29tZSB6b21iaWVkLiBGb3Igc2hhcmRlZCBzdWJzY3JpYmVycywgYSBDbHVzdGVyQWxsRmFpbGVkRXJyb3IgbWVhbnNcbiAgICAgICAgLy8gd2UgaGF2ZSBsb3N0IGFsbCBub2RlcyBmcm9tIHRoZSBzdWJzY3JpYmVyIHBlcnNwZWN0aXZlIGFuZCBtdXN0IHRlYXIgZG93bi5cbiAgICAgICAgY29uc3QgcmVmcmVzaFNsb3RzQ2FjaGVDYWxsYmFjayA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIC8vIERpc2Nvbm5lY3Qgb25seSB3aGVuIHJlZnJlc2hpbmcgdGhlIHNsb3RzIGNhY2hlIGZhaWxzIHdpdGggQ2x1c3RlckFsbEZhaWxlZEVycm9yXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ2x1c3RlckFsbEZhaWxlZEVycm9yXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyR3JvdXBFbWl0dGVyLm9uKFwiLW5vZGVcIiwgKHJlZGlzLCBub2RlS2V5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCItbm9kZVwiLCByZWRpcywgbm9kZUtleSk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hTbG90c0NhY2hlKHJlZnJlc2hTbG90c0NhY2hlQ2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyR3JvdXBFbWl0dGVyLm9uKFwic3Vic2NyaWJlckNvbm5lY3RGYWlsZWRcIiwgKHsgZGVsYXksIGVycm9yIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaFNsb3RzQ2FjaGUocmVmcmVzaFNsb3RzQ2FjaGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJHcm91cEVtaXR0ZXIub24oXCJtb3ZlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hTbG90c0NhY2hlKHJlZnJlc2hTbG90c0NhY2hlQ2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyR3JvdXBFbWl0dGVyLm9uKFwiLXN1YnNjcmliZXJcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiLXN1YnNjcmliZXJcIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJHcm91cEVtaXR0ZXIub24oXCIrc3Vic2NyaWJlclwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCIrc3Vic2NyaWJlclwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlckdyb3VwRW1pdHRlci5vbihcIm5vZGVFcnJvclwiLCAoZXJyb3IsIG5vZGVLZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIm5vZGVFcnJvclwiLCBlcnJvciwgbm9kZUtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJHcm91cEVtaXR0ZXIub24oXCJzdWJzY3JpYmVyc1JlYWR5XCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInN1YnNjcmliZXJzUmVhZHlcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIFtcInNtZXNzYWdlXCIsIFwic21lc3NhZ2VCdWZmZXJcIl0pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlckdyb3VwRW1pdHRlci5vbihldmVudCwgKGFyZzEsIGFyZzIsIGFyZzMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4oMCwgYXBwbHlNaXhpbl8xLmRlZmF1bHQpKENsdXN0ZXIsIGV2ZW50c18xLkV2ZW50RW1pdHRlcik7XG4oMCwgdHJhbnNhY3Rpb25fMS5hZGRUcmFuc2FjdGlvblN1cHBvcnQpKENsdXN0ZXIucHJvdG90eXBlKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENsdXN0ZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjb21tYW5kc18xIiwicmVxdWlyZSIsImV2ZW50c18xIiwicmVkaXNfZXJyb3JzXzEiLCJzdGFuZGFyZF9hc19jYWxsYmFja18xIiwiQ29tbWFuZF8xIiwiQ2x1c3RlckFsbEZhaWxlZEVycm9yXzEiLCJSZWRpc18xIiwiU2NhblN0cmVhbV8xIiwidHJhbnNhY3Rpb25fMSIsInV0aWxzXzEiLCJhcHBseU1peGluXzEiLCJDb21tYW5kZXJfMSIsIkNsdXN0ZXJPcHRpb25zXzEiLCJDbHVzdGVyU3Vic2NyaWJlcl8xIiwiQ29ubmVjdGlvblBvb2xfMSIsIkRlbGF5UXVldWVfMSIsInV0aWxfMSIsIkRlcXVlIiwiQ2x1c3RlclN1YnNjcmliZXJHcm91cF8xIiwiZGVidWciLCJEZWJ1ZyIsIlJFSkVDVF9PVkVSV1JJVFRFTl9DT01NQU5EUyIsIldlYWtTZXQiLCJDbHVzdGVyIiwiZGVmYXVsdCIsImNvbnN0cnVjdG9yIiwic3RhcnR1cE5vZGVzIiwib3B0aW9ucyIsInNsb3RzIiwiX2dyb3Vwc0lkcyIsIl9ncm91cHNCeVNsb3QiLCJBcnJheSIsImlzQ2x1c3RlciIsInJldHJ5QXR0ZW1wdHMiLCJkZWxheVF1ZXVlIiwib2ZmbGluZVF1ZXVlIiwiaXNSZWZyZXNoaW5nIiwiX3JlZnJlc2hTbG90c0NhY2hlQ2FsbGJhY2tzIiwiX2F1dG9QaXBlbGluZXMiLCJNYXAiLCJfcnVubmluZ0F1dG9QaXBlbGluZXMiLCJTZXQiLCJfcmVhZHlEZWxheWVkQ2FsbGJhY2tzIiwiY29ubmVjdGlvbkVwb2NoIiwiRXZlbnRFbWl0dGVyIiwiY2FsbCIsImRlZmF1bHRzIiwiREVGQVVMVF9DTFVTVEVSX09QVElPTlMiLCJzaGFyZGVkU3Vic2NyaWJlcnMiLCJjcmVhdGVTaGFyZGVkU3Vic2NyaWJlckdyb3VwIiwicmVkaXNPcHRpb25zIiwia2V5UHJlZml4Iiwic2NhbGVSZWFkcyIsImluZGV4T2YiLCJFcnJvciIsImNvbm5lY3Rpb25Qb29sIiwib24iLCJyZWRpcyIsImtleSIsImVtaXQiLCJzZXRTdGF0dXMiLCJlcnJvciIsInN1YnNjcmliZXIiLCJzY3JpcHRzIiwiZW50cmllcyIsImZvckVhY2giLCJuYW1lIiwiZGVmaW5pdGlvbiIsImRlZmluZUNvbW1hbmQiLCJsYXp5Q29ubmVjdCIsImNvbm5lY3QiLCJjYXRjaCIsImVyciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic3RhdHVzIiwiZXBvY2giLCJyZXNvbHZlU3RhcnR1cE5vZGVIb3N0bmFtZXMiLCJ0aGVuIiwibm9kZXMiLCJSZWRpc0Vycm9yIiwicmVzZXQiLCJnZXROb2RlcyIsInJlYWR5SGFuZGxlciIsImV4ZWN1dGVPZmZsaW5lQ29tbWFuZHMiLCJyZXNldE5vZGVzUmVmcmVzaEludGVydmFsIiwiY2xvc2VMaXN0ZW5lciIsInVuZGVmaW5lZCIsInJlZnJlc2hMaXN0ZW5lciIsImludm9rZVJlYWR5RGVsYXllZENhbGxiYWNrcyIsInJlbW92ZUxpc3RlbmVyIiwibWFudWFsbHlDbG9zaW5nIiwiZW5hYmxlUmVhZHlDaGVjayIsInJlYWR5Q2hlY2siLCJmYWlsIiwiZGlzY29ubmVjdCIsIm9uY2UiLCJoYW5kbGVDbG9zZUV2ZW50IiwiYmluZCIsInJlZnJlc2hTbG90c0NhY2hlIiwibWVzc2FnZSIsImRlZmF1bHRNZXNzYWdlIiwicHJvdG90eXBlIiwic2lsZW50RW1pdCIsInN0YXJ0IiwicmVjb25uZWN0IiwicmVjb25uZWN0VGltZW91dCIsImNsZWFyVGltZW91dCIsImNsZWFyTm9kZXNSZWZyZXNoSW50ZXJ2YWwiLCJzdG9wIiwicXVpdCIsImNhbGxiYWNrIiwicmV0Iiwic2V0SW1tZWRpYXRlIiwiYWxsIiwibWFwIiwibm9kZSIsIkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyIsImR1cGxpY2F0ZSIsIm92ZXJyaWRlU3RhcnR1cE5vZGVzIiwib3ZlcnJpZGVPcHRpb25zIiwibGVuZ3RoIiwic2xpY2UiLCJhc3NpZ24iLCJyb2xlIiwiZGVsYXlVbnRpbFJlYWR5IiwicHVzaCIsImF1dG9QaXBlbGluZVF1ZXVlU2l6ZSIsInF1ZXVlZCIsInBpcGVsaW5lIiwidmFsdWVzIiwiX3RoaXMiLCJ3cmFwcGVyIiwic2h1ZmZsZSIsImxhc3ROb2RlRXJyb3IiLCJ0cnlOb2RlIiwiaW5kZXgiLCJob3N0IiwicG9ydCIsImdldEluZm9Gcm9tTm9kZSIsInNlbmRDb21tYW5kIiwiY29tbWFuZCIsInN0cmVhbSIsIm5vb3AiLCJwcm9taXNlIiwidG8iLCJpc0NvbW1hbmRSZWFkT25seSIsImlzUmVhZE9ubHkiLCJleGlzdHMiLCJoYXNGbGFnIiwidGFyZ2V0U2xvdCIsInNsb3QiLCJnZXRTbG90IiwidHRsIiwiaGFzIiwiYWRkIiwicGFydGlhbFRyeSIsInRyeUNvbm5lY3Rpb24iLCJoYW5kbGVFcnJvciIsIm1vdmVkIiwiTnVtYmVyIiwiam9pbiIsImZpbmRPckNyZWF0ZSIsIm5hdE1hcHBlciIsImFzayIsIm1hcHBlZCIsInRyeWFnYWluIiwiY2x1c3RlckRvd24iLCJjb25uZWN0aW9uQ2xvc2VkIiwibWF4UmVkaXJlY3Rpb25zIiwicmVkaXJlY3Rpb25FcnJvciIsInJhbmRvbSIsImFza2luZyIsIkFib3J0RXJyb3IiLCJjaGVja0ZsYWciLCJzdWIiLCJnZXRSZXNwb25zaWJsZVN1YnNjcmliZXIiLCJhZGRDaGFubmVscyIsImdldEtleXMiLCJyZW1vdmVDaGFubmVscyIsImdldEluc3RhbmNlIiwibm9kZUtleXMiLCJnZXRJbnN0YW5jZUJ5S2V5IiwiaXNBcnJheSIsInNhbXBsZSIsImdldFNhbXBsZUluc3RhbmNlIiwiZW5hYmxlT2ZmbGluZVF1ZXVlIiwic3NjYW5TdHJlYW0iLCJjcmVhdGVTY2FuU3RyZWFtIiwic3NjYW5CdWZmZXJTdHJlYW0iLCJoc2NhblN0cmVhbSIsImhzY2FuQnVmZmVyU3RyZWFtIiwienNjYW5TdHJlYW0iLCJ6c2NhbkJ1ZmZlclN0cmVhbSIsImhhbmRsZXJzIiwiZXJydiIsInNwbGl0IiwidGltZW91dCIsInJldHJ5RGVsYXlPbk1vdmVkIiwicmV0cnlEZWxheU9uVHJ5QWdhaW4iLCJyZXRyeURlbGF5T25DbHVzdGVyRG93biIsInJldHJ5RGVsYXlPbkZhaWxvdmVyIiwicmVzZXRPZmZsaW5lUXVldWUiLCJzbG90c1RpbWVyIiwic2xvdHNSZWZyZXNoSW50ZXJ2YWwiLCJuZXh0Um91bmQiLCJzZXRUaW1lb3V0IiwicHJvY2VzcyIsIm5leHRUaWNrIiwicmVhc29uIiwiX2EiLCJyZXRyeURlbGF5IiwiY2x1c3RlclJldHJ5U3RyYXRlZ3kiLCJzdWJzY3JpYmVyR3JvdXBFbWl0dGVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZmx1c2hRdWV1ZSIsIml0ZW0iLCJzaGlmdCIsIm5vZGVLZXkiLCJuYXRNYXAiLCJub2RlS2V5VG9SZWRpc09wdGlvbnMiLCJkdXBsaWNhdGVkQ29ubmVjdGlvbiIsInJldHJ5U3RyYXRlZ3kiLCJjb25uZWN0aW9uTmFtZSIsImdldENvbm5lY3Rpb25OYW1lIiwiY2x1c3RlciIsInJlc3VsdCIsImkiLCJpdGVtcyIsInNsb3RSYW5nZVN0YXJ0Iiwic2xvdFJhbmdlRW5kIiwia2V5cyIsImoiLCJyZWFkT25seSIsImNyZWF0ZSIsInRhcmdldCIsInNsb3RzUmVmcmVzaFRpbWVvdXQiLCJjIiwicmVzIiwic3RhdGUiLCJsaW5lcyIsInBhcnRzIiwicmVzb2x2ZVNydiIsImhvc3RuYW1lIiwicmVjb3JkcyIsInNlbGYiLCJncm91cGVkUmVjb3JkcyIsImdyb3VwU3J2UmVjb3JkcyIsInNvcnRlZEtleXMiLCJzb3J0IiwiYSIsImIiLCJwYXJzZUludCIsInRyeUZpcnN0T25lIiwiZ3JvdXAiLCJyZWNvcmQiLCJ3ZWlnaHRTcnZSZWNvcmRzIiwiZG5zTG9va3VwIiwiYWRkcmVzcyIsIm5vcm1hbGl6ZU5vZGVPcHRpb25zIiwiaG9zdG5hbWVzIiwiZ2V0VW5pcXVlSG9zdG5hbWVzRnJvbU9wdGlvbnMiLCJjb25maWdzIiwidXNlU1JWUmVjb3JkcyIsImhvc3RuYW1lVG9Db25maWciLCJ6aXBNYXAiLCJjb25maWciLCJnZXQiLCJvYmplY3RNb2RlIiwicmVmcmVzaFNsb3RzQ2FjaGVDYWxsYmFjayIsImRlbGF5IiwiZXZlbnQiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhZGRUcmFuc2FjdGlvblN1cHBvcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/cluster/util.js":
/*!****************************************************!*\
  !*** ./node_modules/ioredis/built/cluster/util.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getConnectionName = exports.weightSrvRecords = exports.groupSrvRecords = exports.getUniqueHostnamesFromOptions = exports.normalizeNodeOptions = exports.nodeKeyToRedisOptions = exports.getNodeKey = void 0;\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction getNodeKey(node) {\n    node.port = node.port || 6379;\n    node.host = node.host || \"127.0.0.1\";\n    return node.host + \":\" + node.port;\n}\nexports.getNodeKey = getNodeKey;\nfunction nodeKeyToRedisOptions(nodeKey) {\n    const portIndex = nodeKey.lastIndexOf(\":\");\n    if (portIndex === -1) {\n        throw new Error(`Invalid node key ${nodeKey}`);\n    }\n    return {\n        host: nodeKey.slice(0, portIndex),\n        port: Number(nodeKey.slice(portIndex + 1))\n    };\n}\nexports.nodeKeyToRedisOptions = nodeKeyToRedisOptions;\nfunction normalizeNodeOptions(nodes) {\n    return nodes.map((node)=>{\n        const options = {};\n        if (typeof node === \"object\") {\n            Object.assign(options, node);\n        } else if (typeof node === \"string\") {\n            Object.assign(options, (0, utils_1.parseURL)(node));\n        } else if (typeof node === \"number\") {\n            options.port = node;\n        } else {\n            throw new Error(\"Invalid argument \" + node);\n        }\n        if (typeof options.port === \"string\") {\n            options.port = parseInt(options.port, 10);\n        }\n        // Cluster mode only support db 0\n        delete options.db;\n        if (!options.port) {\n            options.port = 6379;\n        }\n        if (!options.host) {\n            options.host = \"127.0.0.1\";\n        }\n        return (0, utils_1.resolveTLSProfile)(options);\n    });\n}\nexports.normalizeNodeOptions = normalizeNodeOptions;\nfunction getUniqueHostnamesFromOptions(nodes) {\n    const uniqueHostsMap = {};\n    nodes.forEach((node)=>{\n        uniqueHostsMap[node.host] = true;\n    });\n    return Object.keys(uniqueHostsMap).filter((host)=>!(0, net_1.isIP)(host));\n}\nexports.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;\nfunction groupSrvRecords(records) {\n    const recordsByPriority = {};\n    for (const record of records){\n        if (!recordsByPriority.hasOwnProperty(record.priority)) {\n            recordsByPriority[record.priority] = {\n                totalWeight: record.weight,\n                records: [\n                    record\n                ]\n            };\n        } else {\n            recordsByPriority[record.priority].totalWeight += record.weight;\n            recordsByPriority[record.priority].records.push(record);\n        }\n    }\n    return recordsByPriority;\n}\nexports.groupSrvRecords = groupSrvRecords;\nfunction weightSrvRecords(recordsGroup) {\n    if (recordsGroup.records.length === 1) {\n        recordsGroup.totalWeight = 0;\n        return recordsGroup.records.shift();\n    }\n    // + `recordsGroup.records.length` to support `weight` 0\n    const random = Math.floor(Math.random() * (recordsGroup.totalWeight + recordsGroup.records.length));\n    let total = 0;\n    for (const [i, record] of recordsGroup.records.entries()){\n        total += 1 + record.weight;\n        if (total > random) {\n            recordsGroup.totalWeight -= record.weight;\n            recordsGroup.records.splice(i, 1);\n            return record;\n        }\n    }\n}\nexports.weightSrvRecords = weightSrvRecords;\nfunction getConnectionName(component, nodeConnectionName) {\n    const prefix = `ioredis-cluster(${component})`;\n    return nodeConnectionName ? `${prefix}:${nodeConnectionName}` : prefix;\n}\nexports.getConnectionName = getConnectionName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHlCQUF5QixHQUFHQSx3QkFBd0IsR0FBR0EsdUJBQXVCLEdBQUdBLHFDQUFxQyxHQUFHQSw0QkFBNEIsR0FBR0EsNkJBQTZCLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDbE4sTUFBTVMsVUFBVUMsbUJBQU9BLENBQUMsbUVBQVU7QUFDbEMsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsU0FBU0YsV0FBV0ksSUFBSTtJQUNwQkEsS0FBS0MsSUFBSSxHQUFHRCxLQUFLQyxJQUFJLElBQUk7SUFDekJELEtBQUtFLElBQUksR0FBR0YsS0FBS0UsSUFBSSxJQUFJO0lBQ3pCLE9BQU9GLEtBQUtFLElBQUksR0FBRyxNQUFNRixLQUFLQyxJQUFJO0FBQ3RDO0FBQ0FiLGtCQUFrQixHQUFHUTtBQUNyQixTQUFTRCxzQkFBc0JRLE9BQU87SUFDbEMsTUFBTUMsWUFBWUQsUUFBUUUsV0FBVyxDQUFDO0lBQ3RDLElBQUlELGNBQWMsQ0FBQyxHQUFHO1FBQ2xCLE1BQU0sSUFBSUUsTUFBTSxDQUFDLGlCQUFpQixFQUFFSCxRQUFRLENBQUM7SUFDakQ7SUFDQSxPQUFPO1FBQ0hELE1BQU1DLFFBQVFJLEtBQUssQ0FBQyxHQUFHSDtRQUN2QkgsTUFBTU8sT0FBT0wsUUFBUUksS0FBSyxDQUFDSCxZQUFZO0lBQzNDO0FBQ0o7QUFDQWhCLDZCQUE2QixHQUFHTztBQUNoQyxTQUFTRCxxQkFBcUJlLEtBQUs7SUFDL0IsT0FBT0EsTUFBTUMsR0FBRyxDQUFDLENBQUNWO1FBQ2QsTUFBTVcsVUFBVSxDQUFDO1FBQ2pCLElBQUksT0FBT1gsU0FBUyxVQUFVO1lBQzFCZCxPQUFPMEIsTUFBTSxDQUFDRCxTQUFTWDtRQUMzQixPQUNLLElBQUksT0FBT0EsU0FBUyxV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QUNBdEQseUJBQXlCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvZHVjdC1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL3V0aWwuanM/ZGJmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Q29ubmVjdGlvbk5hbWUgPSBleHBvcnRzLndlaWdodFNydlJlY29yZHMgPSBleHBvcnRzLmdyb3VwU3J2UmVjb3JkcyA9IGV4cG9ydHMuZ2V0VW5pcXVlSG9zdG5hbWVzRnJvbU9wdGlvbnMgPSBleHBvcnRzLm5vcm1hbGl6ZU5vZGVPcHRpb25zID0gZXhwb3J0cy5ub2RlS2V5VG9SZWRpc09wdGlvbnMgPSBleHBvcnRzLmdldE5vZGVLZXkgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuZnVuY3Rpb24gZ2V0Tm9kZUtleShub2RlKSB7XG4gICAgbm9kZS5wb3J0ID0gbm9kZS5wb3J0IHx8IDYzNzk7XG4gICAgbm9kZS5ob3N0ID0gbm9kZS5ob3N0IHx8IFwiMTI3LjAuMC4xXCI7XG4gICAgcmV0dXJuIG5vZGUuaG9zdCArIFwiOlwiICsgbm9kZS5wb3J0O1xufVxuZXhwb3J0cy5nZXROb2RlS2V5ID0gZ2V0Tm9kZUtleTtcbmZ1bmN0aW9uIG5vZGVLZXlUb1JlZGlzT3B0aW9ucyhub2RlS2V5KSB7XG4gICAgY29uc3QgcG9ydEluZGV4ID0gbm9kZUtleS5sYXN0SW5kZXhPZihcIjpcIik7XG4gICAgaWYgKHBvcnRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5vZGUga2V5ICR7bm9kZUtleX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaG9zdDogbm9kZUtleS5zbGljZSgwLCBwb3J0SW5kZXgpLFxuICAgICAgICBwb3J0OiBOdW1iZXIobm9kZUtleS5zbGljZShwb3J0SW5kZXggKyAxKSksXG4gICAgfTtcbn1cbmV4cG9ydHMubm9kZUtleVRvUmVkaXNPcHRpb25zID0gbm9kZUtleVRvUmVkaXNPcHRpb25zO1xuZnVuY3Rpb24gbm9ybWFsaXplTm9kZU9wdGlvbnMobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsICgwLCB1dGlsc18xLnBhcnNlVVJMKShub2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucG9ydCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IFwiICsgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucG9ydCA9IHBhcnNlSW50KG9wdGlvbnMucG9ydCwgMTApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsdXN0ZXIgbW9kZSBvbmx5IHN1cHBvcnQgZGIgMFxuICAgICAgICBkZWxldGUgb3B0aW9ucy5kYjtcbiAgICAgICAgaWYgKCFvcHRpb25zLnBvcnQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucG9ydCA9IDYzNzk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLmhvc3QpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaG9zdCA9IFwiMTI3LjAuMC4xXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnJlc29sdmVUTFNQcm9maWxlKShvcHRpb25zKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubm9ybWFsaXplTm9kZU9wdGlvbnMgPSBub3JtYWxpemVOb2RlT3B0aW9ucztcbmZ1bmN0aW9uIGdldFVuaXF1ZUhvc3RuYW1lc0Zyb21PcHRpb25zKG5vZGVzKSB7XG4gICAgY29uc3QgdW5pcXVlSG9zdHNNYXAgPSB7fTtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIHVuaXF1ZUhvc3RzTWFwW25vZGUuaG9zdF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh1bmlxdWVIb3N0c01hcCkuZmlsdGVyKChob3N0KSA9PiAhKDAsIG5ldF8xLmlzSVApKGhvc3QpKTtcbn1cbmV4cG9ydHMuZ2V0VW5pcXVlSG9zdG5hbWVzRnJvbU9wdGlvbnMgPSBnZXRVbmlxdWVIb3N0bmFtZXNGcm9tT3B0aW9ucztcbmZ1bmN0aW9uIGdyb3VwU3J2UmVjb3JkcyhyZWNvcmRzKSB7XG4gICAgY29uc3QgcmVjb3Jkc0J5UHJpb3JpdHkgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgIGlmICghcmVjb3Jkc0J5UHJpb3JpdHkuaGFzT3duUHJvcGVydHkocmVjb3JkLnByaW9yaXR5KSkge1xuICAgICAgICAgICAgcmVjb3Jkc0J5UHJpb3JpdHlbcmVjb3JkLnByaW9yaXR5XSA9IHtcbiAgICAgICAgICAgICAgICB0b3RhbFdlaWdodDogcmVjb3JkLndlaWdodCxcbiAgICAgICAgICAgICAgICByZWNvcmRzOiBbcmVjb3JkXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWNvcmRzQnlQcmlvcml0eVtyZWNvcmQucHJpb3JpdHldLnRvdGFsV2VpZ2h0ICs9IHJlY29yZC53ZWlnaHQ7XG4gICAgICAgICAgICByZWNvcmRzQnlQcmlvcml0eVtyZWNvcmQucHJpb3JpdHldLnJlY29yZHMucHVzaChyZWNvcmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWNvcmRzQnlQcmlvcml0eTtcbn1cbmV4cG9ydHMuZ3JvdXBTcnZSZWNvcmRzID0gZ3JvdXBTcnZSZWNvcmRzO1xuZnVuY3Rpb24gd2VpZ2h0U3J2UmVjb3JkcyhyZWNvcmRzR3JvdXApIHtcbiAgICBpZiAocmVjb3Jkc0dyb3VwLnJlY29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJlY29yZHNHcm91cC50b3RhbFdlaWdodCA9IDA7XG4gICAgICAgIHJldHVybiByZWNvcmRzR3JvdXAucmVjb3Jkcy5zaGlmdCgpO1xuICAgIH1cbiAgICAvLyArIGByZWNvcmRzR3JvdXAucmVjb3Jkcy5sZW5ndGhgIHRvIHN1cHBvcnQgYHdlaWdodGAgMFxuICAgIGNvbnN0IHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChyZWNvcmRzR3JvdXAudG90YWxXZWlnaHQgKyByZWNvcmRzR3JvdXAucmVjb3Jkcy5sZW5ndGgpKTtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAoY29uc3QgW2ksIHJlY29yZF0gb2YgcmVjb3Jkc0dyb3VwLnJlY29yZHMuZW50cmllcygpKSB7XG4gICAgICAgIHRvdGFsICs9IDEgKyByZWNvcmQud2VpZ2h0O1xuICAgICAgICBpZiAodG90YWwgPiByYW5kb20pIHtcbiAgICAgICAgICAgIHJlY29yZHNHcm91cC50b3RhbFdlaWdodCAtPSByZWNvcmQud2VpZ2h0O1xuICAgICAgICAgICAgcmVjb3Jkc0dyb3VwLnJlY29yZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMud2VpZ2h0U3J2UmVjb3JkcyA9IHdlaWdodFNydlJlY29yZHM7XG5mdW5jdGlvbiBnZXRDb25uZWN0aW9uTmFtZShjb21wb25lbnQsIG5vZGVDb25uZWN0aW9uTmFtZSkge1xuICAgIGNvbnN0IHByZWZpeCA9IGBpb3JlZGlzLWNsdXN0ZXIoJHtjb21wb25lbnR9KWA7XG4gICAgcmV0dXJuIG5vZGVDb25uZWN0aW9uTmFtZSA/IGAke3ByZWZpeH06JHtub2RlQ29ubmVjdGlvbk5hbWV9YCA6IHByZWZpeDtcbn1cbmV4cG9ydHMuZ2V0Q29ubmVjdGlvbk5hbWUgPSBnZXRDb25uZWN0aW9uTmFtZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldENvbm5lY3Rpb25OYW1lIiwid2VpZ2h0U3J2UmVjb3JkcyIsImdyb3VwU3J2UmVjb3JkcyIsImdldFVuaXF1ZUhvc3RuYW1lc0Zyb21PcHRpb25zIiwibm9ybWFsaXplTm9kZU9wdGlvbnMiLCJub2RlS2V5VG9SZWRpc09wdGlvbnMiLCJnZXROb2RlS2V5IiwidXRpbHNfMSIsInJlcXVpcmUiLCJuZXRfMSIsIm5vZGUiLCJwb3J0IiwiaG9zdCIsIm5vZGVLZXkiLCJwb3J0SW5kZXgiLCJsYXN0SW5kZXhPZiIsIkVycm9yIiwic2xpY2UiLCJOdW1iZXIiLCJub2RlcyIsIm1hcCIsIm9wdGlvbnMiLCJhc3NpZ24iLCJwYXJzZVVSTCIsInBhcnNlSW50IiwiZGIiLCJyZXNvbHZlVExTUHJvZmlsZSIsInVuaXF1ZUhvc3RzTWFwIiwiZm9yRWFjaCIsImtleXMiLCJmaWx0ZXIiLCJpc0lQIiwicmVjb3JkcyIsInJlY29yZHNCeVByaW9yaXR5IiwicmVjb3JkIiwiaGFzT3duUHJvcGVydHkiLCJwcmlvcml0eSIsInRvdGFsV2VpZ2h0Iiwid2VpZ2h0IiwicHVzaCIsInJlY29yZHNHcm91cCIsImxlbmd0aCIsInNoaWZ0IiwicmFuZG9tIiwiTWF0aCIsImZsb29yIiwidG90YWwiLCJpIiwiZW50cmllcyIsInNwbGljZSIsImNvbXBvbmVudCIsIm5vZGVDb25uZWN0aW9uTmFtZSIsInByZWZpeCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/cluster/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js":
/*!********************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/AbstractConnector.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst debug = (0, utils_1.Debug)(\"AbstractConnector\");\nclass AbstractConnector {\n    constructor(disconnectTimeout){\n        this.connecting = false;\n        this.disconnectTimeout = disconnectTimeout;\n    }\n    check(info) {\n        return true;\n    }\n    disconnect() {\n        this.connecting = false;\n        if (this.stream) {\n            const stream = this.stream; // Make sure callbacks refer to the same instance\n            const timeout = setTimeout(()=>{\n                debug(\"stream %s:%s still open, destroying it\", stream.remoteAddress, stream.remotePort);\n                stream.destroy();\n            }, this.disconnectTimeout);\n            stream.on(\"close\", ()=>clearTimeout(timeout));\n            stream.end();\n        }\n    }\n}\nexports[\"default\"] = AbstractConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL0Fic3RyYWN0Q29ubmVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLG1FQUFVO0FBQ2xDLE1BQU1DLFFBQVEsQ0FBQyxHQUFHRixRQUFRRyxLQUFLLEVBQUU7QUFDakMsTUFBTUM7SUFDRkMsWUFBWUMsaUJBQWlCLENBQUU7UUFDM0IsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDRCxpQkFBaUIsR0FBR0E7SUFDN0I7SUFDQUUsTUFBTUMsSUFBSSxFQUFFO1FBQ1IsT0FBTztJQUNYO0lBQ0FDLGFBQWE7UUFDVCxJQUFJLENBQUNILFVBQVUsR0FBRztRQUNsQixJQUFJLElBQUksQ0FBQ0ksTUFBTSxFQUFFO1lBQ2IsTUFBTUEsU0FBUyxJQUFJLENBQUNBLE1BQU0sRUFBRSxpREFBaUQ7WUFDN0UsTUFBTUMsVUFBVUMsV0FBVztnQkFDdkJYLE1BQU0sMENBQTBDUyxPQUFPRyxhQUFhLEVBQUVILE9BQU9JLFVBQVU7Z0JBQ3ZGSixPQUFPSyxPQUFPO1lBQ2xCLEdBQUcsSUFBSSxDQUFDVixpQkFBaUI7WUFDekJLLE9BQU9NLEVBQUUsQ0FBQyxTQUFTLElBQU1DLGFBQWFOO1lBQ3RDRCxPQUFPUSxHQUFHO1FBQ2Q7SUFDSjtBQUNKO0FBQ0FyQixrQkFBZSxHQUFHTSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9BYnN0cmFjdENvbm5lY3Rvci5qcz8yNzk2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiQWJzdHJhY3RDb25uZWN0b3JcIik7XG5jbGFzcyBBYnN0cmFjdENvbm5lY3RvciB7XG4gICAgY29uc3RydWN0b3IoZGlzY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFRpbWVvdXQgPSBkaXNjb25uZWN0VGltZW91dDtcbiAgICB9XG4gICAgY2hlY2soaW5mbykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW07IC8vIE1ha2Ugc3VyZSBjYWxsYmFja3MgcmVmZXIgdG8gdGhlIHNhbWUgaW5zdGFuY2VcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInN0cmVhbSAlczolcyBzdGlsbCBvcGVuLCBkZXN0cm95aW5nIGl0XCIsIHN0cmVhbS5yZW1vdGVBZGRyZXNzLCBzdHJlYW0ucmVtb3RlUG9ydCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0sIHRoaXMuZGlzY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgc3RyZWFtLm9uKFwiY2xvc2VcIiwgKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpKTtcbiAgICAgICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0Q29ubmVjdG9yO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXRpbHNfMSIsInJlcXVpcmUiLCJkZWJ1ZyIsIkRlYnVnIiwiQWJzdHJhY3RDb25uZWN0b3IiLCJjb25zdHJ1Y3RvciIsImRpc2Nvbm5lY3RUaW1lb3V0IiwiY29ubmVjdGluZyIsImNoZWNrIiwiaW5mbyIsImRpc2Nvbm5lY3QiLCJzdHJlYW0iLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsInJlbW90ZUFkZHJlc3MiLCJyZW1vdGVQb3J0IiwiZGVzdHJveSIsIm9uIiwiY2xlYXJUaW1lb3V0IiwiZW5kIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FailoverDetector = void 0;\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst debug = (0, utils_1.Debug)(\"FailoverDetector\");\nconst CHANNEL_NAME = \"+switch-master\";\nclass FailoverDetector {\n    // sentinels can't be used for regular commands after this\n    constructor(connector, sentinels){\n        this.isDisconnected = false;\n        this.connector = connector;\n        this.sentinels = sentinels;\n    }\n    cleanup() {\n        this.isDisconnected = true;\n        for (const sentinel of this.sentinels){\n            sentinel.client.disconnect();\n        }\n    }\n    async subscribe() {\n        debug(\"Starting FailoverDetector\");\n        const promises = [];\n        for (const sentinel of this.sentinels){\n            const promise = sentinel.client.subscribe(CHANNEL_NAME).catch((err)=>{\n                debug(\"Failed to subscribe to failover messages on sentinel %s:%s (%s)\", sentinel.address.host || \"127.0.0.1\", sentinel.address.port || 26739, err.message);\n            });\n            promises.push(promise);\n            sentinel.client.on(\"message\", (channel)=>{\n                if (!this.isDisconnected && channel === CHANNEL_NAME) {\n                    this.disconnect();\n                }\n            });\n        }\n        await Promise.all(promises);\n    }\n    disconnect() {\n        // Avoid disconnecting more than once per failover.\n        // A new FailoverDetector will be created after reconnecting.\n        this.isDisconnected = true;\n        debug(\"Failover detected, disconnecting\");\n        // Will call this.cleanup()\n        this.connector.disconnect();\n    }\n}\nexports.FailoverDetector = FailoverDetector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1NlbnRpbmVsQ29ubmVjdG9yL0ZhaWxvdmVyRGV0ZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHLEtBQUs7QUFDaEMsTUFBTUcsVUFBVUMsbUJBQU9BLENBQUMsc0VBQWE7QUFDckMsTUFBTUMsUUFBUSxDQUFDLEdBQUdGLFFBQVFHLEtBQUssRUFBRTtBQUNqQyxNQUFNQyxlQUFlO0FBQ3JCLE1BQU1MO0lBQ0YsMERBQTBEO0lBQzFETSxZQUFZQyxTQUFTLEVBQUVDLFNBQVMsQ0FBRTtRQUM5QixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNGLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO0lBQ3JCO0lBQ0FFLFVBQVU7UUFDTixJQUFJLENBQUNELGNBQWMsR0FBRztRQUN0QixLQUFLLE1BQU1FLFlBQVksSUFBSSxDQUFDSCxTQUFTLENBQUU7WUFDbkNHLFNBQVNDLE1BQU0sQ0FBQ0MsVUFBVTtRQUM5QjtJQUNKO0lBQ0EsTUFBTUMsWUFBWTtRQUNkWCxNQUFNO1FBQ04sTUFBTVksV0FBVyxFQUFFO1FBQ25CLEtBQUssTUFBTUosWUFBWSxJQUFJLENBQUNILFNBQVMsQ0FBRTtZQUNuQyxNQUFNUSxVQUFVTCxTQUFTQyxNQUFNLENBQUNFLFNBQVMsQ0FBQ1QsY0FBY1ksS0FBSyxDQUFDLENBQUNDO2dCQUMzRGYsTUFBTSxtRUFBbUVRLFNBQVNRLE9BQU8sQ0FBQ0MsSUFBSSxJQUFJLGFBQWFULFNBQVNRLE9BQU8sQ0FBQ0UsSUFBSSxJQUFJLE9BQU9ILElBQUlJLE9BQU87WUFDOUo7WUFDQVAsU0FBU1EsSUFBSSxDQUFDUDtZQUNkTCxTQUFTQyxNQUFNLENBQUNZLEVBQUUsQ0FBQyxXQUFXLENBQUNDO2dCQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDaEIsY0FBYyxJQUFJZ0IsWUFBWXBCLGNBQWM7b0JBQ2xELElBQUksQ0FBQ1EsVUFBVTtnQkFDbkI7WUFDSjtRQUNKO1FBQ0EsTUFBTWEsUUFBUUMsR0FBRyxDQUFDWjtJQUN0QjtJQUNBRixhQUFhO1FBQ1QsbURBQW1EO1FBQ25ELDZEQUE2RDtRQUM3RCxJQUFJLENBQUNKLGNBQWMsR0FBRztRQUN0Qk4sTUFBTTtRQUNOLDJCQUEyQjtRQUMzQixJQUFJLENBQUNJLFNBQVMsQ0FBQ00sVUFBVTtJQUM3QjtBQUNKO0FBQ0FmLHdCQUF3QixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9TZW50aW5lbENvbm5lY3Rvci9GYWlsb3ZlckRldGVjdG9yLmpzP2UxNGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZhaWxvdmVyRGV0ZWN0b3IgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJGYWlsb3ZlckRldGVjdG9yXCIpO1xuY29uc3QgQ0hBTk5FTF9OQU1FID0gXCIrc3dpdGNoLW1hc3RlclwiO1xuY2xhc3MgRmFpbG92ZXJEZXRlY3RvciB7XG4gICAgLy8gc2VudGluZWxzIGNhbid0IGJlIHVzZWQgZm9yIHJlZ3VsYXIgY29tbWFuZHMgYWZ0ZXIgdGhpc1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rvciwgc2VudGluZWxzKSB7XG4gICAgICAgIHRoaXMuaXNEaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBjb25uZWN0b3I7XG4gICAgICAgIHRoaXMuc2VudGluZWxzID0gc2VudGluZWxzO1xuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICB0aGlzLmlzRGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBzZW50aW5lbCBvZiB0aGlzLnNlbnRpbmVscykge1xuICAgICAgICAgICAgc2VudGluZWwuY2xpZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzdWJzY3JpYmUoKSB7XG4gICAgICAgIGRlYnVnKFwiU3RhcnRpbmcgRmFpbG92ZXJEZXRlY3RvclwiKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzZW50aW5lbCBvZiB0aGlzLnNlbnRpbmVscykge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHNlbnRpbmVsLmNsaWVudC5zdWJzY3JpYmUoQ0hBTk5FTF9OQU1FKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJGYWlsZWQgdG8gc3Vic2NyaWJlIHRvIGZhaWxvdmVyIG1lc3NhZ2VzIG9uIHNlbnRpbmVsICVzOiVzICglcylcIiwgc2VudGluZWwuYWRkcmVzcy5ob3N0IHx8IFwiMTI3LjAuMC4xXCIsIHNlbnRpbmVsLmFkZHJlc3MucG9ydCB8fCAyNjczOSwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgc2VudGluZWwuY2xpZW50Lm9uKFwibWVzc2FnZVwiLCAoY2hhbm5lbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0Rpc2Nvbm5lY3RlZCAmJiBjaGFubmVsID09PSBDSEFOTkVMX05BTUUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICAvLyBBdm9pZCBkaXNjb25uZWN0aW5nIG1vcmUgdGhhbiBvbmNlIHBlciBmYWlsb3Zlci5cbiAgICAgICAgLy8gQSBuZXcgRmFpbG92ZXJEZXRlY3RvciB3aWxsIGJlIGNyZWF0ZWQgYWZ0ZXIgcmVjb25uZWN0aW5nLlxuICAgICAgICB0aGlzLmlzRGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgZGVidWcoXCJGYWlsb3ZlciBkZXRlY3RlZCwgZGlzY29ubmVjdGluZ1wiKTtcbiAgICAgICAgLy8gV2lsbCBjYWxsIHRoaXMuY2xlYW51cCgpXG4gICAgICAgIHRoaXMuY29ubmVjdG9yLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG59XG5leHBvcnRzLkZhaWxvdmVyRGV0ZWN0b3IgPSBGYWlsb3ZlckRldGVjdG9yO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRmFpbG92ZXJEZXRlY3RvciIsInV0aWxzXzEiLCJyZXF1aXJlIiwiZGVidWciLCJEZWJ1ZyIsIkNIQU5ORUxfTkFNRSIsImNvbnN0cnVjdG9yIiwiY29ubmVjdG9yIiwic2VudGluZWxzIiwiaXNEaXNjb25uZWN0ZWQiLCJjbGVhbnVwIiwic2VudGluZWwiLCJjbGllbnQiLCJkaXNjb25uZWN0Iiwic3Vic2NyaWJlIiwicHJvbWlzZXMiLCJwcm9taXNlIiwiY2F0Y2giLCJlcnIiLCJhZGRyZXNzIiwiaG9zdCIsInBvcnQiLCJtZXNzYWdlIiwicHVzaCIsIm9uIiwiY2hhbm5lbCIsIlByb21pc2UiLCJhbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction isSentinelEql(a, b) {\n    return (a.host || \"127.0.0.1\") === (b.host || \"127.0.0.1\") && (a.port || 26379) === (b.port || 26379);\n}\nclass SentinelIterator {\n    constructor(sentinels){\n        this.cursor = 0;\n        this.sentinels = sentinels.slice(0);\n    }\n    next() {\n        const done = this.cursor >= this.sentinels.length;\n        return {\n            done,\n            value: done ? undefined : this.sentinels[this.cursor++]\n        };\n    }\n    reset(moveCurrentEndpointToFirst) {\n        if (moveCurrentEndpointToFirst && this.sentinels.length > 1 && this.cursor !== 1) {\n            this.sentinels.unshift(...this.sentinels.splice(this.cursor - 1));\n        }\n        this.cursor = 0;\n    }\n    add(sentinel) {\n        for(let i = 0; i < this.sentinels.length; i++){\n            if (isSentinelEql(sentinel, this.sentinels[i])) {\n                return false;\n            }\n        }\n        this.sentinels.push(sentinel);\n        return true;\n    }\n    toString() {\n        return `${JSON.stringify(this.sentinels)} @${this.cursor}`;\n    }\n}\nexports[\"default\"] = SentinelIterator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1NlbnRpbmVsQ29ubmVjdG9yL1NlbnRpbmVsSXRlcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsU0FBU0MsY0FBY0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ3ZCLE9BQVEsQ0FBQ0QsRUFBRUUsSUFBSSxJQUFJLFdBQVUsTUFBUUQsQ0FBQUEsRUFBRUMsSUFBSSxJQUFJLFdBQVUsS0FDckQsQ0FBQ0YsRUFBRUcsSUFBSSxJQUFJLEtBQUksTUFBUUYsQ0FBQUEsRUFBRUUsSUFBSSxJQUFJLEtBQUk7QUFDN0M7QUFDQSxNQUFNQztJQUNGQyxZQUFZQyxTQUFTLENBQUU7UUFDbkIsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNELFNBQVMsR0FBR0EsVUFBVUUsS0FBSyxDQUFDO0lBQ3JDO0lBQ0FDLE9BQU87UUFDSCxNQUFNQyxPQUFPLElBQUksQ0FBQ0gsTUFBTSxJQUFJLElBQUksQ0FBQ0QsU0FBUyxDQUFDSyxNQUFNO1FBQ2pELE9BQU87WUFBRUQ7WUFBTVosT0FBT1ksT0FBT0UsWUFBWSxJQUFJLENBQUNOLFNBQVMsQ0FBQyxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUFDO0lBQzNFO0lBQ0FNLE1BQU1DLDBCQUEwQixFQUFFO1FBQzlCLElBQUlBLDhCQUNBLElBQUksQ0FBQ1IsU0FBUyxDQUFDSyxNQUFNLEdBQUcsS0FDeEIsSUFBSSxDQUFDSixNQUFNLEtBQUssR0FBRztZQUNuQixJQUFJLENBQUNELFNBQVMsQ0FBQ1MsT0FBTyxJQUFJLElBQUksQ0FBQ1QsU0FBUyxDQUFDVSxNQUFNLENBQUMsSUFBSSxDQUFDVCxNQUFNLEdBQUc7UUFDbEU7UUFDQSxJQUFJLENBQUNBLE1BQU0sR0FBRztJQUNsQjtJQUNBVSxJQUFJQyxRQUFRLEVBQUU7UUFDVixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNiLFNBQVMsQ0FBQ0ssTUFBTSxFQUFFUSxJQUFLO1lBQzVDLElBQUlwQixjQUFjbUIsVUFBVSxJQUFJLENBQUNaLFNBQVMsQ0FBQ2EsRUFBRSxHQUFHO2dCQUM1QyxPQUFPO1lBQ1g7UUFDSjtRQUNBLElBQUksQ0FBQ2IsU0FBUyxDQUFDYyxJQUFJLENBQUNGO1FBQ3BCLE9BQU87SUFDWDtJQUNBRyxXQUFXO1FBQ1AsT0FBTyxDQUFDLEVBQUVDLEtBQUtDLFNBQVMsQ0FBQyxJQUFJLENBQUNqQixTQUFTLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQ0MsTUFBTSxDQUFDLENBQUM7SUFDOUQ7QUFDSjtBQUNBVixrQkFBZSxHQUFHTyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9TZW50aW5lbENvbm5lY3Rvci9TZW50aW5lbEl0ZXJhdG9yLmpzP2QyMWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpc1NlbnRpbmVsRXFsKGEsIGIpIHtcbiAgICByZXR1cm4gKChhLmhvc3QgfHwgXCIxMjcuMC4wLjFcIikgPT09IChiLmhvc3QgfHwgXCIxMjcuMC4wLjFcIikgJiZcbiAgICAgICAgKGEucG9ydCB8fCAyNjM3OSkgPT09IChiLnBvcnQgfHwgMjYzNzkpKTtcbn1cbmNsYXNzIFNlbnRpbmVsSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHNlbnRpbmVscykge1xuICAgICAgICB0aGlzLmN1cnNvciA9IDA7XG4gICAgICAgIHRoaXMuc2VudGluZWxzID0gc2VudGluZWxzLnNsaWNlKDApO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBkb25lID0gdGhpcy5jdXJzb3IgPj0gdGhpcy5zZW50aW5lbHMubGVuZ3RoO1xuICAgICAgICByZXR1cm4geyBkb25lLCB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IHRoaXMuc2VudGluZWxzW3RoaXMuY3Vyc29yKytdIH07XG4gICAgfVxuICAgIHJlc2V0KG1vdmVDdXJyZW50RW5kcG9pbnRUb0ZpcnN0KSB7XG4gICAgICAgIGlmIChtb3ZlQ3VycmVudEVuZHBvaW50VG9GaXJzdCAmJlxuICAgICAgICAgICAgdGhpcy5zZW50aW5lbHMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgdGhpcy5jdXJzb3IgIT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuc2VudGluZWxzLnVuc2hpZnQoLi4udGhpcy5zZW50aW5lbHMuc3BsaWNlKHRoaXMuY3Vyc29yIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Vyc29yID0gMDtcbiAgICB9XG4gICAgYWRkKHNlbnRpbmVsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZW50aW5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpc1NlbnRpbmVsRXFsKHNlbnRpbmVsLCB0aGlzLnNlbnRpbmVsc1tpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW50aW5lbHMucHVzaChzZW50aW5lbCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke0pTT04uc3RyaW5naWZ5KHRoaXMuc2VudGluZWxzKX0gQCR7dGhpcy5jdXJzb3J9YDtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTZW50aW5lbEl0ZXJhdG9yO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNTZW50aW5lbEVxbCIsImEiLCJiIiwiaG9zdCIsInBvcnQiLCJTZW50aW5lbEl0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJzZW50aW5lbHMiLCJjdXJzb3IiLCJzbGljZSIsIm5leHQiLCJkb25lIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwicmVzZXQiLCJtb3ZlQ3VycmVudEVuZHBvaW50VG9GaXJzdCIsInVuc2hpZnQiLCJzcGxpY2UiLCJhZGQiLCJzZW50aW5lbCIsImkiLCJwdXNoIiwidG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/SentinelConnector/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SentinelIterator = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst SentinelIterator_1 = __webpack_require__(/*! ./SentinelIterator */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js\");\nexports.SentinelIterator = SentinelIterator_1.default;\nconst AbstractConnector_1 = __webpack_require__(/*! ../AbstractConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js\");\nconst Redis_1 = __webpack_require__(/*! ../../Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nconst FailoverDetector_1 = __webpack_require__(/*! ./FailoverDetector */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js\");\nconst debug = (0, utils_1.Debug)(\"SentinelConnector\");\nclass SentinelConnector extends AbstractConnector_1.default {\n    constructor(options){\n        super(options.disconnectTimeout);\n        this.options = options;\n        this.emitter = null;\n        this.failoverDetector = null;\n        if (!this.options.sentinels.length) {\n            throw new Error(\"Requires at least one sentinel to connect to.\");\n        }\n        if (!this.options.name) {\n            throw new Error(\"Requires the name of master.\");\n        }\n        this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);\n    }\n    check(info) {\n        const roleMatches = !info.role || this.options.role === info.role;\n        if (!roleMatches) {\n            debug(\"role invalid, expected %s, but got %s\", this.options.role, info.role);\n            // Start from the next item.\n            // Note that `reset` will move the cursor to the previous element,\n            // so we advance two steps here.\n            this.sentinelIterator.next();\n            this.sentinelIterator.next();\n            this.sentinelIterator.reset(true);\n        }\n        return roleMatches;\n    }\n    disconnect() {\n        super.disconnect();\n        if (this.failoverDetector) {\n            this.failoverDetector.cleanup();\n        }\n    }\n    connect(eventEmitter) {\n        this.connecting = true;\n        this.retryAttempts = 0;\n        let lastError;\n        const connectToNext = async ()=>{\n            const endpoint = this.sentinelIterator.next();\n            if (endpoint.done) {\n                this.sentinelIterator.reset(false);\n                const retryDelay = typeof this.options.sentinelRetryStrategy === \"function\" ? this.options.sentinelRetryStrategy(++this.retryAttempts) : null;\n                let errorMsg = typeof retryDelay !== \"number\" ? \"All sentinels are unreachable and retry is disabled.\" : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;\n                if (lastError) {\n                    errorMsg += ` Last error: ${lastError.message}`;\n                }\n                debug(errorMsg);\n                const error = new Error(errorMsg);\n                if (typeof retryDelay === \"number\") {\n                    eventEmitter(\"error\", error);\n                    await new Promise((resolve)=>setTimeout(resolve, retryDelay));\n                    return connectToNext();\n                } else {\n                    throw error;\n                }\n            }\n            let resolved = null;\n            let err = null;\n            try {\n                resolved = await this.resolve(endpoint.value);\n            } catch (error) {\n                err = error;\n            }\n            if (!this.connecting) {\n                throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);\n            }\n            const endpointAddress = endpoint.value.host + \":\" + endpoint.value.port;\n            if (resolved) {\n                debug(\"resolved: %s:%s from sentinel %s\", resolved.host, resolved.port, endpointAddress);\n                if (this.options.enableTLSForSentinelMode && this.options.tls) {\n                    Object.assign(resolved, this.options.tls);\n                    this.stream = (0, tls_1.connect)(resolved);\n                    this.stream.once(\"secureConnect\", this.initFailoverDetector.bind(this));\n                } else {\n                    this.stream = (0, net_1.createConnection)(resolved);\n                    this.stream.once(\"connect\", this.initFailoverDetector.bind(this));\n                }\n                this.stream.once(\"error\", (err)=>{\n                    this.firstError = err;\n                });\n                return this.stream;\n            } else {\n                const errorMsg = err ? \"failed to connect to sentinel \" + endpointAddress + \" because \" + err.message : \"connected to sentinel \" + endpointAddress + \" successfully, but got an invalid reply: \" + resolved;\n                debug(errorMsg);\n                eventEmitter(\"sentinelError\", new Error(errorMsg));\n                if (err) {\n                    lastError = err;\n                }\n                return connectToNext();\n            }\n        };\n        return connectToNext();\n    }\n    async updateSentinels(client) {\n        if (!this.options.updateSentinels) {\n            return;\n        }\n        const result = await client.sentinel(\"sentinels\", this.options.name);\n        if (!Array.isArray(result)) {\n            return;\n        }\n        result.map(utils_1.packObject).forEach((sentinel)=>{\n            const flags = sentinel.flags ? sentinel.flags.split(\",\") : [];\n            if (flags.indexOf(\"disconnected\") === -1 && sentinel.ip && sentinel.port) {\n                const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));\n                if (this.sentinelIterator.add(endpoint)) {\n                    debug(\"adding sentinel %s:%s\", endpoint.host, endpoint.port);\n                }\n            }\n        });\n        debug(\"Updated internal sentinels: %s\", this.sentinelIterator);\n    }\n    async resolveMaster(client) {\n        const result = await client.sentinel(\"get-master-addr-by-name\", this.options.name);\n        await this.updateSentinels(client);\n        return this.sentinelNatResolve(Array.isArray(result) ? {\n            host: result[0],\n            port: Number(result[1])\n        } : null);\n    }\n    async resolveSlave(client) {\n        const result = await client.sentinel(\"slaves\", this.options.name);\n        if (!Array.isArray(result)) {\n            return null;\n        }\n        const availableSlaves = result.map(utils_1.packObject).filter((slave)=>slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));\n        return this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves));\n    }\n    sentinelNatResolve(item) {\n        if (!item || !this.options.natMap) return item;\n        const key = `${item.host}:${item.port}`;\n        let result = item;\n        if (typeof this.options.natMap === \"function\") {\n            result = this.options.natMap(key) || item;\n        } else if (typeof this.options.natMap === \"object\") {\n            result = this.options.natMap[key] || item;\n        }\n        return result;\n    }\n    connectToSentinel(endpoint, options) {\n        const redis = new Redis_1.default({\n            port: endpoint.port || 26379,\n            host: endpoint.host,\n            username: this.options.sentinelUsername || null,\n            password: this.options.sentinelPassword || null,\n            family: endpoint.family || // @ts-expect-error\n            (\"path\" in this.options && this.options.path ? undefined : this.options.family),\n            tls: this.options.sentinelTLS,\n            retryStrategy: null,\n            enableReadyCheck: false,\n            connectTimeout: this.options.connectTimeout,\n            commandTimeout: this.options.sentinelCommandTimeout,\n            ...options\n        });\n        // @ts-expect-error\n        return redis;\n    }\n    async resolve(endpoint) {\n        const client = this.connectToSentinel(endpoint);\n        // ignore the errors since resolve* methods will handle them\n        client.on(\"error\", noop);\n        try {\n            if (this.options.role === \"slave\") {\n                return await this.resolveSlave(client);\n            } else {\n                return await this.resolveMaster(client);\n            }\n        } finally{\n            client.disconnect();\n        }\n    }\n    async initFailoverDetector() {\n        var _a;\n        if (!this.options.failoverDetector) {\n            return;\n        }\n        // Move the current sentinel to the first position\n        this.sentinelIterator.reset(true);\n        const sentinels = [];\n        // In case of a large amount of sentinels, limit the number of concurrent connections\n        while(sentinels.length < this.options.sentinelMaxConnections){\n            const { done, value } = this.sentinelIterator.next();\n            if (done) {\n                break;\n            }\n            const client = this.connectToSentinel(value, {\n                lazyConnect: true,\n                retryStrategy: this.options.sentinelReconnectStrategy\n            });\n            client.on(\"reconnecting\", ()=>{\n                var _a;\n                // Tests listen to this event\n                (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(\"sentinelReconnecting\");\n            });\n            sentinels.push({\n                address: value,\n                client\n            });\n        }\n        this.sentinelIterator.reset(false);\n        if (this.failoverDetector) {\n            // Clean up previous detector\n            this.failoverDetector.cleanup();\n        }\n        this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);\n        await this.failoverDetector.subscribe();\n        // Tests listen to this event\n        (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(\"failoverSubscribed\");\n    }\n}\nexports[\"default\"] = SentinelConnector;\nfunction selectPreferredSentinel(availableSlaves, preferredSlaves) {\n    if (availableSlaves.length === 0) {\n        return null;\n    }\n    let selectedSlave;\n    if (typeof preferredSlaves === \"function\") {\n        selectedSlave = preferredSlaves(availableSlaves);\n    } else if (preferredSlaves !== null && typeof preferredSlaves === \"object\") {\n        const preferredSlavesArray = Array.isArray(preferredSlaves) ? preferredSlaves : [\n            preferredSlaves\n        ];\n        // sort by priority\n        preferredSlavesArray.sort((a, b)=>{\n            // default the priority to 1\n            if (!a.prio) {\n                a.prio = 1;\n            }\n            if (!b.prio) {\n                b.prio = 1;\n            }\n            // lowest priority first\n            if (a.prio < b.prio) {\n                return -1;\n            }\n            if (a.prio > b.prio) {\n                return 1;\n            }\n            return 0;\n        });\n        // loop over preferred slaves and return the first match\n        for(let p = 0; p < preferredSlavesArray.length; p++){\n            for(let a = 0; a < availableSlaves.length; a++){\n                const slave = availableSlaves[a];\n                if (slave.ip === preferredSlavesArray[p].ip) {\n                    if (slave.port === preferredSlavesArray[p].port) {\n                        selectedSlave = slave;\n                        break;\n                    }\n                }\n            }\n            if (selectedSlave) {\n                break;\n            }\n        }\n    }\n    // if none of the preferred slaves are available, a random available slave is returned\n    if (!selectedSlave) {\n        selectedSlave = (0, utils_1.sample)(availableSlaves);\n    }\n    return addressResponseToAddress(selectedSlave);\n}\nfunction addressResponseToAddress(input) {\n    return {\n        host: input.ip,\n        port: Number(input.port)\n    };\n}\nfunction noop() {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1NlbnRpbmVsQ29ubmVjdG9yL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBRyxLQUFLO0FBQ2hDLE1BQU1HLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLHNFQUFhO0FBQ3JDLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1HLHFCQUFxQkgsbUJBQU9BLENBQUMsK0dBQW9CO0FBQ3ZESix3QkFBd0IsR0FBR08sbUJBQW1CQyxPQUFPO0FBQ3JELE1BQU1DLHNCQUFzQkwsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzFELE1BQU1NLFVBQVVOLG1CQUFPQSxDQUFDLGdFQUFhO0FBQ3JDLE1BQU1PLHFCQUFxQlAsbUJBQU9BLENBQUMsK0dBQW9CO0FBQ3ZELE1BQU1RLFFBQVEsQ0FBQyxHQUFHUCxRQUFRUSxLQUFLLEVBQUU7QUFDakMsTUFBTUMsMEJBQTBCTCxvQkFBb0JELE9BQU87SUFDdkRPLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBLFFBQVFDLGlCQUFpQjtRQUMvQixJQUFJLENBQUNELE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNFLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLENBQUNDLE1BQU0sRUFBRTtZQUNoQyxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDTixPQUFPLENBQUNPLElBQUksRUFBRTtZQUNwQixNQUFNLElBQUlELE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNFLGdCQUFnQixHQUFHLElBQUlqQixtQkFBbUJDLE9BQU8sQ0FBQyxJQUFJ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d2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9TZW50aW5lbENvbm5lY3Rvci9pbmRleC5qcz9hOWY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZW50aW5lbEl0ZXJhdG9yID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IHRsc18xID0gcmVxdWlyZShcInRsc1wiKTtcbmNvbnN0IFNlbnRpbmVsSXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL1NlbnRpbmVsSXRlcmF0b3JcIik7XG5leHBvcnRzLlNlbnRpbmVsSXRlcmF0b3IgPSBTZW50aW5lbEl0ZXJhdG9yXzEuZGVmYXVsdDtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi4vQWJzdHJhY3RDb25uZWN0b3JcIik7XG5jb25zdCBSZWRpc18xID0gcmVxdWlyZShcIi4uLy4uL1JlZGlzXCIpO1xuY29uc3QgRmFpbG92ZXJEZXRlY3Rvcl8xID0gcmVxdWlyZShcIi4vRmFpbG92ZXJEZXRlY3RvclwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiU2VudGluZWxDb25uZWN0b3JcIik7XG5jbGFzcyBTZW50aW5lbENvbm5lY3RvciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdG9yXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLmRpc2Nvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5mYWlsb3ZlckRldGVjdG9yID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2VudGluZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZXMgYXQgbGVhc3Qgb25lIHNlbnRpbmVsIHRvIGNvbm5lY3QgdG8uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVpcmVzIHRoZSBuYW1lIG9mIG1hc3Rlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW50aW5lbEl0ZXJhdG9yID0gbmV3IFNlbnRpbmVsSXRlcmF0b3JfMS5kZWZhdWx0KHRoaXMub3B0aW9ucy5zZW50aW5lbHMpO1xuICAgIH1cbiAgICBjaGVjayhpbmZvKSB7XG4gICAgICAgIGNvbnN0IHJvbGVNYXRjaGVzID0gIWluZm8ucm9sZSB8fCB0aGlzLm9wdGlvbnMucm9sZSA9PT0gaW5mby5yb2xlO1xuICAgICAgICBpZiAoIXJvbGVNYXRjaGVzKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInJvbGUgaW52YWxpZCwgZXhwZWN0ZWQgJXMsIGJ1dCBnb3QgJXNcIiwgdGhpcy5vcHRpb25zLnJvbGUsIGluZm8ucm9sZSk7XG4gICAgICAgICAgICAvLyBTdGFydCBmcm9tIHRoZSBuZXh0IGl0ZW0uXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgYHJlc2V0YCB3aWxsIG1vdmUgdGhlIGN1cnNvciB0byB0aGUgcHJldmlvdXMgZWxlbWVudCxcbiAgICAgICAgICAgIC8vIHNvIHdlIGFkdmFuY2UgdHdvIHN0ZXBzIGhlcmUuXG4gICAgICAgICAgICB0aGlzLnNlbnRpbmVsSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5zZW50aW5lbEl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2VudGluZWxJdGVyYXRvci5yZXNldCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9sZU1hdGNoZXM7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHN1cGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHRoaXMuZmFpbG92ZXJEZXRlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5mYWlsb3ZlckRldGVjdG9yLmNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0KGV2ZW50RW1pdHRlcikge1xuICAgICAgICB0aGlzLmNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJldHJ5QXR0ZW1wdHMgPSAwO1xuICAgICAgICBsZXQgbGFzdEVycm9yO1xuICAgICAgICBjb25zdCBjb25uZWN0VG9OZXh0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLnNlbnRpbmVsSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGVuZHBvaW50LmRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbnRpbmVsSXRlcmF0b3IucmVzZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5RGVsYXkgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNlbnRpbmVsUmV0cnlTdHJhdGVneSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLnNlbnRpbmVsUmV0cnlTdHJhdGVneSgrK3RoaXMucmV0cnlBdHRlbXB0cylcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBlcnJvck1zZyA9IHR5cGVvZiByZXRyeURlbGF5ICE9PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgID8gXCJBbGwgc2VudGluZWxzIGFyZSB1bnJlYWNoYWJsZSBhbmQgcmV0cnkgaXMgZGlzYWJsZWQuXCJcbiAgICAgICAgICAgICAgICAgICAgOiBgQWxsIHNlbnRpbmVscyBhcmUgdW5yZWFjaGFibGUuIFJldHJ5aW5nIGZyb20gc2NyYXRjaCBhZnRlciAke3JldHJ5RGVsYXl9bXMuYDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTXNnICs9IGAgTGFzdCBlcnJvcjogJHtsYXN0RXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhlcnJvck1zZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0cnlEZWxheSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5RGVsYXkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RUb05leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZXJyID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBhd2FpdCB0aGlzLnJlc29sdmUoZW5kcG9pbnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsc18xLkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludEFkZHJlc3MgPSBlbmRwb2ludC52YWx1ZS5ob3N0ICsgXCI6XCIgKyBlbmRwb2ludC52YWx1ZS5wb3J0O1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJyZXNvbHZlZDogJXM6JXMgZnJvbSBzZW50aW5lbCAlc1wiLCByZXNvbHZlZC5ob3N0LCByZXNvbHZlZC5wb3J0LCBlbmRwb2ludEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlVExTRm9yU2VudGluZWxNb2RlICYmIHRoaXMub3B0aW9ucy50bHMpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXNvbHZlZCwgdGhpcy5vcHRpb25zLnRscyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gKDAsIHRsc18xLmNvbm5lY3QpKHJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ub25jZShcInNlY3VyZUNvbm5lY3RcIiwgdGhpcy5pbml0RmFpbG92ZXJEZXRlY3Rvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gKDAsIG5ldF8xLmNyZWF0ZUNvbm5lY3Rpb24pKHJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ub25jZShcImNvbm5lY3RcIiwgdGhpcy5pbml0RmFpbG92ZXJEZXRlY3Rvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ub25jZShcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdEVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID0gZXJyXG4gICAgICAgICAgICAgICAgICAgID8gXCJmYWlsZWQgdG8gY29ubmVjdCB0byBzZW50aW5lbCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludEFkZHJlc3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgYmVjYXVzZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICA6IFwiY29ubmVjdGVkIHRvIHNlbnRpbmVsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50QWRkcmVzcyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBzdWNjZXNzZnVsbHksIGJ1dCBnb3QgYW4gaW52YWxpZCByZXBseTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQ7XG4gICAgICAgICAgICAgICAgZGVidWcoZXJyb3JNc2cpO1xuICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlcihcInNlbnRpbmVsRXJyb3JcIiwgbmV3IEVycm9yKGVycm9yTXNnKSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0VG9OZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb25uZWN0VG9OZXh0KCk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVNlbnRpbmVscyhjbGllbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlU2VudGluZWxzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnNlbnRpbmVsKFwic2VudGluZWxzXCIsIHRoaXMub3B0aW9ucy5uYW1lKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIC5tYXAodXRpbHNfMS5wYWNrT2JqZWN0KVxuICAgICAgICAgICAgLmZvckVhY2goKHNlbnRpbmVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IHNlbnRpbmVsLmZsYWdzID8gc2VudGluZWwuZmxhZ3Muc3BsaXQoXCIsXCIpIDogW107XG4gICAgICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZihcImRpc2Nvbm5lY3RlZFwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBzZW50aW5lbC5pcCAmJlxuICAgICAgICAgICAgICAgIHNlbnRpbmVsLnBvcnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuc2VudGluZWxOYXRSZXNvbHZlKGFkZHJlc3NSZXNwb25zZVRvQWRkcmVzcyhzZW50aW5lbCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbnRpbmVsSXRlcmF0b3IuYWRkKGVuZHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImFkZGluZyBzZW50aW5lbCAlczolc1wiLCBlbmRwb2ludC5ob3N0LCBlbmRwb2ludC5wb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkZWJ1ZyhcIlVwZGF0ZWQgaW50ZXJuYWwgc2VudGluZWxzOiAlc1wiLCB0aGlzLnNlbnRpbmVsSXRlcmF0b3IpO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlTWFzdGVyKGNsaWVudCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuc2VudGluZWwoXCJnZXQtbWFzdGVyLWFkZHItYnktbmFtZVwiLCB0aGlzLm9wdGlvbnMubmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlU2VudGluZWxzKGNsaWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbnRpbmVsTmF0UmVzb2x2ZShBcnJheS5pc0FycmF5KHJlc3VsdClcbiAgICAgICAgICAgID8geyBob3N0OiByZXN1bHRbMF0sIHBvcnQ6IE51bWJlcihyZXN1bHRbMV0pIH1cbiAgICAgICAgICAgIDogbnVsbCk7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVTbGF2ZShjbGllbnQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LnNlbnRpbmVsKFwic2xhdmVzXCIsIHRoaXMub3B0aW9ucy5uYW1lKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVNsYXZlcyA9IHJlc3VsdFxuICAgICAgICAgICAgLm1hcCh1dGlsc18xLnBhY2tPYmplY3QpXG4gICAgICAgICAgICAuZmlsdGVyKChzbGF2ZSkgPT4gc2xhdmUuZmxhZ3MgJiYgIXNsYXZlLmZsYWdzLm1hdGNoKC8oZGlzY29ubmVjdGVkfHNfZG93bnxvX2Rvd24pLykpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW50aW5lbE5hdFJlc29sdmUoc2VsZWN0UHJlZmVycmVkU2VudGluZWwoYXZhaWxhYmxlU2xhdmVzLCB0aGlzLm9wdGlvbnMucHJlZmVycmVkU2xhdmVzKSk7XG4gICAgfVxuICAgIHNlbnRpbmVsTmF0UmVzb2x2ZShpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbSB8fCAhdGhpcy5vcHRpb25zLm5hdE1hcClcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICBjb25zdCBrZXkgPSBgJHtpdGVtLmhvc3R9OiR7aXRlbS5wb3J0fWA7XG4gICAgICAgIGxldCByZXN1bHQgPSBpdGVtO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5uYXRNYXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5vcHRpb25zLm5hdE1hcChrZXkpIHx8IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5uYXRNYXAgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMub3B0aW9ucy5uYXRNYXBba2V5XSB8fCBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbm5lY3RUb1NlbnRpbmVsKGVuZHBvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlZGlzID0gbmV3IFJlZGlzXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBwb3J0OiBlbmRwb2ludC5wb3J0IHx8IDI2Mzc5LFxuICAgICAgICAgICAgaG9zdDogZW5kcG9pbnQuaG9zdCxcbiAgICAgICAgICAgIHVzZXJuYW1lOiB0aGlzLm9wdGlvbnMuc2VudGluZWxVc2VybmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMub3B0aW9ucy5zZW50aW5lbFBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICBmYW1pbHk6IGVuZHBvaW50LmZhbWlseSB8fFxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAoXCJwYXRoXCIgaW4gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wYXRoXG4gICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZhbWlseSksXG4gICAgICAgICAgICB0bHM6IHRoaXMub3B0aW9ucy5zZW50aW5lbFRMUyxcbiAgICAgICAgICAgIHJldHJ5U3RyYXRlZ3k6IG51bGwsXG4gICAgICAgICAgICBlbmFibGVSZWFkeUNoZWNrOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbm5lY3RUaW1lb3V0OiB0aGlzLm9wdGlvbnMuY29ubmVjdFRpbWVvdXQsXG4gICAgICAgICAgICBjb21tYW5kVGltZW91dDogdGhpcy5vcHRpb25zLnNlbnRpbmVsQ29tbWFuZFRpbWVvdXQsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByZXR1cm4gcmVkaXM7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmUoZW5kcG9pbnQpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jb25uZWN0VG9TZW50aW5lbChlbmRwb2ludCk7XG4gICAgICAgIC8vIGlnbm9yZSB0aGUgZXJyb3JzIHNpbmNlIHJlc29sdmUqIG1ldGhvZHMgd2lsbCBoYW5kbGUgdGhlbVxuICAgICAgICBjbGllbnQub24oXCJlcnJvclwiLCBub29wKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucm9sZSA9PT0gXCJzbGF2ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVzb2x2ZVNsYXZlKGNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXNvbHZlTWFzdGVyKGNsaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBjbGllbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGluaXRGYWlsb3ZlckRldGVjdG9yKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZhaWxvdmVyRGV0ZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNb3ZlIHRoZSBjdXJyZW50IHNlbnRpbmVsIHRvIHRoZSBmaXJzdCBwb3NpdGlvblxuICAgICAgICB0aGlzLnNlbnRpbmVsSXRlcmF0b3IucmVzZXQodHJ1ZSk7XG4gICAgICAgIGNvbnN0IHNlbnRpbmVscyA9IFtdO1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGEgbGFyZ2UgYW1vdW50IG9mIHNlbnRpbmVscywgbGltaXQgdGhlIG51bWJlciBvZiBjb25jdXJyZW50IGNvbm5lY3Rpb25zXG4gICAgICAgIHdoaWxlIChzZW50aW5lbHMubGVuZ3RoIDwgdGhpcy5vcHRpb25zLnNlbnRpbmVsTWF4Q29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHRoaXMuc2VudGluZWxJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jb25uZWN0VG9TZW50aW5lbCh2YWx1ZSwge1xuICAgICAgICAgICAgICAgIGxhenlDb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHJldHJ5U3RyYXRlZ3k6IHRoaXMub3B0aW9ucy5zZW50aW5lbFJlY29ubmVjdFN0cmF0ZWd5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbGllbnQub24oXCJyZWNvbm5lY3RpbmdcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBUZXN0cyBsaXN0ZW4gdG8gdGhpcyBldmVudFxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZW1pdHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtaXQoXCJzZW50aW5lbFJlY29ubmVjdGluZ1wiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VudGluZWxzLnB1c2goeyBhZGRyZXNzOiB2YWx1ZSwgY2xpZW50IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VudGluZWxJdGVyYXRvci5yZXNldChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmZhaWxvdmVyRGV0ZWN0b3IpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHByZXZpb3VzIGRldGVjdG9yXG4gICAgICAgICAgICB0aGlzLmZhaWxvdmVyRGV0ZWN0b3IuY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmFpbG92ZXJEZXRlY3RvciA9IG5ldyBGYWlsb3ZlckRldGVjdG9yXzEuRmFpbG92ZXJEZXRlY3Rvcih0aGlzLCBzZW50aW5lbHMpO1xuICAgICAgICBhd2FpdCB0aGlzLmZhaWxvdmVyRGV0ZWN0b3Iuc3Vic2NyaWJlKCk7XG4gICAgICAgIC8vIFRlc3RzIGxpc3RlbiB0byB0aGlzIGV2ZW50XG4gICAgICAgIChfYSA9IHRoaXMuZW1pdHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtaXQoXCJmYWlsb3ZlclN1YnNjcmliZWRcIik7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2VudGluZWxDb25uZWN0b3I7XG5mdW5jdGlvbiBzZWxlY3RQcmVmZXJyZWRTZW50aW5lbChhdmFpbGFibGVTbGF2ZXMsIHByZWZlcnJlZFNsYXZlcykge1xuICAgIGlmIChhdmFpbGFibGVTbGF2ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgc2VsZWN0ZWRTbGF2ZTtcbiAgICBpZiAodHlwZW9mIHByZWZlcnJlZFNsYXZlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHNlbGVjdGVkU2xhdmUgPSBwcmVmZXJyZWRTbGF2ZXMoYXZhaWxhYmxlU2xhdmVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJlZmVycmVkU2xhdmVzICE9PSBudWxsICYmIHR5cGVvZiBwcmVmZXJyZWRTbGF2ZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcHJlZmVycmVkU2xhdmVzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByZWZlcnJlZFNsYXZlcylcbiAgICAgICAgICAgID8gcHJlZmVycmVkU2xhdmVzXG4gICAgICAgICAgICA6IFtwcmVmZXJyZWRTbGF2ZXNdO1xuICAgICAgICAvLyBzb3J0IGJ5IHByaW9yaXR5XG4gICAgICAgIHByZWZlcnJlZFNsYXZlc0FycmF5LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdGhlIHByaW9yaXR5IHRvIDFcbiAgICAgICAgICAgIGlmICghYS5wcmlvKSB7XG4gICAgICAgICAgICAgICAgYS5wcmlvID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYi5wcmlvKSB7XG4gICAgICAgICAgICAgICAgYi5wcmlvID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxvd2VzdCBwcmlvcml0eSBmaXJzdFxuICAgICAgICAgICAgaWYgKGEucHJpbyA8IGIucHJpbykge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhLnByaW8gPiBiLnByaW8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gbG9vcCBvdmVyIHByZWZlcnJlZCBzbGF2ZXMgYW5kIHJldHVybiB0aGUgZmlyc3QgbWF0Y2hcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwcmVmZXJyZWRTbGF2ZXNBcnJheS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBhdmFpbGFibGVTbGF2ZXMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbGF2ZSA9IGF2YWlsYWJsZVNsYXZlc1thXTtcbiAgICAgICAgICAgICAgICBpZiAoc2xhdmUuaXAgPT09IHByZWZlcnJlZFNsYXZlc0FycmF5W3BdLmlwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGF2ZS5wb3J0ID09PSBwcmVmZXJyZWRTbGF2ZXNBcnJheVtwXS5wb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFNsYXZlID0gc2xhdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFNsYXZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgbm9uZSBvZiB0aGUgcHJlZmVycmVkIHNsYXZlcyBhcmUgYXZhaWxhYmxlLCBhIHJhbmRvbSBhdmFpbGFibGUgc2xhdmUgaXMgcmV0dXJuZWRcbiAgICBpZiAoIXNlbGVjdGVkU2xhdmUpIHtcbiAgICAgICAgc2VsZWN0ZWRTbGF2ZSA9ICgwLCB1dGlsc18xLnNhbXBsZSkoYXZhaWxhYmxlU2xhdmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHJlc3NSZXNwb25zZVRvQWRkcmVzcyhzZWxlY3RlZFNsYXZlKTtcbn1cbmZ1bmN0aW9uIGFkZHJlc3NSZXNwb25zZVRvQWRkcmVzcyhpbnB1dCkge1xuICAgIHJldHVybiB7IGhvc3Q6IGlucHV0LmlwLCBwb3J0OiBOdW1iZXIoaW5wdXQucG9ydCkgfTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNlbnRpbmVsSXRlcmF0b3IiLCJuZXRfMSIsInJlcXVpcmUiLCJ1dGlsc18xIiwidGxzXzEiLCJTZW50aW5lbEl0ZXJhdG9yXzEiLCJkZWZhdWx0IiwiQWJzdHJhY3RDb25uZWN0b3JfMSIsIlJlZGlzXzEiLCJGYWlsb3ZlckRldGVjdG9yXzEiLCJkZWJ1ZyIsIkRlYnVnIiwiU2VudGluZWxDb25uZWN0b3IiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJkaXNjb25uZWN0VGltZW91dCIsImVtaXR0ZXIiLCJmYWlsb3ZlckRldGVjdG9yIiwic2VudGluZWxzIiwibGVuZ3RoIiwiRXJyb3IiLCJuYW1lIiwic2VudGluZWxJdGVyYXRvciIsImNoZWNrIiwiaW5mbyIsInJvbGVNYXRjaGVzIiwicm9sZSIsIm5leHQiLCJyZXNldCIsImRpc2Nvbm5lY3QiLCJjbGVhbnVwIiwiY29ubmVjdCIsImV2ZW50RW1pdHRlciIsImNvbm5lY3RpbmciLCJyZXRyeUF0dGVtcHRzIiwibGFzdEVycm9yIiwiY29ubmVjdFRvTmV4dCIsImVuZHBvaW50IiwiZG9uZSIsInJldHJ5RGVsYXkiLCJzZW50aW5lbFJldHJ5U3RyYXRlZ3kiLCJlcnJvck1zZyIsIm1lc3NhZ2UiLCJlcnJvciIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInJlc29sdmVkIiwiZXJyIiwiQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHIiwiZW5kcG9pbnRBZGRyZXNzIiwiaG9zdCIsInBvcnQiLCJlbmFibGVUTFNGb3JTZW50aW5lbE1vZGUiLCJ0bHMiLCJhc3NpZ24iLCJzdHJlYW0iLCJvbmNlIiwiaW5pdEZhaWxvdmVyRGV0ZWN0b3IiLCJiaW5kIiwiY3JlYXRlQ29ubmVjdGlvbiIsImZpcnN0RXJyb3IiLCJ1cGRhdGVTZW50aW5lbHMiLCJjbGllbnQiLCJyZXN1bHQiLCJzZW50aW5lbCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInBhY2tPYmplY3QiLCJmb3JFYWNoIiwiZmxhZ3MiLCJzcGxpdCIsImluZGV4T2YiLCJpcCIsInNlbnRpbmVsTmF0UmVzb2x2ZSIsImFkZHJlc3NSZXNwb25zZVRvQWRkcmVzcyIsImFkZCIsInJlc29sdmVNYXN0ZXIiLCJOdW1iZXIiLCJyZXNvbHZlU2xhdmUiLCJhdmFpbGFibGVTbGF2ZXMiLCJmaWx0ZXIiLCJzbGF2ZSIsIm1hdGNoIiwic2VsZWN0UHJlZmVycmVkU2VudGluZWwiLCJwcmVmZXJyZWRTbGF2ZXMiLCJpdGVtIiwibmF0TWFwIiwia2V5IiwiY29ubmVjdFRvU2VudGluZWwiLCJyZWRpcyIsInVzZXJuYW1lIiwic2VudGluZWxVc2VybmFtZSIsInBhc3N3b3JkIiwic2VudGluZWxQYXNzd29yZCIsImZhbWlseSIsInBhdGgiLCJ1bmRlZmluZWQiLCJzZW50aW5lbFRMUyIsInJldHJ5U3RyYXRlZ3kiLCJlbmFibGVSZWFkeUNoZWNrIiwiY29ubmVjdFRpbWVvdXQiLCJjb21tYW5kVGltZW91dCIsInNlbnRpbmVsQ29tbWFuZFRpbWVvdXQiLCJvbiIsIm5vb3AiLCJfYSIsInNlbnRpbmVsTWF4Q29ubmVjdGlvbnMiLCJsYXp5Q29ubmVjdCIsInNlbnRpbmVsUmVjb25uZWN0U3RyYXRlZ3kiLCJlbWl0IiwicHVzaCIsImFkZHJlc3MiLCJGYWlsb3ZlckRldGVjdG9yIiwic3Vic2NyaWJlIiwic2VsZWN0ZWRTbGF2ZSIsInByZWZlcnJlZFNsYXZlc0FycmF5Iiwic29ydCIsImEiLCJiIiwicHJpbyIsInAiLCJzYW1wbGUiLCJpbnB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/StandaloneConnector.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/StandaloneConnector.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst AbstractConnector_1 = __webpack_require__(/*! ./AbstractConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js\");\nclass StandaloneConnector extends AbstractConnector_1.default {\n    constructor(options){\n        super(options.disconnectTimeout);\n        this.options = options;\n    }\n    connect(_) {\n        const { options } = this;\n        this.connecting = true;\n        let connectionOptions;\n        if (\"path\" in options && options.path) {\n            connectionOptions = {\n                path: options.path\n            };\n        } else {\n            connectionOptions = {};\n            if (\"port\" in options && options.port != null) {\n                connectionOptions.port = options.port;\n            }\n            if (\"host\" in options && options.host != null) {\n                connectionOptions.host = options.host;\n            }\n            if (\"family\" in options && options.family != null) {\n                connectionOptions.family = options.family;\n            }\n        }\n        if (options.tls) {\n            Object.assign(connectionOptions, options.tls);\n        }\n        // TODO:\n        // We use native Promise here since other Promise\n        // implementation may use different schedulers that\n        // cause issue when the stream is resolved in the\n        // next tick.\n        // Should use the provided promise in the next major\n        // version and do not connect before resolved.\n        return new Promise((resolve, reject)=>{\n            process.nextTick(()=>{\n                if (!this.connecting) {\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                    return;\n                }\n                try {\n                    if (options.tls) {\n                        this.stream = (0, tls_1.connect)(connectionOptions);\n                    } else {\n                        this.stream = (0, net_1.createConnection)(connectionOptions);\n                    }\n                } catch (err) {\n                    reject(err);\n                    return;\n                }\n                this.stream.once(\"error\", (err)=>{\n                    this.firstError = err;\n                });\n                resolve(this.stream);\n            });\n        });\n    }\n}\nexports[\"default\"] = StandaloneConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL1N0YW5kYWxvbmVDb25uZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsUUFBUUMsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsbUVBQVU7QUFDbEMsTUFBTUcsc0JBQXNCSCxtQkFBT0EsQ0FBQywrRkFBcUI7QUFDekQsTUFBTUksNEJBQTRCRCxvQkFBb0JFLE9BQU87SUFDekRDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBLFFBQVFDLGlCQUFpQjtRQUMvQixJQUFJLENBQUNELE9BQU8sR0FBR0E7SUFDbkI7SUFDQUUsUUFBUUMsQ0FBQyxFQUFFO1FBQ1AsTUFBTSxFQUFFSCxPQUFPLEVBQUUsR0FBRyxJQUFJO1FBQ3hCLElBQUksQ0FBQ0ksVUFBVSxHQUFHO1FBQ2xCLElBQUlDO1FBQ0osSUFBSSxVQUFVTCxXQUFXQSxRQUFRTSxJQUFJLEVBQUU7WUFDbkNELG9CQUFvQjtnQkFDaEJDLE1BQU1OLFFBQVFNLElBQUk7WUFDdEI7UUFDSixPQUNLO1lBQ0RELG9CQUFvQixDQUFDO1lBQ3JCLElBQUksVUFBVUwsV0FBV0EsUUFBUU8sSUFBSSxJQUFJLE1BQU07Z0JBQzNDRixrQkFBa0JFLElBQUksR0FBR1AsUUFBUU8sSUFBSTtZQUN6QztZQUNBLElBQUksVUFBVVAsV0FBV0EsUUFBUVEsSUFBSSxJQUFJLE1BQU07Z0JBQzNDSCxrQkFBa0JHLElBQUksR0FBR1IsUUFBUVEsSUFBSTtZQUN6QztZQUNBLElBQUksWUFBWVIsV0FBV0EsUUFBUVMsTUFBTSxJQUFJLE1BQU07Z0JBQy9DSixrQkFBa0JJLE1BQU0sR0FBR1QsUUFBUVMsTUFBTTtZQUM3QztRQUNKO1FBQ0EsSUFBSVQsUUFBUVUsR0FBRyxFQUFFO1lBQ2J0QixPQUFPdUIsTUFBTSxDQUFDTixtQkFBbUJMLFFBQVFVLEdBQUc7UUFDaEQ7UUFDQSxRQUFRO1FBQ1IsaURBQWlEO1FBQ2pELG1EQUFtRDtRQUNuRCxpREFBaUQ7UUFDakQsYUFBYTtRQUNiLG9EQUFvRDtRQUNwRCw4Q0FBOEM7UUFDOUMsT0FBTyxJQUFJRSxRQUFRLENBQUNDLFNBQVNDO1lBQ3pCQyxRQUFRQyxRQUFRLENBQUM7Z0JBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQ1osVUFBVSxFQUFFO29CQUNsQlUsT0FBTyxJQUFJRyxNQUFNdEIsUUFBUXVCLDJCQUEyQjtvQkFDcEQ7Z0JBQ0o7Z0JBQ0EsSUFBSTtvQkFDQSxJQUFJbEIsUUFBUVUsR0FBRyxFQUFFO3dCQUNiLElBQUksQ0FBQ1MsTUFBTSxHQUFHLENBQUMsR0FBR3pCLE1BQU1RLE9BQU8sRUFBRUc7b0JBQ3JDLE9BQ0s7d0JBQ0QsSUFBSSxDQUFDYyxNQUFNLEdBQUcsQ0FBQyxHQUFHM0IsTUFBTTRCLGdCQUFnQixFQUFFZjtvQkFDOUM7Z0JBQ0osRUFDQSxPQUFPZ0IsS0FBSztvQkFDUlAsT0FBT087b0JBQ1A7Z0JBQ0o7Z0JBQ0EsSUFBSSxDQUFDRixNQUFNLENBQUNHLElBQUksQ0FBQyxTQUFTLENBQUNEO29CQUN2QixJQUFJLENBQUNFLFVBQVUsR0FBR0Y7Z0JBQ3RCO2dCQUNBUixRQUFRLElBQUksQ0FBQ00sTUFBTTtZQUN2QjtRQUNKO0lBQ0o7QUFDSjtBQUNBN0Isa0JBQWUsR0FBR08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0LWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvU3RhbmRhbG9uZUNvbm5lY3Rvci5qcz8wZWNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdENvbm5lY3RvclwiKTtcbmNsYXNzIFN0YW5kYWxvbmVDb25uZWN0b3IgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rvcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5kaXNjb25uZWN0VGltZW91dCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGNvbm5lY3QoXykge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgIGxldCBjb25uZWN0aW9uT3B0aW9ucztcbiAgICAgICAgaWYgKFwicGF0aFwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiBvcHRpb25zLnBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChcInBvcnRcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMucG9ydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMucG9ydCA9IG9wdGlvbnMucG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcImhvc3RcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuaG9zdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuaG9zdCA9IG9wdGlvbnMuaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcImZhbWlseVwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5mYW1pbHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmZhbWlseSA9IG9wdGlvbnMuZmFtaWx5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnRscykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjb25uZWN0aW9uT3B0aW9ucywgb3B0aW9ucy50bHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86XG4gICAgICAgIC8vIFdlIHVzZSBuYXRpdmUgUHJvbWlzZSBoZXJlIHNpbmNlIG90aGVyIFByb21pc2VcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gbWF5IHVzZSBkaWZmZXJlbnQgc2NoZWR1bGVycyB0aGF0XG4gICAgICAgIC8vIGNhdXNlIGlzc3VlIHdoZW4gdGhlIHN0cmVhbSBpcyByZXNvbHZlZCBpbiB0aGVcbiAgICAgICAgLy8gbmV4dCB0aWNrLlxuICAgICAgICAvLyBTaG91bGQgdXNlIHRoZSBwcm92aWRlZCBwcm9taXNlIGluIHRoZSBuZXh0IG1ham9yXG4gICAgICAgIC8vIHZlcnNpb24gYW5kIGRvIG5vdCBjb25uZWN0IGJlZm9yZSByZXNvbHZlZC5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IodXRpbHNfMS5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50bHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gKDAsIHRsc18xLmNvbm5lY3QpKGNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gKDAsIG5ldF8xLmNyZWF0ZUNvbm5lY3Rpb24pKGNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuc3RyZWFtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTdGFuZGFsb25lQ29ubmVjdG9yO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibmV0XzEiLCJyZXF1aXJlIiwidGxzXzEiLCJ1dGlsc18xIiwiQWJzdHJhY3RDb25uZWN0b3JfMSIsIlN0YW5kYWxvbmVDb25uZWN0b3IiLCJkZWZhdWx0IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiZGlzY29ubmVjdFRpbWVvdXQiLCJjb25uZWN0IiwiXyIsImNvbm5lY3RpbmciLCJjb25uZWN0aW9uT3B0aW9ucyIsInBhdGgiLCJwb3J0IiwiaG9zdCIsImZhbWlseSIsInRscyIsImFzc2lnbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicHJvY2VzcyIsIm5leHRUaWNrIiwiRXJyb3IiLCJDT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0ciLCJzdHJlYW0iLCJjcmVhdGVDb25uZWN0aW9uIiwiZXJyIiwib25jZSIsImZpcnN0RXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/StandaloneConnector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/connectors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ioredis/built/connectors/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SentinelConnector = exports.StandaloneConnector = void 0;\nconst StandaloneConnector_1 = __webpack_require__(/*! ./StandaloneConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/StandaloneConnector.js\");\nexports.StandaloneConnector = StandaloneConnector_1.default;\nconst SentinelConnector_1 = __webpack_require__(/*! ./SentinelConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js\");\nexports.SentinelConnector = SentinelConnector_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBR0EsMkJBQTJCLEdBQUcsS0FBSztBQUMvRCxNQUFNSSx3QkFBd0JDLG1CQUFPQSxDQUFDLG1HQUF1QjtBQUM3REwsMkJBQTJCLEdBQUdJLHNCQUFzQkUsT0FBTztBQUMzRCxNQUFNQyxzQkFBc0JGLG1CQUFPQSxDQUFDLHFHQUFxQjtBQUN6REwseUJBQXlCLEdBQUdPLG9CQUFvQkQsT0FBTyIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9pbmRleC5qcz8wMmYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZW50aW5lbENvbm5lY3RvciA9IGV4cG9ydHMuU3RhbmRhbG9uZUNvbm5lY3RvciA9IHZvaWQgMDtcbmNvbnN0IFN0YW5kYWxvbmVDb25uZWN0b3JfMSA9IHJlcXVpcmUoXCIuL1N0YW5kYWxvbmVDb25uZWN0b3JcIik7XG5leHBvcnRzLlN0YW5kYWxvbmVDb25uZWN0b3IgPSBTdGFuZGFsb25lQ29ubmVjdG9yXzEuZGVmYXVsdDtcbmNvbnN0IFNlbnRpbmVsQ29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9TZW50aW5lbENvbm5lY3RvclwiKTtcbmV4cG9ydHMuU2VudGluZWxDb25uZWN0b3IgPSBTZW50aW5lbENvbm5lY3Rvcl8xLmRlZmF1bHQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTZW50aW5lbENvbm5lY3RvciIsIlN0YW5kYWxvbmVDb25uZWN0b3IiLCJTdGFuZGFsb25lQ29ubmVjdG9yXzEiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIlNlbnRpbmVsQ29ubmVjdG9yXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/connectors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/constants/TLSProfiles.js":
/*!*************************************************************!*\
  !*** ./node_modules/ioredis/built/constants/TLSProfiles.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * TLS settings for Redis Cloud. Updated on 2022-08-19.\n */ const RedisCloudCA = `-----BEGIN CERTIFICATE-----\nMIIDTzCCAjegAwIBAgIJAKSVpiDswLcwMA0GCSqGSIb3DQEBBQUAMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTAeFw0xMzEwMDExMjE0NTVaFw0yMzA5MjkxMjE0NTVaMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALZqkh/DczWP\nJnxnHLQ7QL0T4B4CDKWBKCcisriGbA6ZePWVNo4hfKQC6JrzfR+081NeD6VcWUiz\nrmd+jtPhIY4c+WVQYm5PKaN6DT1imYdxQw7aqO5j2KUCEh/cznpLxeSHoTxlR34E\nQwF28Wl3eg2vc5ct8LjU3eozWVk3gb7alx9mSA2SgmuX5lEQawl++rSjsBStemY2\nBDwOpAMXIrdEyP/cVn8mkvi/BDs5M5G+09j0gfhyCzRWMQ7Hn71u1eolRxwVxgi3\nTMn+/vTaFSqxKjgck6zuAYjBRPaHe7qLxHNr1So/Mc9nPy+3wHebFwbIcnUojwbp\n4nctkWbjb2cCAwEAAaNQME4wHQYDVR0OBBYEFP1whtcrydmW3ZJeuSoKZIKjze3w\nMB8GA1UdIwQYMBaAFP1whtcrydmW3ZJeuSoKZIKjze3wMAwGA1UdEwQFMAMBAf8w\nDQYJKoZIhvcNAQEFBQADggEBAG2erXhwRAa7+ZOBs0B6X57Hwyd1R4kfmXcs0rta\nlbPpvgULSiB+TCbf3EbhJnHGyvdCY1tvlffLjdA7HJ0PCOn+YYLBA0pTU/dyvrN6\nSu8NuS5yubnt9mb13nDGYo1rnt0YRfxN+8DM3fXIVr038A30UlPX2Ou1ExFJT0MZ\nuFKY6ZvLdI6/1cbgmguMlAhM+DhKyV6Sr5699LM3zqeI816pZmlREETYkGr91q7k\nBpXJu/dtHaGxg1ZGu6w/PCsYGUcECWENYD4VQPd8N32JjOfu6vEgoEAwfPP+3oGp\nZ4m3ewACcWOAenqflb+cQYC4PsF7qbXDmRaWrbKntOlZ3n0=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIGMTCCBBmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwajELMAkGA1UEBhMCVVMx\nCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJzMS0w\nKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcN\nMTgwMjI1MTUzNzM3WhcNMjgwMjIzMTUzNzM3WjBfMQswCQYDVQQGEwJVUzELMAkG\nA1UECAwCQ0ExEjAQBgNVBAoMCVJlZGlzTGFiczEvMC0GA1UEAwwmUkNQIEludGVy\nbWVkaWF0ZSBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA\nA4ICDwAwggIKAoICAQDf9dqbxc8Bq7Ctq9rWcxrGNKKHivqLAFpPq02yLPx6fsOv\nTq7GsDChAYBBc4v7Y2Ap9RD5Vs3dIhEANcnolf27QwrG9RMnnvzk8pCvp1o6zSU4\nVuOE1W66/O1/7e2rVxyrnTcP7UgK43zNIXu7+tiAqWsO92uSnuMoGPGpeaUm1jym\nhjWKtkAwDFSqvHY+XL5qDVBEjeUe+WHkYUg40cAXjusAqgm2hZt29c2wnVrxW25W\nP0meNlzHGFdA2AC5z54iRiqj57dTfBTkHoBczQxcyw6hhzxZQ4e5I5zOKjXXEhZN\nr0tA3YC14CTabKRus/JmZieyZzRgEy2oti64tmLYTqSlAD78pRL40VNoaSYetXLw\nhhNsXCHgWaY6d5bLOc/aIQMAV5oLvZQKvuXAF1IDmhPA+bZbpWipp0zagf1P1H3s\nUzsMdn2KM0ejzgotbtNlj5TcrVwpmvE3ktvUAuA+hi3FkVx1US+2Gsp5x4YOzJ7u\nP1WPk6ShF0JgnJH2ILdj6kttTWwFzH17keSFICWDfH/+kM+k7Y1v3EXMQXE7y0T9\nMjvJskz6d/nv+sQhY04xt64xFMGTnZjlJMzfQNi7zWFLTZnDD0lPowq7l3YiPoTT\nt5Xky83lu0KZsZBo0WlWaDG00gLVdtRgVbcuSWxpi5BdLb1kRab66JptWjxwXQID\nAQABo4HrMIHoMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHBzOi8vcmwtY2Etc2VydmVy\nLnJlZGlzbGFicy5jb20vdjEvY3JsMEYGCCsGAQUFBwEBBDowODA2BggrBgEFBQcw\nAYYqaHR0cHM6Ly9ybC1jYS1zZXJ2ZXIucmVkaXNsYWJzLmNvbS92MS9vY3NwMB0G\nA1UdDgQWBBQHar5OKvQUpP2qWt6mckzToeCOHDAfBgNVHSMEGDAWgBQi42wH6hM4\nL2sujEvLM0/u8lRXTzASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQsFAAOCAgEAirEn/iTsAKyhd+pu2W3Z5NjCko4NPU0EYUbr\nAP7+POK2rzjIrJO3nFYQ/LLuC7KCXG+2qwan2SAOGmqWst13Y+WHp44Kae0kaChW\nvcYLXXSoGQGC8QuFSNUdaeg3RbMDYFT04dOkqufeWVccoHVxyTSg9eD8LZuHn5jw\n7QDLiEECBmIJHk5Eeo2TAZrx4Yx6ufSUX5HeVjlAzqwtAqdt99uCJ/EL8bgpWbe+\nXoSpvUv0SEC1I1dCAhCKAvRlIOA6VBcmzg5Am12KzkqTul12/VEFIgzqu0Zy2Jbc\nAUPrYVu/+tOGXQaijy7YgwH8P8n3s7ZeUa1VABJHcxrxYduDDJBLZi+MjheUDaZ1\njQRHYevI2tlqeSBqdPKG4zBY5lS0GiAlmuze5oENt0P3XboHoZPHiqcK3VECgTVh\n/BkJcuudETSJcZDmQ8YfoKfBzRQNg2sv/hwvUv73Ss51Sco8GEt2lD8uEdib1Q6z\nzDT5lXJowSzOD5ZA9OGDjnSRL+2riNtKWKEqvtEG3VBJoBzu9GoxbAc7wIZLxmli\niF5a/Zf5X+UXD3s4TMmy6C4QZJpAA2egsSQCnraWO2ULhh7iXMysSkF/nzVfZn43\niqpaB8++9a37hWq14ZmOv0TJIDz//b2+KC4VFXWQ5W5QC6whsjT+OlG4p5ZYG0jo\n616pxqo=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\n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\n-----END CERTIFICATE-----\n\n-----BEGIN CERTIFICATE-----\nMIIEjzCCA3egAwIBAgIQe55B/ALCKJDZtdNT8kD6hTANBgkqhkiG9w0BAQsFADBM\nMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEGA1UEChMKR2xv\nYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjAeFw0yMjAxMjYxMjAwMDBaFw0y\nNTAxMjYwMDAwMDBaMFgxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWdu\nIG52LXNhMS4wLAYDVQQDEyVHbG9iYWxTaWduIEF0bGFzIFIzIE9WIFRMUyBDQSAy\nMDIyIFEyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmGmg1LW9b7Lf\n8zDD83yBDTEkt+FOxKJZqF4veWc5KZsQj9HfnUS2e5nj/E+JImlGPsQuoiosLuXD\nBVBNAMcUFa11buFMGMeEMwiTmCXoXRrXQmH0qjpOfKgYc5gHG3BsRGaRrf7VR4eg\nofNMG9wUBw4/g/TT7+bQJdA4NfE7Y4d5gEryZiBGB/swaX6Jp/8MF4TgUmOWmalK\ndZCKyb4sPGQFRTtElk67F7vU+wdGcrcOx1tDcIB0ncjLPMnaFicagl+daWGsKqTh\ncounQb6QJtYHa91KvCfKWocMxQ7OIbB5UARLPmC4CJ1/f8YFm35ebfzAeULYdGXu\njE9CLor0OwIDAQABo4IBXzCCAVswDgYDVR0PAQH/BAQDAgGGMB0GA1UdJQQWMBQG\nCCsGAQUFBwMBBggrBgEFBQcDAjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW\nBBSH5Zq7a7B/t95GfJWkDBpA8HHqdjAfBgNVHSMEGDAWgBSP8Et/qC5FJK5NUPpj\nmove4t0bvDB7BggrBgEFBQcBAQRvMG0wLgYIKwYBBQUHMAGGImh0dHA6Ly9vY3Nw\nMi5nbG9iYWxzaWduLmNvbS9yb290cjMwOwYIKwYBBQUHMAKGL2h0dHA6Ly9zZWN1\ncmUuZ2xvYmFsc2lnbi5jb20vY2FjZXJ0L3Jvb3QtcjMuY3J0MDYGA1UdHwQvMC0w\nK6ApoCeGJWh0dHA6Ly9jcmwuZ2xvYmFsc2lnbi5jb20vcm9vdC1yMy5jcmwwIQYD\nVR0gBBowGDAIBgZngQwBAgIwDAYKKwYBBAGgMgoBAjANBgkqhkiG9w0BAQsFAAOC\nAQEAKRic9/f+nmhQU/wz04APZLjgG5OgsuUOyUEZjKVhNGDwxGTvKhyXGGAMW2B/\n3bRi+aElpXwoxu3pL6fkElbX3B0BeS5LoDtxkyiVEBMZ8m+sXbocwlPyxrPbX6mY\n0rVIvnuUeBH8X0L5IwfpNVvKnBIilTbcebfHyXkPezGwz7E1yhUULjJFm2bt0SdX\ny+4X/WeiiYIv+fTVgZZgl+/2MKIsu/qdBJc3f3TvJ8nz+Eax1zgZmww+RSQWeOj3\n15Iw6Z5FX+NwzY/Ab+9PosR5UosSeq+9HhtaxZttXG1nVh+avYPGYddWmiMT90J5\nZgKnO/Fx2hBgTxhOTMYaD312kg==\n-----END CERTIFICATE-----\n\n-----BEGIN CERTIFICATE-----\nMIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\nA1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\nZ24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\nMTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\nA1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\nRgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\ngHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\nKPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\nQQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\nXriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\nDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\nLkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\nRUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\njjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\n6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\nmcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\nMx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\nWD9f\n-----END CERTIFICATE-----`;\nconst TLSProfiles = {\n    RedisCloudFixed: {\n        ca: RedisCloudCA\n    },\n    RedisCloudFlexible: {\n        ca: RedisCloudCA\n    }\n};\nexports[\"default\"] = TLSProfiles;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25zdGFudHMvVExTUHJvZmlsZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0Q7O0NBRUMsR0FDRCxNQUFNQyxlQUFlLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkEwSUcsQ0FBQztBQUMxQixNQUFNQyxjQUFjO0lBQ2hCQyxpQkFBaUI7UUFBRUMsSUFBSUg7SUFBYTtJQUNwQ0ksb0JBQW9CO1FBQUVELElBQUlIO0lBQWE7QUFDM0M7QUFDQUYsa0JBQWUsR0FBR0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0LWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2NvbnN0YW50cy9UTFNQcm9maWxlcy5qcz84MTVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUTFMgc2V0dGluZ3MgZm9yIFJlZGlzIENsb3VkLiBVcGRhdGVkIG9uIDIwMjItMDgtMTkuXG4gKi9cbmNvbnN0IFJlZGlzQ2xvdWRDQSA9IGAtLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS1cbk1JSURUekNDQWplZ0F3SUJBZ0lKQUtTVnBpRHN3TGN3TUEwR0NTcUdTSWIzRFFFQkJRVUFNRDR4RmpBVUJnTlZcbkJBb01EVWRoY21GdWRHbGhJRVJoZEdFeEpEQWlCZ05WQkFNTUcxTlRUQ0JEWlhKMGFXWnBZMkYwYVc5dUlFRjFcbmRHaHZjbWwwZVRBZUZ3MHhNekV3TURFeE1qRTBOVFZhRncweU16QTVNamt4TWpFME5UVmFNRDR4RmpBVUJnTlZcbkJBb01EVWRoY21GdWRHbGhJRVJoZEdFeEpEQWlCZ05WQkFNTUcxTlRUQ0JEWlhKMGFXWnBZMkYwYVc5dUlFRjFcbmRHaHZjbWwwZVRDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTFpxa2gvRGN6V1BcbkpueG5ITFE3UUwwVDRCNENES1dCS0NjaXNyaUdiQTZaZVBXVk5vNGhmS1FDNkpyemZSKzA4MU5lRDZWY1dVaXpcbnJtZCtqdFBoSVk0YytXVlFZbTVQS2FONkRUMWltWWR4UXc3YXFPNWoyS1VDRWgvY3pucEx4ZVNIb1R4bFIzNEVcblF3RjI4V2wzZWcydmM1Y3Q4TGpVM2VveldWazNnYjdhbHg5bVNBMlNnbXVYNWxFUWF3bCsrclNqc0JTdGVtWTJcbkJEd09wQU1YSXJkRXlQL2NWbjhta3ZpL0JEczVNNUcrMDlqMGdmaHlDelJXTVE3SG43MXUxZW9sUnh3VnhnaTNcblRNbisvdlRhRlNxeEtqZ2NrNnp1QVlqQlJQYUhlN3FMeEhOcjFTby9NYzluUHkrM3dIZWJGd2JJY25Vb2p3YnBcbjRuY3RrV2JqYjJjQ0F3RUFBYU5RTUU0d0hRWURWUjBPQkJZRUZQMXdodGNyeWRtVzNaSmV1U29LWklLanplM3dcbk1COEdBMVVkSXdRWU1CYUFGUDF3aHRjcnlkbVczWkpldVNvS1pJS2p6ZTN3TUF3R0ExVWRFd1FGTUFNQkFmOHdcbkRRWUpLb1pJaHZjTkFRRUZCUUFEZ2dFQkFHMmVyWGh3UkFhNytaT0JzMEI2WDU3SHd5ZDFSNGtmbVhjczBydGFcbmxiUHB2Z1VMU2lCK1RDYmYzRWJoSm5IR3l2ZENZMXR2bGZmTGpkQTdISjBQQ09uK1lZTEJBMHBUVS9keXZyTjZcblN1OE51UzV5dWJudDltYjEzbkRHWW8xcm50MFlSZnhOKzhETTNmWElWcjAzOEEzMFVsUFgyT3UxRXhGSlQwTVpcbnVGS1k2WnZMZEk2LzFjYmdtZ3VNbEFoTStEaEt5VjZTcjU2OTlMTTN6cWVJODE2cFptbFJFRVRZa0dyOTFxN2tcbkJwWEp1L2R0SGFHeGcxWkd1NncvUENzWUdVY0VDV0VOWUQ0VlFQZDhOMzJKak9mdTZ2RWdvRUF3ZlBQKzNvR3Bcblo0bTNld0FDY1dPQWVucWZsYitjUVlDNFBzRjdxYlhEbVJhV3JiS250T2xaM24wPVxuLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLVxuLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlHTVRDQ0JCbWdBd0lCQWdJQ0VBQXdEUVlKS29aSWh2Y05BUUVMQlFBd2FqRUxNQWtHQTFVRUJoTUNWVk14XG5DekFKQmdOVkJBZ01Ba05CTVFzd0NRWURWUVFIREFKRFFURVNNQkFHQTFVRUNnd0pVbVZrYVhOTVlXSnpNUzB3XG5Ld1lEVlFRRERDUlNaV1JwYzB4aFluTWdVbTl2ZENCRFpYSjBhV1pwWTJGMFpTQkJkWFJvYjNKcGRIa3dIaGNOXG5NVGd3TWpJMU1UVXpOek0zV2hjTk1qZ3dNakl6TVRVek56TTNXakJmTVFzd0NRWURWUVFHRXdKVlV6RUxNQWtHXG5BMVVFQ0F3Q1EwRXhFakFRQmdOVkJBb01DVkpsWkdselRHRmljekV2TUMwR0ExVUVBd3dtVWtOUUlFbHVkR1Z5XG5iV1ZrYVdGMFpTQkRaWEowYVdacFkyRjBaU0JCZFhSb2IzSnBkSGt3Z2dJaU1BMEdDU3FHU0liM0RRRUJBUVVBXG5BNElDRHdBd2dnSUtBb0lDQVFEZjlkcWJ4YzhCcTdDdHE5cldjeHJHTktLSGl2cUxBRnBQcTAyeUxQeDZmc092XG5UcTdHc0RDaEFZQkJjNHY3WTJBcDlSRDVWczNkSWhFQU5jbm9sZjI3UXdyRzlSTW5udnprOHBDdnAxbzZ6U1U0XG5WdU9FMVc2Ni9PMS83ZTJyVnh5cm5UY1A3VWdLNDN6TklYdTcrdGlBcVdzTzkydVNudU1vR1BHcGVhVW0xanltXG5oaldLdGtBd0RGU3F2SFkrWEw1cURWQkVqZVVlK1dIa1lVZzQwY0FYanVzQXFnbTJoWnQyOWMyd25WcnhXMjVXXG5QMG1lTmx6SEdGZEEyQUM1ejU0aVJpcWo1N2RUZkJUa0hvQmN6UXhjeXc2aGh6eFpRNGU1STV6T0tqWFhFaFpOXG5yMHRBM1lDMTRDVGFiS1J1cy9KbVppZXlaelJnRXkyb3RpNjR0bUxZVHFTbEFENzhwUkw0MFZOb2FTWWV0WEx3XG5oaE5zWENIZ1dhWTZkNWJMT2MvYUlRTUFWNW9MdlpRS3Z1WEFGMUlEbWhQQStiWmJwV2lwcDB6YWdmMVAxSDNzXG5VenNNZG4yS00wZWp6Z290YnRObGo1VGNyVndwbXZFM2t0dlVBdUEraGkzRmtWeDFVUysyR3NwNXg0WU96Sjd1XG5QMVdQazZTaEYwSmduSkgySUxkajZrdHRUV3dGekgxN2tlU0ZJQ1dEZkgvK2tNK2s3WTF2M0VYTVFYRTd5MFQ5XG5NanZKc2t6NmQvbnYrc1FoWTA0eHQ2NHhGTUdUblpqbEpNemZRTmk3eldGTFRabkREMGxQb3dxN2wzWWlQb1RUXG50NVhreTgzbHUwS1pzWkJvMFdsV2FERzAwZ0xWZHRSZ1ZiY3VTV3hwaTVCZExiMWtSYWI2NkpwdFdqeHdYUUlEXG5BUUFCbzRIck1JSG9NRG9HQTFVZEh3UXpNREV3TDZBdG9DdUdLV2gwZEhCek9pOHZjbXd0WTJFdGMyVnlkbVZ5XG5MbkpsWkdsemJHRmljeTVqYjIwdmRqRXZZM0pzTUVZR0NDc0dBUVVGQndFQkJEb3dPREEyQmdnckJnRUZCUWN3XG5BWVlxYUhSMGNITTZMeTl5YkMxallTMXpaWEoyWlhJdWNtVmthWE5zWVdKekxtTnZiUzkyTVM5dlkzTndNQjBHXG5BMVVkRGdRV0JCUUhhcjVPS3ZRVXBQMnFXdDZtY2t6VG9lQ09IREFmQmdOVkhTTUVHREFXZ0JRaTQyd0g2aE00XG5MMnN1akV2TE0wL3U4bFJYVHpBU0JnTlZIUk1CQWY4RUNEQUdBUUgvQWdFQU1BNEdBMVVkRHdFQi93UUVBd0lCXG5oakFOQmdrcWhraUc5dzBCQVFzRkFBT0NBZ0VBaXJFbi9pVHNBS3loZCtwdTJXM1o1TmpDa280TlBVMEVZVWJyXG5BUDcrUE9LMnJ6aklySk8zbkZZUS9MTHVDN0tDWEcrMnF3YW4yU0FPR21xV3N0MTNZK1dIcDQ0S2FlMGthQ2hXXG52Y1lMWFhTb0dRR0M4UXVGU05VZGFlZzNSYk1EWUZUMDRkT2txdWZlV1ZjY29IVnh5VFNnOWVEOExadUhuNWp3XG43UURMaUVFQ0JtSUpIazVFZW8yVEFacng0WXg2dWZTVVg1SGVWamxBenF3dEFxZHQ5OXVDSi9FTDhiZ3BXYmUrXG5Yb1NwdlV2MFNFQzFJMWRDQWhDS0F2UmxJT0E2VkJjbXpnNUFtMTJLemtxVHVsMTIvVkVGSWd6cXUwWnkySmJjXG5BVVByWVZ1Lyt0T0dYUWFpank3WWd3SDhQOG4zczdaZVVhMVZBQkpIY3hyeFlkdURESkJMWmkrTWpoZVVEYVoxXG5qUVJIWWV2STJ0bHFlU0JxZFBLRzR6Qlk1bFMwR2lBbG11emU1b0VOdDBQM1hib0hvWlBIaXFjSzNWRUNnVFZoXG4vQmtKY3V1ZEVUU0pjWkRtUThZZm9LZkJ6UlFOZzJzdi9od3ZVdjczU3M1MVNjbzhHRXQybEQ4dUVkaWIxUTZ6XG56RFQ1bFhKb3dTek9ENVpBOU9HRGpuU1JMKzJyaU50S1dLRXF2dEVHM1ZCSm9CenU5R294YkFjN3dJWkx4bWxpXG5pRjVhL1pmNVgrVVhEM3M0VE1teTZDNFFaSnBBQTJlZ3NTUUNucmFXTzJVTGhoN2lYTXlzU2tGL256VmZabjQzXG5pcXBhQjgrKzlhMzdoV3ExNFptT3YwVEpJRHovL2IyK0tDNFZGWFdRNVc1UUM2d2hzalQrT2xHNHA1WllHMGpvXG42MTZweHFvPVxuLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLVxuLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlGdWpDQ0E2S2dBd0lCQWdJSkFKMWFUVDFsdTJTY01BMEdDU3FHU0liM0RRRUJDd1VBTUdveEN6QUpCZ05WXG5CQVlUQWxWVE1Rc3dDUVlEVlFRSURBSkRRVEVMTUFrR0ExVUVCd3dDUTBFeEVqQVFCZ05WQkFvTUNWSmxaR2x6XG5UR0ZpY3pFdE1Dc0dBMVVFQXd3a1VtVmthWE5NWVdKeklGSnZiM1FnUTJWeWRHbG1hV05oZEdVZ1FYVjBhRzl5XG5hWFI1TUI0WERURTRNREl5TlRFMU1qQTBNbG9YRFRNNE1ESXlNREUxTWpBME1sb3dhakVMTUFrR0ExVUVCaE1DXG5WVk14Q3pBSkJnTlZCQWdNQWtOQk1Rc3dDUVlEVlFRSERBSkRRVEVTTUJBR0ExVUVDZ3dKVW1Wa2FYTk1ZV0p6XG5NUzB3S3dZRFZRUUREQ1JTWldScGMweGhZbk1nVW05dmRDQkRaWEowYVdacFkyRjBaU0JCZFhSb2IzSnBkSGt3XG5nZ0lpTUEwR0NTcUdTSWIzRFFFQkFRVUFBNElDRHdBd2dnSUtBb0lDQVFETEVqWHk3WXJiTjVXYWF1NWNkNmcxXG5HNUMydE1tZVRwWjBkdUZBUHhOVTRvRTNSSFM1Z0dpb2szNDZmVVh1VXhiWjZRa3V6ZU4yLzJaK1JtUmNKaFFZXG5EbTBaZ2RHNHg1OUFuMVRKZm56S0tvV2o4SVNtb0hTL1RHTkJkRnpYVjdGWU5MQnVxWm91cWVQSTZSZUM2UWhsXG5wcDQ1aHVWMzJRM2E2SURycnZ4N1dvNVpjekVRZUZOYkNlQ09RWU5EZFRtQ3lFa0hxYzJBR284ZW9JbFNUdXRUXG5VTE9DN1I1Z3pKVlRTMGUxaGVzUTdqbXFIamJPK1ZRUzFOQUw0LzVLNmN1VEVxVWwrWGhWaFBkTFdCWEpRNWFnXG41NHFoWDR2K29qTHplVTFSL1ZjNk5qTXZWdHB0V1k2SmlocGdwbHByTjBZaDI1NTZld2NYTWV0dXJjS2dYZkdKXG54ZVl6c2p6WGVyRWpyVm9jWDVWOEJOcmc2NE5saWZ6VE1LTk9PdjRmVlpzenExU0lIUjhGOVJPcnFpT2RoOGlDXG5KcFViTHBYSDloV0NTRU82VlJNQjJ4Sm9LdTNjZ2w2M2tGMzBzNzd4N3dMRk1FSGl3c1FSS3hvb0UxVWhnUzlLXG4yc080VGxRMWVXVXZGdkhTVFZEUURsR1E2enU0cWpiT3BiM1E4YlF3b0srYWkyYWxrWFZSNEx0eGU5UWxnWUszXG5TdHNuUGhydXpaR0Ewd2JYZHB3MGJuTStZZGxFbTVmZlNUcE5JZmdIZWFhN0R0YjgwMUZ0QTcxWmxIN0E2VGFJXG5TSVF1VVNUOUVLbXY3eHJKeXgwVzFwR29QT0x3NVQwMjlhVGpuSUNTTGR0VjliTHd5c3JMaElZRzViblBxNzhCXG5jUytqWkhGR3pEN1BVVkdRRDAxbk9RSURBUUFCbzJNd1lUQWRCZ05WSFE0RUZnUVVJdU5zQitvVE9DOXJMb3hMXG55ek5QN3ZKVVYwOHdId1lEVlIwakJCZ3dGb0FVSXVOc0Irb1RPQzlyTG94THl6TlA3dkpVVjA4d0R3WURWUjBUXG5BUUgvQkFVd0F3RUIvekFPQmdOVkhROEJBZjhFQkFNQ0FZWXdEUVlKS29aSWh2Y05BUUVMQlFBRGdnSUJBSGZnXG56NXBNTlVBS2RNeksxYVMxRURkSzl5S3o0cWljSUx6NWN6U0xqMW1DN0hLRFJ5OGNWQURVeEVJQ2lzKytDc0N1XG5yWU92eUNWZXJnSFFMUkVjeFBxNHJjNU5xMXVqNko2NjQ5TkVlaDRXYXpPT2pMNFpmUTFqVnpuTWJHeStmSm0zXG4zSG9lbHY2aldSRzlpcWVKWmphNy8xczZZQzZiV3ltSS9PWTFlNHdVS2VOSEFvK1ZnZXI3TWxIVitSdWFiYVgrXG5oU0o4YkpBTTU5TkNNN0FnTVRRcEpDbmNyY2RMZWNlWW5pR3k1US9xdDJiNW1Ka1FWa0lkeTRUUEdHQitBWERKXG5EMHEzSS9KRFJrRFVGTkZkZVcwanM3Zkhkc3ZDUjdPM3RKeTV6SWdFVi9vL0JDa21KVnR1d1BZT3J3L3lPbEtqXG5UWS9VN0FUQXg5VkZGNi92WUVPTVlTbXJabEZYKzk4TDZuSnR3RHFmTEI1VlRsdHFaNEgvS0J4R0UzSVJTdDlsXG5GWHk0MFUrTG5YemhoVys3VkJBdnlZWDhHRVhoSGtLVThHcWsxeGl0cnFmQlhZNzR4S2d5VVNUb2xGU2ZGVmdqXG5tY00vWDRLNDVia2ErcXBrajdLZnYvOEQ0ajZhWmVrd2hOMmx5NmhoQzFTbVE4cWpNanBHL21yV09TU0haRm1mXG55YnU5aUQyQVlIZUlPa3NoSWw2eFlJYSsrUS8wMC92czQ2SXpBYlF5cmlPaTBYeGxTTU1WdFB4MFEzaXNwK2ppXG5uOE1xOWVPdXhZT0VRNG9mOHR3VWtVRGQ1Mjhpd0d0RWR3ZjBRMDFVeVQ4NFM2Mk44QXlTbDFaQktYSno2VzRGXG5VaFdmYS9IUVlPQVBEZEVqTmduVndMSTIzYjh0MFRvenlDV3c3cThoXG4tLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tXG5cbi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxuTUlJRWp6Q0NBM2VnQXdJQkFnSVFlNTVCL0FMQ0tKRFp0ZE5UOGtENmhUQU5CZ2txaGtpRzl3MEJBUXNGQURCTVxuTVNBd0hnWURWUVFMRXhkSGJHOWlZV3hUYVdkdUlGSnZiM1FnUTBFZ0xTQlNNekVUTUJFR0ExVUVDaE1LUjJ4dlxuWW1Gc1UybG5iakVUTUJFR0ExVUVBeE1LUjJ4dlltRnNVMmxuYmpBZUZ3MHlNakF4TWpZeE1qQXdNREJhRncweVxuTlRBeE1qWXdNREF3TURCYU1GZ3hDekFKQmdOVkJBWVRBa0pGTVJrd0Z3WURWUVFLRXhCSGJHOWlZV3hUYVdkdVxuSUc1MkxYTmhNUzR3TEFZRFZRUURFeVZIYkc5aVlXeFRhV2R1SUVGMGJHRnpJRkl6SUU5V0lGUk1VeUJEUVNBeVxuTURJeUlGRXlNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQW1HbWcxTFc5YjdMZlxuOHpERDgzeUJEVEVrdCtGT3hLSlpxRjR2ZVdjNUtac1FqOUhmblVTMmU1bmovRStKSW1sR1BzUXVvaW9zTHVYRFxuQlZCTkFNY1VGYTExYnVGTUdNZUVNd2lUbUNYb1hSclhRbUgwcWpwT2ZLZ1ljNWdIRzNCc1JHYVJyZjdWUjRlZ1xub2ZOTUc5d1VCdzQvZy9UVDcrYlFKZEE0TmZFN1k0ZDVnRXJ5WmlCR0Ivc3dhWDZKcC84TUY0VGdVbU9XbWFsS1xuZFpDS3liNHNQR1FGUlR0RWxrNjdGN3ZVK3dkR2NyY094MXREY0lCMG5jakxQTW5hRmljYWdsK2RhV0dzS3FUaFxuY291blFiNlFKdFlIYTkxS3ZDZktXb2NNeFE3T0liQjVVQVJMUG1DNENKMS9mOFlGbTM1ZWJmekFlVUxZZEdYdVxuakU5Q0xvcjBPd0lEQVFBQm80SUJYekNDQVZzd0RnWURWUjBQQVFIL0JBUURBZ0dHTUIwR0ExVWRKUVFXTUJRR1xuQ0NzR0FRVUZCd01CQmdnckJnRUZCUWNEQWpBU0JnTlZIUk1CQWY4RUNEQUdBUUgvQWdFQU1CMEdBMVVkRGdRV1xuQkJTSDVacTdhN0IvdDk1R2ZKV2tEQnBBOEhIcWRqQWZCZ05WSFNNRUdEQVdnQlNQOEV0L3FDNUZKSzVOVVBwalxubW92ZTR0MGJ2REI3QmdnckJnRUZCUWNCQVFSdk1HMHdMZ1lJS3dZQkJRVUhNQUdHSW1oMGRIQTZMeTl2WTNOd1xuTWk1bmJHOWlZV3h6YVdkdUxtTnZiUzl5YjI5MGNqTXdPd1lJS3dZQkJRVUhNQUtHTDJoMGRIQTZMeTl6WldOMVxuY21VdVoyeHZZbUZzYzJsbmJpNWpiMjB2WTJGalpYSjBMM0p2YjNRdGNqTXVZM0owTURZR0ExVWRId1F2TUMwd1xuSzZBcG9DZUdKV2gwZEhBNkx5OWpjbXd1WjJ4dlltRnNjMmxuYmk1amIyMHZjbTl2ZEMxeU15NWpjbXd3SVFZRFxuVlIwZ0JCb3dHREFJQmdabmdRd0JBZ0l3REFZS0t3WUJCQUdnTWdvQkFqQU5CZ2txaGtpRzl3MEJBUXNGQUFPQ1xuQVFFQUtSaWM5L2Yrbm1oUVUvd3owNEFQWkxqZ0c1T2dzdVVPeVVFWmpLVmhOR0R3eEdUdktoeVhHR0FNVzJCL1xuM2JSaSthRWxwWHdveHUzcEw2ZmtFbGJYM0IwQmVTNUxvRHR4a3lpVkVCTVo4bStzWGJvY3dsUHl4clBiWDZtWVxuMHJWSXZudVVlQkg4WDBMNUl3ZnBOVnZLbkJJaWxUYmNlYmZIeVhrUGV6R3d6N0UxeWhVVUxqSkZtMmJ0MFNkWFxueSs0WC9XZWlpWUl2K2ZUVmdaWmdsKy8yTUtJc3UvcWRCSmMzZjNUdko4bnorRWF4MXpnWm13dytSU1FXZU9qM1xuMTVJdzZaNUZYK053elkvQWIrOVBvc1I1VW9zU2VxKzlIaHRheFp0dFhHMW5WaCthdllQR1lkZFdtaU1UOTBKNVxuWmdLbk8vRngyaEJnVHhoT1RNWWFEMzEya2c9PVxuLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLVxuXG4tLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS1cbk1JSURYekNDQWtlZ0F3SUJBZ0lMQkFBQUFBQUJJVmhUQ0tJd0RRWUpLb1pJaHZjTkFRRUxCUUF3VERFZ01CNEdcbkExVUVDeE1YUjJ4dlltRnNVMmxuYmlCU2IyOTBJRU5CSUMwZ1VqTXhFekFSQmdOVkJBb1RDa2RzYjJKaGJGTnBcbloyNHhFekFSQmdOVkJBTVRDa2RzYjJKaGJGTnBaMjR3SGhjTk1Ea3dNekU0TVRBd01EQXdXaGNOTWprd016RTRcbk1UQXdNREF3V2pCTU1TQXdIZ1lEVlFRTEV4ZEhiRzlpWVd4VGFXZHVJRkp2YjNRZ1EwRWdMU0JTTXpFVE1CRUdcbkExVUVDaE1LUjJ4dlltRnNVMmxuYmpFVE1CRUdBMVVFQXhNS1IyeHZZbUZzVTJsbmJqQ0NBU0l3RFFZSktvWklcbmh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTXdsZHBCNUJuZ2lGdlhBZzdhRXlpaWUvUVYyRWNXdGlITDhcblJnSkR4N0tLblFSZkpNc3VTK0ZnZ2tiaFVxc01nVWR3Yk4xazBldjFMS01QZ2owTUs2NlgxN1lVaGhCNXV6c1RcbmdIZU1DT0ZKMG1waUx4OWUrcFpvMzRrbmxUaWZCdGMreWNzbVdRMXozckRJNlNZT2d4WEc3MXVMMGdSZ3lrbW1cbktQWnBPL2JMeUNpUjVaMktZVmMzckhRVTNIVGdPdTV5THk2Yys5Qzd2L1U5QU9FR00raUNLNjVUcGpvV2M0emRcblFRNGdPc0MwcDZIcHNrK1FMakpnNlZmTHVRU1NhR2psT0NaZ2RiS2ZkLytSRk8rdUlFbjhyVUFWU05FQ01XRVpcblhyaVg3NjEzdDJTYWVyOWZ3UlB2bTJMN0RXemdWR2tXcVFQYWJ1bURrM0YyeG1tRmdoY0NBd0VBQWFOQ01FQXdcbkRnWURWUjBQQVFIL0JBUURBZ0VHTUE4R0ExVWRFd0VCL3dRRk1BTUJBZjh3SFFZRFZSME9CQllFRkkvd1MzK29cbkxrVWtyazFRK21PYWk5N2kzUnU4TUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFCTFFOdkFVS3IreUF6djk1WlVcblJVbTdsZ0FKUWF5ekU0YUdLQWN6eW12bWRMbTZBQzJ1cEFyVDlmSHhENHEvYzJkS2c4ZEVlM2pncjI1c2J3TXBcbmpqTTVSY09PNUxsWGJLcjhFcGJzVThZdDVDUnN1WlJqKzl4VGFHZFdQb080enpVaHc4bG8vczdhd2xPcXpKQ0tcbjZmQmRSb3lWM1hwWUtCb3ZIZDdOQURkQmorMUViZGRUS0pkKzgyY0VIaFhYaXBhMDA5NU1KNlJNRzNOemR2UVhcbm1jSWZlZzdqTFFpdENod3MvenlyVlE0UGtYNDI2OE5YU2I3aExpMThZSXZEUVZFVEk1M085ekpybEFHb21lY3Ncbk14ODZPeVhTaGtET095eUdlTWxoTHhTNjd0dFZiOStFN2dVSlRiMG8ySExPMDJKUVpSN3JrcGVETWRtenRjcEhcbldEOWZcbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1gO1xuY29uc3QgVExTUHJvZmlsZXMgPSB7XG4gICAgUmVkaXNDbG91ZEZpeGVkOiB7IGNhOiBSZWRpc0Nsb3VkQ0EgfSxcbiAgICBSZWRpc0Nsb3VkRmxleGlibGU6IHsgY2E6IFJlZGlzQ2xvdWRDQSB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRMU1Byb2ZpbGVzO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmVkaXNDbG91ZENBIiwiVExTUHJvZmlsZXMiLCJSZWRpc0Nsb3VkRml4ZWQiLCJjYSIsIlJlZGlzQ2xvdWRGbGV4aWJsZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/constants/TLSProfiles.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/errors/ClusterAllFailedError.js":
/*!********************************************************************!*\
  !*** ./node_modules/ioredis/built/errors/ClusterAllFailedError.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\");\nclass ClusterAllFailedError extends redis_errors_1.RedisError {\n    constructor(message, lastNodeError){\n        super(message);\n        this.lastNodeError = lastNodeError;\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get name() {\n        return this.constructor.name;\n    }\n}\nexports[\"default\"] = ClusterAllFailedError;\nClusterAllFailedError.defaultMessage = \"Failed to refresh slots cache.\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvQ2x1c3RlckFsbEZhaWxlZEVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGlCQUFpQkMsbUJBQU9BLENBQUMsZ0VBQWM7QUFDN0MsTUFBTUMsOEJBQThCRixlQUFlRyxVQUFVO0lBQ3pEQyxZQUFZQyxPQUFPLEVBQUVDLGFBQWEsQ0FBRTtRQUNoQyxLQUFLLENBQUNEO1FBQ04sSUFBSSxDQUFDQyxhQUFhLEdBQUdBO1FBQ3JCQyxNQUFNQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDSixXQUFXO0lBQ2xEO0lBQ0EsSUFBSUssT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDTCxXQUFXLENBQUNLLElBQUk7SUFDaEM7QUFDSjtBQUNBWCxrQkFBZSxHQUFHSTtBQUNsQkEsc0JBQXNCUyxjQUFjLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0LWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Vycm9ycy9DbHVzdGVyQWxsRmFpbGVkRXJyb3IuanM/MTFjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZGlzX2Vycm9yc18xID0gcmVxdWlyZShcInJlZGlzLWVycm9yc1wiKTtcbmNsYXNzIENsdXN0ZXJBbGxGYWlsZWRFcnJvciBleHRlbmRzIHJlZGlzX2Vycm9yc18xLlJlZGlzRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGxhc3ROb2RlRXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubGFzdE5vZGVFcnJvciA9IGxhc3ROb2RlRXJyb3I7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDbHVzdGVyQWxsRmFpbGVkRXJyb3I7XG5DbHVzdGVyQWxsRmFpbGVkRXJyb3IuZGVmYXVsdE1lc3NhZ2UgPSBcIkZhaWxlZCB0byByZWZyZXNoIHNsb3RzIGNhY2hlLlwiO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVkaXNfZXJyb3JzXzEiLCJyZXF1aXJlIiwiQ2x1c3RlckFsbEZhaWxlZEVycm9yIiwiUmVkaXNFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImxhc3ROb2RlRXJyb3IiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwibmFtZSIsImRlZmF1bHQiLCJkZWZhdWx0TWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/errors/ClusterAllFailedError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js":
/*!************************************************************************!*\
  !*** ./node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\");\nclass MaxRetriesPerRequestError extends redis_errors_1.AbortError {\n    constructor(maxRetriesPerRequest){\n        const message = `Reached the max retries per request limit (which is ${maxRetriesPerRequest}). Refer to \"maxRetriesPerRequest\" option for details.`;\n        super(message);\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get name() {\n        return this.constructor.name;\n    }\n}\nexports[\"default\"] = MaxRetriesPerRequestError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxpQkFBaUJDLG1CQUFPQSxDQUFDLGdFQUFjO0FBQzdDLE1BQU1DLGtDQUFrQ0YsZUFBZUcsVUFBVTtJQUM3REMsWUFBWUMsb0JBQW9CLENBQUU7UUFDOUIsTUFBTUMsVUFBVSxDQUFDLG9EQUFvRCxFQUFFRCxxQkFBcUIsc0RBQXNELENBQUM7UUFDbkosS0FBSyxDQUFDQztRQUNOQyxNQUFNQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDSixXQUFXO0lBQ2xEO0lBQ0EsSUFBSUssT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDTCxXQUFXLENBQUNLLElBQUk7SUFDaEM7QUFDSjtBQUNBWCxrQkFBZSxHQUFHSSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvZXJyb3JzL01heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IuanM/YTI1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZGlzX2Vycm9yc18xID0gcmVxdWlyZShcInJlZGlzLWVycm9yc1wiKTtcbmNsYXNzIE1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IgZXh0ZW5kcyByZWRpc19lcnJvcnNfMS5BYm9ydEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhSZXRyaWVzUGVyUmVxdWVzdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYFJlYWNoZWQgdGhlIG1heCByZXRyaWVzIHBlciByZXF1ZXN0IGxpbWl0ICh3aGljaCBpcyAke21heFJldHJpZXNQZXJSZXF1ZXN0fSkuIFJlZmVyIHRvIFwibWF4UmV0cmllc1BlclJlcXVlc3RcIiBvcHRpb24gZm9yIGRldGFpbHMuYDtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVkaXNfZXJyb3JzXzEiLCJyZXF1aXJlIiwiTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvciIsIkFib3J0RXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1heFJldHJpZXNQZXJSZXF1ZXN0IiwibWVzc2FnZSIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJuYW1lIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/errors/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ioredis/built/errors/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MaxRetriesPerRequestError = void 0;\nconst MaxRetriesPerRequestError_1 = __webpack_require__(/*! ./MaxRetriesPerRequestError */ \"(rsc)/./node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js\");\nexports.MaxRetriesPerRequestError = MaxRetriesPerRequestError_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlDQUFpQyxHQUFHLEtBQUs7QUFDekMsTUFBTUcsOEJBQThCQyxtQkFBT0EsQ0FBQywyR0FBNkI7QUFDekVKLGlDQUFpQyxHQUFHRyw0QkFBNEJFLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0LWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Vycm9ycy9pbmRleC5qcz8zZGNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yID0gdm9pZCAwO1xuY29uc3QgTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvcl8xID0gcmVxdWlyZShcIi4vTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvclwiKTtcbmV4cG9ydHMuTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvciA9IE1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3JfMS5kZWZhdWx0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvciIsIk1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3JfMSIsInJlcXVpcmUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/errors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ioredis/built/index.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.print = exports.ReplyError = exports.SentinelIterator = exports.SentinelConnector = exports.AbstractConnector = exports.Pipeline = exports.ScanStream = exports.Command = exports.Cluster = exports.Redis = exports[\"default\"] = void 0;\nexports = module.exports = __webpack_require__(/*! ./Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\")[\"default\"];\nvar Redis_1 = __webpack_require__(/*! ./Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return Redis_1.default;\n    }\n}));\nvar Redis_2 = __webpack_require__(/*! ./Redis */ \"(rsc)/./node_modules/ioredis/built/Redis.js\");\nObject.defineProperty(exports, \"Redis\", ({\n    enumerable: true,\n    get: function() {\n        return Redis_2.default;\n    }\n}));\nvar cluster_1 = __webpack_require__(/*! ./cluster */ \"(rsc)/./node_modules/ioredis/built/cluster/index.js\");\nObject.defineProperty(exports, \"Cluster\", ({\n    enumerable: true,\n    get: function() {\n        return cluster_1.default;\n    }\n}));\n/**\n * @ignore\n */ var Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nObject.defineProperty(exports, \"Command\", ({\n    enumerable: true,\n    get: function() {\n        return Command_1.default;\n    }\n}));\n/**\n * @ignore\n */ var ScanStream_1 = __webpack_require__(/*! ./ScanStream */ \"(rsc)/./node_modules/ioredis/built/ScanStream.js\");\nObject.defineProperty(exports, \"ScanStream\", ({\n    enumerable: true,\n    get: function() {\n        return ScanStream_1.default;\n    }\n}));\n/**\n * @ignore\n */ var Pipeline_1 = __webpack_require__(/*! ./Pipeline */ \"(rsc)/./node_modules/ioredis/built/Pipeline.js\");\nObject.defineProperty(exports, \"Pipeline\", ({\n    enumerable: true,\n    get: function() {\n        return Pipeline_1.default;\n    }\n}));\n/**\n * @ignore\n */ var AbstractConnector_1 = __webpack_require__(/*! ./connectors/AbstractConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/AbstractConnector.js\");\nObject.defineProperty(exports, \"AbstractConnector\", ({\n    enumerable: true,\n    get: function() {\n        return AbstractConnector_1.default;\n    }\n}));\n/**\n * @ignore\n */ var SentinelConnector_1 = __webpack_require__(/*! ./connectors/SentinelConnector */ \"(rsc)/./node_modules/ioredis/built/connectors/SentinelConnector/index.js\");\nObject.defineProperty(exports, \"SentinelConnector\", ({\n    enumerable: true,\n    get: function() {\n        return SentinelConnector_1.default;\n    }\n}));\nObject.defineProperty(exports, \"SentinelIterator\", ({\n    enumerable: true,\n    get: function() {\n        return SentinelConnector_1.SentinelIterator;\n    }\n}));\n// No TS typings\nexports.ReplyError = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\").ReplyError;\n/**\n * @ignore\n */ Object.defineProperty(exports, \"Promise\", ({\n    get () {\n        console.warn(\"ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.\");\n        return Promise;\n    },\n    set (_lib) {\n        console.warn(\"ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.\");\n    }\n}));\n/**\n * @ignore\n */ function print(err, reply) {\n    if (err) {\n        console.log(\"Error: \" + err);\n    } else {\n        console.log(\"Reply: \" + reply);\n    }\n}\nexports.print = print;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSxrQkFBa0IsR0FBR0Esd0JBQXdCLEdBQUdBLHlCQUF5QixHQUFHQSx5QkFBeUIsR0FBR0EsZ0JBQWdCLEdBQUdBLGtCQUFrQixHQUFHQSxlQUFlLEdBQUdBLGVBQWUsR0FBR0EsYUFBYSxHQUFHQSxrQkFBZSxHQUFHLEtBQUs7QUFDM09BLFVBQVVhLDZHQUEyQztBQUNyRCxJQUFJRSxVQUFVRCxtQkFBT0EsQ0FBQyw0REFBUztBQUMvQmhCLDJDQUEwQztJQUFFa0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsUUFBUUgsT0FBTztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzdHLElBQUlNLFVBQVVKLG1CQUFPQSxDQUFDLDREQUFTO0FBQy9CaEIseUNBQXdDO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxRQUFRTixPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDM0csSUFBSU8sWUFBWUwsbUJBQU9BLENBQUMsc0VBQVc7QUFDbkNoQiwyQ0FBMEM7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLFVBQVVQLE9BQU87SUFBRTtBQUFFLENBQUMsRUFBQztBQUMvRzs7Q0FFQyxHQUNELElBQUlRLFlBQVlOLG1CQUFPQSxDQUFDLGdFQUFXO0FBQ25DaEIsMkNBQTBDO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxVQUFVUixPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDL0c7O0NBRUMsR0FDRCxJQUFJUyxlQUFlUCxtQkFBT0EsQ0FBQyxzRUFBYztBQUN6Q2hCLDhDQUE2QztJQUFFa0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0ksYUFBYVQsT0FBTztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JIOztDQUVDLEdBQ0QsSUFBSVUsYUFBYVIsbUJBQU9BLENBQUMsa0VBQVk7QUFDckNoQiw0Q0FBMkM7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9LLFdBQVdWLE9BQU87SUFBRTtBQUFFLENBQUMsRUFBQztBQUNqSDs7Q0FFQyxHQUNELElBQUlXLHNCQUFzQlQsbUJBQU9BLENBQUMsMEdBQWdDO0FBQ2xFaEIscURBQW9EO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPTSxvQkFBb0JYLE9BQU87SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSTs7Q0FFQyxHQUNELElBQUlZLHNCQUFzQlYsbUJBQU9BLENBQUMsZ0hBQWdDO0FBQ2xFaEIscURBQW9EO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPTyxvQkFBb0JaLE9BQU87SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSWQsb0RBQW1EO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPTyxvQkFBb0JwQixnQkFBZ0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzSSxnQkFBZ0I7QUFDaEJKLHFIQUF1RDtBQUN2RDs7Q0FFQyxHQUNERiwyQ0FBMEM7SUFDdENtQjtRQUNJUSxRQUFRQyxJQUFJLENBQUM7UUFDYixPQUFPQztJQUNYO0lBQ0FDLEtBQUlDLElBQUk7UUFDSkosUUFBUUMsSUFBSSxDQUFDO0lBQ2pCO0FBQ0osQ0FBQyxFQUFDO0FBQ0Y7O0NBRUMsR0FDRCxTQUFTeEIsTUFBTTRCLEdBQUcsRUFBRUMsS0FBSztJQUNyQixJQUFJRCxLQUFLO1FBQ0xMLFFBQVFPLEdBQUcsQ0FBQyxZQUFZRjtJQUM1QixPQUNLO1FBQ0RMLFFBQVFPLEdBQUcsQ0FBQyxZQUFZRDtJQUM1QjtBQUNKO0FBQ0EvQixhQUFhLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvZHVjdC1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9pbmRleC5qcz8xZTE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcmludCA9IGV4cG9ydHMuUmVwbHlFcnJvciA9IGV4cG9ydHMuU2VudGluZWxJdGVyYXRvciA9IGV4cG9ydHMuU2VudGluZWxDb25uZWN0b3IgPSBleHBvcnRzLkFic3RyYWN0Q29ubmVjdG9yID0gZXhwb3J0cy5QaXBlbGluZSA9IGV4cG9ydHMuU2NhblN0cmVhbSA9IGV4cG9ydHMuQ29tbWFuZCA9IGV4cG9ydHMuQ2x1c3RlciA9IGV4cG9ydHMuUmVkaXMgPSBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9SZWRpc1wiKS5kZWZhdWx0O1xudmFyIFJlZGlzXzEgPSByZXF1aXJlKFwiLi9SZWRpc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJlZGlzXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBSZWRpc18yID0gcmVxdWlyZShcIi4vUmVkaXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWRpc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUmVkaXNfMi5kZWZhdWx0OyB9IH0pO1xudmFyIGNsdXN0ZXJfMSA9IHJlcXVpcmUoXCIuL2NsdXN0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbHVzdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbHVzdGVyXzEuZGVmYXVsdDsgfSB9KTtcbi8qKlxuICogQGlnbm9yZVxuICovXG52YXIgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29tbWFuZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbW1hbmRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvbW1hbmRfMS5kZWZhdWx0OyB9IH0pO1xuLyoqXG4gKiBAaWdub3JlXG4gKi9cbnZhciBTY2FuU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9TY2FuU3RyZWFtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NhblN0cmVhbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2NhblN0cmVhbV8xLmRlZmF1bHQ7IH0gfSk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xudmFyIFBpcGVsaW5lXzEgPSByZXF1aXJlKFwiLi9QaXBlbGluZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBpcGVsaW5lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQaXBlbGluZV8xLmRlZmF1bHQ7IH0gfSk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEFic3RyYWN0Q29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0b3JzL0Fic3RyYWN0Q29ubmVjdG9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RDb25uZWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFic3RyYWN0Q29ubmVjdG9yXzEuZGVmYXVsdDsgfSB9KTtcbi8qKlxuICogQGlnbm9yZVxuICovXG52YXIgU2VudGluZWxDb25uZWN0b3JfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3RvcnMvU2VudGluZWxDb25uZWN0b3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW50aW5lbENvbm5lY3RvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VudGluZWxDb25uZWN0b3JfMS5kZWZhdWx0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VudGluZWxJdGVyYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VudGluZWxDb25uZWN0b3JfMS5TZW50aW5lbEl0ZXJhdG9yOyB9IH0pO1xuLy8gTm8gVFMgdHlwaW5nc1xuZXhwb3J0cy5SZXBseUVycm9yID0gcmVxdWlyZShcInJlZGlzLWVycm9yc1wiKS5SZXBseUVycm9yO1xuLyoqXG4gKiBAaWdub3JlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb21pc2VcIiwge1xuICAgIGdldCgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiaW9yZWRpcyB2NSBkb2VzIG5vdCBzdXBwb3J0IHBsdWdnaW5nIHRoaXJkLXBhcnR5IFByb21pc2UgbGlicmFyeSBhbnltb3JlLiBOYXRpdmUgUHJvbWlzZSB3aWxsIGJlIHVzZWQuXCIpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZTtcbiAgICB9LFxuICAgIHNldChfbGliKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcImlvcmVkaXMgdjUgZG9lcyBub3Qgc3VwcG9ydCBwbHVnZ2luZyB0aGlyZC1wYXJ0eSBQcm9taXNlIGxpYnJhcnkgYW55bW9yZS4gTmF0aXZlIFByb21pc2Ugd2lsbCBiZSB1c2VkLlwiKTtcbiAgICB9LFxufSk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gcHJpbnQoZXJyLCByZXBseSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjogXCIgKyBlcnIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJSZXBseTogXCIgKyByZXBseSk7XG4gICAgfVxufVxuZXhwb3J0cy5wcmludCA9IHByaW50O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicHJpbnQiLCJSZXBseUVycm9yIiwiU2VudGluZWxJdGVyYXRvciIsIlNlbnRpbmVsQ29ubmVjdG9yIiwiQWJzdHJhY3RDb25uZWN0b3IiLCJQaXBlbGluZSIsIlNjYW5TdHJlYW0iLCJDb21tYW5kIiwiQ2x1c3RlciIsIlJlZGlzIiwiZGVmYXVsdCIsIm1vZHVsZSIsInJlcXVpcmUiLCJSZWRpc18xIiwiZW51bWVyYWJsZSIsImdldCIsIlJlZGlzXzIiLCJjbHVzdGVyXzEiLCJDb21tYW5kXzEiLCJTY2FuU3RyZWFtXzEiLCJQaXBlbGluZV8xIiwiQWJzdHJhY3RDb25uZWN0b3JfMSIsIlNlbnRpbmVsQ29ubmVjdG9yXzEiLCJjb25zb2xlIiwid2FybiIsIlByb21pc2UiLCJzZXQiLCJfbGliIiwiZXJyIiwicmVwbHkiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/redis/RedisOptions.js":
/*!**********************************************************!*\
  !*** ./node_modules/ioredis/built/redis/RedisOptions.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DEFAULT_REDIS_OPTIONS = void 0;\nexports.DEFAULT_REDIS_OPTIONS = {\n    // Connection\n    port: 6379,\n    host: \"localhost\",\n    family: 0,\n    connectTimeout: 10000,\n    disconnectTimeout: 2000,\n    retryStrategy: function(times) {\n        return Math.min(times * 50, 2000);\n    },\n    keepAlive: 0,\n    noDelay: true,\n    connectionName: null,\n    disableClientInfo: false,\n    clientInfoTag: undefined,\n    // Sentinel\n    sentinels: null,\n    name: null,\n    role: \"master\",\n    sentinelRetryStrategy: function(times) {\n        return Math.min(times * 10, 1000);\n    },\n    sentinelReconnectStrategy: function() {\n        // This strategy only applies when sentinels are used for detecting\n        // a failover, not during initial master resolution.\n        // The deployment can still function when some of the sentinels are down\n        // for a long period of time, so we may not want to attempt reconnection\n        // very often. Therefore the default interval is fairly long (1 minute).\n        return 60000;\n    },\n    natMap: null,\n    enableTLSForSentinelMode: false,\n    updateSentinels: true,\n    failoverDetector: false,\n    // Status\n    username: null,\n    password: null,\n    db: 0,\n    // Others\n    enableOfflineQueue: true,\n    enableReadyCheck: true,\n    autoResubscribe: true,\n    autoResendUnfulfilledCommands: true,\n    lazyConnect: false,\n    keyPrefix: \"\",\n    reconnectOnError: null,\n    readOnly: false,\n    stringNumbers: false,\n    maxRetriesPerRequest: 20,\n    maxLoadingRetryTime: 10000,\n    enableAutoPipelining: false,\n    autoPipeliningIgnoredCommands: [],\n    sentinelMaxConnections: 10,\n    blockingTimeoutGrace: 100\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9yZWRpcy9SZWRpc09wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckNBLDZCQUE2QixHQUFHO0lBQzVCLGFBQWE7SUFDYkcsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsZ0JBQWdCO0lBQ2hCQyxtQkFBbUI7SUFDbkJDLGVBQWUsU0FBVUMsS0FBSztRQUMxQixPQUFPQyxLQUFLQyxHQUFHLENBQUNGLFFBQVEsSUFBSTtJQUNoQztJQUNBRyxXQUFXO0lBQ1hDLFNBQVM7SUFDVEMsZ0JBQWdCO0lBQ2hCQyxtQkFBbUI7SUFDbkJDLGVBQWVDO0lBQ2YsV0FBVztJQUNYQyxXQUFXO0lBQ1hDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyx1QkFBdUIsU0FBVVosS0FBSztRQUNsQyxPQUFPQyxLQUFLQyxHQUFHLENBQUNGLFFBQVEsSUFBSTtJQUNoQztJQUNBYSwyQkFBMkI7UUFDdkIsbUVBQW1FO1FBQ25FLG9EQUFvRDtRQUNwRCx3RUFBd0U7UUFDeEUsd0VBQXdFO1FBQ3hFLHdFQUF3RTtRQUN4RSxPQUFPO0lBQ1g7SUFDQUMsUUFBUTtJQUNSQywwQkFBMEI7SUFDMUJDLGlCQUFpQjtJQUNqQkMsa0JBQWtCO0lBQ2xCLFNBQVM7SUFDVEMsVUFBVTtJQUNWQyxVQUFVO0lBQ1ZDLElBQUk7SUFDSixTQUFTO0lBQ1RDLG9CQUFvQjtJQUNwQkMsa0JBQWtCO0lBQ2xCQyxpQkFBaUI7SUFDakJDLCtCQUErQjtJQUMvQkMsYUFBYTtJQUNiQyxXQUFXO0lBQ1hDLGtCQUFrQjtJQUNsQkMsVUFBVTtJQUNWQyxlQUFlO0lBQ2ZDLHNCQUFzQjtJQUN0QkMscUJBQXFCO0lBQ3JCQyxzQkFBc0I7SUFDdEJDLCtCQUErQixFQUFFO0lBQ2pDQyx3QkFBd0I7SUFDeEJDLHNCQUFzQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvcmVkaXMvUmVkaXNPcHRpb25zLmpzPzMzY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRkFVTFRfUkVESVNfT1BUSU9OUyA9IHZvaWQgMDtcbmV4cG9ydHMuREVGQVVMVF9SRURJU19PUFRJT05TID0ge1xuICAgIC8vIENvbm5lY3Rpb25cbiAgICBwb3J0OiA2Mzc5LFxuICAgIGhvc3Q6IFwibG9jYWxob3N0XCIsXG4gICAgZmFtaWx5OiAwLFxuICAgIGNvbm5lY3RUaW1lb3V0OiAxMDAwMCxcbiAgICBkaXNjb25uZWN0VGltZW91dDogMjAwMCxcbiAgICByZXRyeVN0cmF0ZWd5OiBmdW5jdGlvbiAodGltZXMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRpbWVzICogNTAsIDIwMDApO1xuICAgIH0sXG4gICAga2VlcEFsaXZlOiAwLFxuICAgIG5vRGVsYXk6IHRydWUsXG4gICAgY29ubmVjdGlvbk5hbWU6IG51bGwsXG4gICAgZGlzYWJsZUNsaWVudEluZm86IGZhbHNlLFxuICAgIGNsaWVudEluZm9UYWc6IHVuZGVmaW5lZCxcbiAgICAvLyBTZW50aW5lbFxuICAgIHNlbnRpbmVsczogbnVsbCxcbiAgICBuYW1lOiBudWxsLFxuICAgIHJvbGU6IFwibWFzdGVyXCIsXG4gICAgc2VudGluZWxSZXRyeVN0cmF0ZWd5OiBmdW5jdGlvbiAodGltZXMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRpbWVzICogMTAsIDEwMDApO1xuICAgIH0sXG4gICAgc2VudGluZWxSZWNvbm5lY3RTdHJhdGVneTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUaGlzIHN0cmF0ZWd5IG9ubHkgYXBwbGllcyB3aGVuIHNlbnRpbmVscyBhcmUgdXNlZCBmb3IgZGV0ZWN0aW5nXG4gICAgICAgIC8vIGEgZmFpbG92ZXIsIG5vdCBkdXJpbmcgaW5pdGlhbCBtYXN0ZXIgcmVzb2x1dGlvbi5cbiAgICAgICAgLy8gVGhlIGRlcGxveW1lbnQgY2FuIHN0aWxsIGZ1bmN0aW9uIHdoZW4gc29tZSBvZiB0aGUgc2VudGluZWxzIGFyZSBkb3duXG4gICAgICAgIC8vIGZvciBhIGxvbmcgcGVyaW9kIG9mIHRpbWUsIHNvIHdlIG1heSBub3Qgd2FudCB0byBhdHRlbXB0IHJlY29ubmVjdGlvblxuICAgICAgICAvLyB2ZXJ5IG9mdGVuLiBUaGVyZWZvcmUgdGhlIGRlZmF1bHQgaW50ZXJ2YWwgaXMgZmFpcmx5IGxvbmcgKDEgbWludXRlKS5cbiAgICAgICAgcmV0dXJuIDYwMDAwO1xuICAgIH0sXG4gICAgbmF0TWFwOiBudWxsLFxuICAgIGVuYWJsZVRMU0ZvclNlbnRpbmVsTW9kZTogZmFsc2UsXG4gICAgdXBkYXRlU2VudGluZWxzOiB0cnVlLFxuICAgIGZhaWxvdmVyRGV0ZWN0b3I6IGZhbHNlLFxuICAgIC8vIFN0YXR1c1xuICAgIHVzZXJuYW1lOiBudWxsLFxuICAgIHBhc3N3b3JkOiBudWxsLFxuICAgIGRiOiAwLFxuICAgIC8vIE90aGVyc1xuICAgIGVuYWJsZU9mZmxpbmVRdWV1ZTogdHJ1ZSxcbiAgICBlbmFibGVSZWFkeUNoZWNrOiB0cnVlLFxuICAgIGF1dG9SZXN1YnNjcmliZTogdHJ1ZSxcbiAgICBhdXRvUmVzZW5kVW5mdWxmaWxsZWRDb21tYW5kczogdHJ1ZSxcbiAgICBsYXp5Q29ubmVjdDogZmFsc2UsXG4gICAga2V5UHJlZml4OiBcIlwiLFxuICAgIHJlY29ubmVjdE9uRXJyb3I6IG51bGwsXG4gICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgIHN0cmluZ051bWJlcnM6IGZhbHNlLFxuICAgIG1heFJldHJpZXNQZXJSZXF1ZXN0OiAyMCxcbiAgICBtYXhMb2FkaW5nUmV0cnlUaW1lOiAxMDAwMCxcbiAgICBlbmFibGVBdXRvUGlwZWxpbmluZzogZmFsc2UsXG4gICAgYXV0b1BpcGVsaW5pbmdJZ25vcmVkQ29tbWFuZHM6IFtdLFxuICAgIHNlbnRpbmVsTWF4Q29ubmVjdGlvbnM6IDEwLFxuICAgIGJsb2NraW5nVGltZW91dEdyYWNlOiAxMDAsXG59O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiREVGQVVMVF9SRURJU19PUFRJT05TIiwicG9ydCIsImhvc3QiLCJmYW1pbHkiLCJjb25uZWN0VGltZW91dCIsImRpc2Nvbm5lY3RUaW1lb3V0IiwicmV0cnlTdHJhdGVneSIsInRpbWVzIiwiTWF0aCIsIm1pbiIsImtlZXBBbGl2ZSIsIm5vRGVsYXkiLCJjb25uZWN0aW9uTmFtZSIsImRpc2FibGVDbGllbnRJbmZvIiwiY2xpZW50SW5mb1RhZyIsInVuZGVmaW5lZCIsInNlbnRpbmVscyIsIm5hbWUiLCJyb2xlIiwic2VudGluZWxSZXRyeVN0cmF0ZWd5Iiwic2VudGluZWxSZWNvbm5lY3RTdHJhdGVneSIsIm5hdE1hcCIsImVuYWJsZVRMU0ZvclNlbnRpbmVsTW9kZSIsInVwZGF0ZVNlbnRpbmVscyIsImZhaWxvdmVyRGV0ZWN0b3IiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiZGIiLCJlbmFibGVPZmZsaW5lUXVldWUiLCJlbmFibGVSZWFkeUNoZWNrIiwiYXV0b1Jlc3Vic2NyaWJlIiwiYXV0b1Jlc2VuZFVuZnVsZmlsbGVkQ29tbWFuZHMiLCJsYXp5Q29ubmVjdCIsImtleVByZWZpeCIsInJlY29ubmVjdE9uRXJyb3IiLCJyZWFkT25seSIsInN0cmluZ051bWJlcnMiLCJtYXhSZXRyaWVzUGVyUmVxdWVzdCIsIm1heExvYWRpbmdSZXRyeVRpbWUiLCJlbmFibGVBdXRvUGlwZWxpbmluZyIsImF1dG9QaXBlbGluaW5nSWdub3JlZENvbW1hbmRzIiwic2VudGluZWxNYXhDb25uZWN0aW9ucyIsImJsb2NraW5nVGltZW91dEdyYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/redis/RedisOptions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/redis/event_handler.js":
/*!***********************************************************!*\
  !*** ./node_modules/ioredis/built/redis/event_handler.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.readyHandler = exports.errorHandler = exports.closeHandler = exports.connectHandler = void 0;\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/./node_modules/redis-errors/index.js\");\nconst Command_1 = __webpack_require__(/*! ../Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/ioredis/built/errors/index.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst DataHandler_1 = __webpack_require__(/*! ../DataHandler */ \"(rsc)/./node_modules/ioredis/built/DataHandler.js\");\nconst debug = (0, utils_1.Debug)(\"connection\");\nfunction connectHandler(self) {\n    return function() {\n        var _a;\n        self.setStatus(\"connect\");\n        self.resetCommandQueue();\n        // AUTH command should be processed before any other commands\n        let flushed = false;\n        const { connectionEpoch } = self;\n        if (self.condition.auth) {\n            self.auth(self.condition.auth, function(err) {\n                if (connectionEpoch !== self.connectionEpoch) {\n                    return;\n                }\n                if (err) {\n                    if (err.message.indexOf(\"no password is set\") !== -1) {\n                        console.warn(\"[WARN] Redis server does not require a password, but a password was supplied.\");\n                    } else if (err.message.indexOf(\"without any password configured for the default user\") !== -1) {\n                        console.warn(\"[WARN] This Redis server's `default` user does not require a password, but a password was supplied\");\n                    } else if (err.message.indexOf(\"wrong number of arguments for 'auth' command\") !== -1) {\n                        console.warn(`[ERROR] The server returned \"wrong number of arguments for 'auth' command\". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.`);\n                    } else {\n                        flushed = true;\n                        self.recoverFromFatalError(err, err);\n                    }\n                }\n            });\n        }\n        if (self.condition.select) {\n            self.select(self.condition.select).catch((err)=>{\n                // If the node is in cluster mode, select is disallowed.\n                // In this case, reconnect won't help.\n                self.silentEmit(\"error\", err);\n            });\n        }\n        /*\n          No need to keep the reference of DataHandler here\n          because we don't need to do the cleanup.\n          `Stream#end()` will remove all listeners for us.\n        */ new DataHandler_1.default(self, {\n            stringNumbers: self.options.stringNumbers\n        });\n        const clientCommandPromises = [];\n        if (self.options.connectionName) {\n            debug(\"set the connection name [%s]\", self.options.connectionName);\n            clientCommandPromises.push(self.client(\"setname\", self.options.connectionName).catch(utils_1.noop));\n        }\n        if (!self.options.disableClientInfo) {\n            debug(\"set the client info\");\n            clientCommandPromises.push((0, utils_1.getPackageMeta)().then((packageMeta)=>{\n                return self.client(\"SETINFO\", \"LIB-VER\", packageMeta.version).catch(utils_1.noop);\n            }).catch(utils_1.noop));\n            clientCommandPromises.push(self.client(\"SETINFO\", \"LIB-NAME\", ((_a = self.options) === null || _a === void 0 ? void 0 : _a.clientInfoTag) ? `ioredis(${self.options.clientInfoTag})` : \"ioredis\").catch(utils_1.noop));\n        }\n        Promise.all(clientCommandPromises).catch(utils_1.noop).finally(()=>{\n            if (!self.options.enableReadyCheck) {\n                exports.readyHandler(self)();\n            }\n            if (self.options.enableReadyCheck) {\n                self._readyCheck(function(err, info) {\n                    if (connectionEpoch !== self.connectionEpoch) {\n                        return;\n                    }\n                    if (err) {\n                        if (!flushed) {\n                            self.recoverFromFatalError(new Error(\"Ready check failed: \" + err.message), err);\n                        }\n                    } else {\n                        if (self.connector.check(info)) {\n                            exports.readyHandler(self)();\n                        } else {\n                            self.disconnect(true);\n                        }\n                    }\n                });\n            }\n        });\n    };\n}\nexports.connectHandler = connectHandler;\nfunction abortError(command) {\n    const err = new redis_errors_1.AbortError(\"Command aborted due to connection close\");\n    err.command = {\n        name: command.name,\n        args: command.args\n    };\n    return err;\n}\n// If a contiguous set of pipeline commands starts from index zero then they\n// can be safely reattempted. If however we have a chain of pipelined commands\n// starting at index 1 or more it means we received a partial response before\n// the connection close and those pipelined commands must be aborted. For\n// example, if the queue looks like this: [2, 3, 4, 0, 1, 2] then after\n// aborting and purging we'll have a queue that looks like this: [0, 1, 2]\nfunction abortIncompletePipelines(commandQueue) {\n    var _a;\n    let expectedIndex = 0;\n    for(let i = 0; i < commandQueue.length;){\n        const command = (_a = commandQueue.peekAt(i)) === null || _a === void 0 ? void 0 : _a.command;\n        const pipelineIndex = command.pipelineIndex;\n        if (pipelineIndex === undefined || pipelineIndex === 0) {\n            expectedIndex = 0;\n        }\n        if (pipelineIndex !== undefined && pipelineIndex !== expectedIndex++) {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n            continue;\n        }\n        i++;\n    }\n}\n// If only a partial transaction result was received before connection close,\n// we have to abort any transaction fragments that may have ended up in the\n// offline queue\nfunction abortTransactionFragments(commandQueue) {\n    var _a;\n    for(let i = 0; i < commandQueue.length;){\n        const command = (_a = commandQueue.peekAt(i)) === null || _a === void 0 ? void 0 : _a.command;\n        if (command.name === \"multi\") {\n            break;\n        }\n        if (command.name === \"exec\") {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n            break;\n        }\n        if (command.inTransaction) {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n        } else {\n            i++;\n        }\n    }\n}\nfunction closeHandler(self) {\n    return function() {\n        const prevStatus = self.status;\n        self.setStatus(\"close\");\n        if (self.commandQueue.length) {\n            abortIncompletePipelines(self.commandQueue);\n        }\n        if (self.offlineQueue.length) {\n            abortTransactionFragments(self.offlineQueue);\n        }\n        if (prevStatus === \"ready\") {\n            if (!self.prevCondition) {\n                self.prevCondition = self.condition;\n            }\n            if (self.commandQueue.length) {\n                self.prevCommandQueue = self.commandQueue;\n            }\n        }\n        if (self.manuallyClosing) {\n            self.manuallyClosing = false;\n            debug(\"skip reconnecting since the connection is manually closed.\");\n            return close();\n        }\n        if (typeof self.options.retryStrategy !== \"function\") {\n            debug(\"skip reconnecting because `retryStrategy` is not a function\");\n            return close();\n        }\n        const retryDelay = self.options.retryStrategy(++self.retryAttempts);\n        if (typeof retryDelay !== \"number\") {\n            debug(\"skip reconnecting because `retryStrategy` doesn't return a number\");\n            return close();\n        }\n        debug(\"reconnect in %sms\", retryDelay);\n        self.setStatus(\"reconnecting\", retryDelay);\n        self.reconnectTimeout = setTimeout(function() {\n            self.reconnectTimeout = null;\n            self.connect().catch(utils_1.noop);\n        }, retryDelay);\n        const { maxRetriesPerRequest } = self.options;\n        if (typeof maxRetriesPerRequest === \"number\") {\n            if (maxRetriesPerRequest < 0) {\n                debug(\"maxRetriesPerRequest is negative, ignoring...\");\n            } else {\n                const remainder = self.retryAttempts % (maxRetriesPerRequest + 1);\n                if (remainder === 0) {\n                    debug(\"reach maxRetriesPerRequest limitation, flushing command queue...\");\n                    self.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));\n                }\n            }\n        }\n    };\n    function close() {\n        self.setStatus(\"end\");\n        self.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n    }\n}\nexports.closeHandler = closeHandler;\nfunction errorHandler(self) {\n    return function(error) {\n        debug(\"error: %s\", error);\n        self.silentEmit(\"error\", error);\n    };\n}\nexports.errorHandler = errorHandler;\nfunction readyHandler(self) {\n    return function() {\n        self.setStatus(\"ready\");\n        self.retryAttempts = 0;\n        if (self.options.monitor) {\n            self.call(\"monitor\").then(()=>self.setStatus(\"monitoring\"), (error)=>self.emit(\"error\", error));\n            const { sendCommand } = self;\n            self.sendCommand = function(command) {\n                if (Command_1.default.checkFlag(\"VALID_IN_MONITOR_MODE\", command.name)) {\n                    return sendCommand.call(self, command);\n                }\n                command.reject(new Error(\"Connection is in monitoring mode, can't process commands.\"));\n                return command.promise;\n            };\n            self.once(\"close\", function() {\n                delete self.sendCommand;\n            });\n            return;\n        }\n        const finalSelect = self.prevCondition ? self.prevCondition.select : self.condition.select;\n        if (self.options.readOnly) {\n            debug(\"set the connection to readonly mode\");\n            self.readonly().catch(utils_1.noop);\n        }\n        if (self.prevCondition) {\n            const condition = self.prevCondition;\n            self.prevCondition = null;\n            if (condition.subscriber && self.options.autoResubscribe) {\n                // We re-select the previous db first since\n                // `SELECT` command is not valid in sub mode.\n                if (self.condition.select !== finalSelect) {\n                    debug(\"connect to db [%d]\", finalSelect);\n                    self.select(finalSelect);\n                }\n                const subscribeChannels = condition.subscriber.channels(\"subscribe\");\n                if (subscribeChannels.length) {\n                    debug(\"subscribe %d channels\", subscribeChannels.length);\n                    self.subscribe(subscribeChannels);\n                }\n                const psubscribeChannels = condition.subscriber.channels(\"psubscribe\");\n                if (psubscribeChannels.length) {\n                    debug(\"psubscribe %d channels\", psubscribeChannels.length);\n                    self.psubscribe(psubscribeChannels);\n                }\n                const ssubscribeChannels = condition.subscriber.channels(\"ssubscribe\");\n                if (ssubscribeChannels.length) {\n                    debug(\"ssubscribe %s\", ssubscribeChannels.length);\n                    for (const channel of ssubscribeChannels){\n                        self.ssubscribe(channel);\n                    }\n                }\n            }\n        }\n        if (self.prevCommandQueue) {\n            if (self.options.autoResendUnfulfilledCommands) {\n                debug(\"resend %d unfulfilled commands\", self.prevCommandQueue.length);\n                while(self.prevCommandQueue.length > 0){\n                    const item = self.prevCommandQueue.shift();\n                    if (item.select !== self.condition.select && item.command.name !== \"select\") {\n                        self.select(item.select);\n                    }\n                    self.sendCommand(item.command, item.stream);\n                }\n            } else {\n                self.prevCommandQueue = null;\n            }\n        }\n        if (self.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", self.offlineQueue.length);\n            const offlineQueue = self.offlineQueue;\n            self.resetOfflineQueue();\n            while(offlineQueue.length > 0){\n                const item = offlineQueue.shift();\n                if (item.select !== self.condition.select && item.command.name !== \"select\") {\n                    self.select(item.select);\n                }\n                self.sendCommand(item.command, item.stream);\n            }\n        }\n        if (self.condition.select !== finalSelect) {\n            debug(\"connect to db [%d]\", finalSelect);\n            self.select(finalSelect);\n        }\n    };\n}\nexports.readyHandler = readyHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9yZWRpcy9ldmVudF9oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUdBLG9CQUFvQixHQUFHQSxzQkFBc0IsR0FBRyxLQUFLO0FBQ25HLE1BQU1NLGlCQUFpQkMsbUJBQU9BLENBQUMsZ0VBQWM7QUFDN0MsTUFBTUMsWUFBWUQsbUJBQU9BLENBQUMsaUVBQVk7QUFDdEMsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMscUVBQVc7QUFDcEMsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMsbUVBQVU7QUFDbEMsTUFBTUksZ0JBQWdCSixtQkFBT0EsQ0FBQyx5RUFBZ0I7QUFDOUMsTUFBTUssUUFBUSxDQUFDLEdBQUdGLFFBQVFHLEtBQUssRUFBRTtBQUNqQyxTQUFTUixlQUFlUyxJQUFJO0lBQ3hCLE9BQU87UUFDSCxJQUFJQztRQUNKRCxLQUFLRSxTQUFTLENBQUM7UUFDZkYsS0FBS0csaUJBQWlCO1FBQ3RCLDZEQUE2RDtRQUM3RCxJQUFJQyxVQUFVO1FBQ2QsTUFBTSxFQUFFQyxlQUFlLEVBQUUsR0FBR0w7UUFDNUIsSUFBSUEsS0FBS00sU0FBUyxDQUFDQyxJQUFJLEVBQUU7WUFDckJQLEtBQUtPLElBQUksQ0FBQ1AsS0FBS00sU0FBUyxDQUFDQyxJQUFJLEVBQUUsU0FBVUMsR0FBRztnQkFDeEMsSUFBSUgsb0JBQW9CTCxLQUFLSyxlQUFlLEVBQUU7b0JBQzFDO2dCQUNKO2dCQUNBLElBQUlHLEtBQUs7b0JBQ0wsSUFBSUEsSUFBSUMsT0FBTyxDQUFDQyxPQUFPLENBQUMsMEJBQTBCLENBQUMsR0FBRzt3QkFDbERDLFFBQVFDLElBQUksQ0FBQztvQkFDakIsT0FDSyxJQUFJSixJQUFJQyxPQUFPLENBQUNDLE9BQU8sQ0FBQyw0REFBNEQsQ0FBQyxHQUFHO3dCQUN6RkMsUUFBUUMs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QUFLOEQsZ0JBQWdCLEdBQUc7WUFDNUI7UUFDSjtRQUNBLElBQUk5RCxLQUFLNEQsWUFBWSxDQUFDVixNQUFNLEVBQUU7WUFDMUJwRCxNQUFNLHFDQUFxQ0UsS0FBSzRELFlBQVksQ0FBQ1YsTUFBTTtZQUNuRSxNQUFNVSxlQUFlNUQsS0FBSzRELFlBQVk7WUFDdEM1RCxLQUFLcUcsaUJBQWlCO1lBQ3RCLE1BQU96QyxhQUFhVixNQUFNLEdBQUcsRUFBRztnQkFDNUIsTUFBTWdELE9BQU90QyxhQUFhdUMsS0FBSztnQkFDL0IsSUFBSUQsS0FBS3BGLE1BQU0sS0FBS2QsS0FBS00sU0FBUyxDQUFDUSxNQUFNLElBQ3JDb0YsS0FBS3hELE9BQU8sQ0FBQ0UsSUFBSSxLQUFLLFVBQVU7b0JBQ2hDNUMsS0FBS2MsTUFBTSxDQUFDb0YsS0FBS3BGLE1BQU07Z0JBQzNCO2dCQUNBZCxLQUFLZ0YsV0FBVyxDQUFDa0IsS0FBS3hELE9BQU8sRUFBRXdELEtBQUtFLE1BQU07WUFDOUM7UUFDSjtRQUNBLElBQUlwRyxLQUFLTSxTQUFTLENBQUNRLE1BQU0sS0FBS3NFLGFBQWE7WUFDdkN0RixNQUFNLHNCQUFzQnNGO1lBQzVCcEYsS0FBS2MsTUFBTSxDQUFDc0U7UUFDaEI7SUFDSjtBQUNKO0FBQ0FsRyxvQkFBb0IsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0LWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L3JlZGlzL2V2ZW50X2hhbmRsZXIuanM/ZjQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVhZHlIYW5kbGVyID0gZXhwb3J0cy5lcnJvckhhbmRsZXIgPSBleHBvcnRzLmNsb3NlSGFuZGxlciA9IGV4cG9ydHMuY29ubmVjdEhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCByZWRpc19lcnJvcnNfMSA9IHJlcXVpcmUoXCJyZWRpcy1lcnJvcnNcIik7XG5jb25zdCBDb21tYW5kXzEgPSByZXF1aXJlKFwiLi4vQ29tbWFuZFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBEYXRhSGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL0RhdGFIYW5kbGVyXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJjb25uZWN0aW9uXCIpO1xuZnVuY3Rpb24gY29ubmVjdEhhbmRsZXIoc2VsZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc2VsZi5zZXRTdGF0dXMoXCJjb25uZWN0XCIpO1xuICAgICAgICBzZWxmLnJlc2V0Q29tbWFuZFF1ZXVlKCk7XG4gICAgICAgIC8vIEFVVEggY29tbWFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkIGJlZm9yZSBhbnkgb3RoZXIgY29tbWFuZHNcbiAgICAgICAgbGV0IGZsdXNoZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uRXBvY2ggfSA9IHNlbGY7XG4gICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbi5hdXRoKSB7XG4gICAgICAgICAgICBzZWxmLmF1dGgoc2VsZi5jb25kaXRpb24uYXV0aCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uRXBvY2ggIT09IHNlbGYuY29ubmVjdGlvbkVwb2NoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZihcIm5vIHBhc3N3b3JkIGlzIHNldFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOXSBSZWRpcyBzZXJ2ZXIgZG9lcyBub3QgcmVxdWlyZSBhIHBhc3N3b3JkLCBidXQgYSBwYXNzd29yZCB3YXMgc3VwcGxpZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoXCJ3aXRob3V0IGFueSBwYXNzd29yZCBjb25maWd1cmVkIGZvciB0aGUgZGVmYXVsdCB1c2VyXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5dIFRoaXMgUmVkaXMgc2VydmVyJ3MgYGRlZmF1bHRgIHVzZXIgZG9lcyBub3QgcmVxdWlyZSBhIHBhc3N3b3JkLCBidXQgYSBwYXNzd29yZCB3YXMgc3VwcGxpZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZihcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgZm9yICdhdXRoJyBjb21tYW5kXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbRVJST1JdIFRoZSBzZXJ2ZXIgcmV0dXJuZWQgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGZvciAnYXV0aCcgY29tbWFuZFwiLiBZb3UgYXJlIHByb2JhYmx5IHBhc3NpbmcgYm90aCB1c2VybmFtZSBhbmQgcGFzc3dvcmQgdG8gUmVkaXMgdmVyc2lvbiA1IG9yIGJlbG93LiBZb3Ugc2hvdWxkIG9ubHkgcGFzcyB0aGUgJ3Bhc3N3b3JkJyBvcHRpb24gZm9yIFJlZGlzIHZlcnNpb24gNSBhbmQgdW5kZXIuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVjb3ZlckZyb21GYXRhbEVycm9yKGVyciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbi5zZWxlY3QpIHtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0KHNlbGYuY29uZGl0aW9uLnNlbGVjdCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBub2RlIGlzIGluIGNsdXN0ZXIgbW9kZSwgc2VsZWN0IGlzIGRpc2FsbG93ZWQuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCByZWNvbm5lY3Qgd29uJ3QgaGVscC5cbiAgICAgICAgICAgICAgICBzZWxmLnNpbGVudEVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICBObyBuZWVkIHRvIGtlZXAgdGhlIHJlZmVyZW5jZSBvZiBEYXRhSGFuZGxlciBoZXJlXG4gICAgICAgICAgYmVjYXVzZSB3ZSBkb24ndCBuZWVkIHRvIGRvIHRoZSBjbGVhbnVwLlxuICAgICAgICAgIGBTdHJlYW0jZW5kKClgIHdpbGwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHVzLlxuICAgICAgICAqL1xuICAgICAgICBuZXcgRGF0YUhhbmRsZXJfMS5kZWZhdWx0KHNlbGYsIHtcbiAgICAgICAgICAgIHN0cmluZ051bWJlcnM6IHNlbGYub3B0aW9ucy5zdHJpbmdOdW1iZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50Q29tbWFuZFByb21pc2VzID0gW107XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuY29ubmVjdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2V0IHRoZSBjb25uZWN0aW9uIG5hbWUgWyVzXVwiLCBzZWxmLm9wdGlvbnMuY29ubmVjdGlvbk5hbWUpO1xuICAgICAgICAgICAgY2xpZW50Q29tbWFuZFByb21pc2VzLnB1c2goc2VsZi5jbGllbnQoXCJzZXRuYW1lXCIsIHNlbGYub3B0aW9ucy5jb25uZWN0aW9uTmFtZSkuY2F0Y2godXRpbHNfMS5ub29wKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWxmLm9wdGlvbnMuZGlzYWJsZUNsaWVudEluZm8pIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2V0IHRoZSBjbGllbnQgaW5mb1wiKTtcbiAgICAgICAgICAgIGNsaWVudENvbW1hbmRQcm9taXNlcy5wdXNoKCgwLCB1dGlsc18xLmdldFBhY2thZ2VNZXRhKSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHBhY2thZ2VNZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgICAgICAgICAgICAgICAgLmNsaWVudChcIlNFVElORk9cIiwgXCJMSUItVkVSXCIsIHBhY2thZ2VNZXRhLnZlcnNpb24pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2godXRpbHNfMS5ub29wKSk7XG4gICAgICAgICAgICBjbGllbnRDb21tYW5kUHJvbWlzZXMucHVzaChzZWxmXG4gICAgICAgICAgICAgICAgLmNsaWVudChcIlNFVElORk9cIiwgXCJMSUItTkFNRVwiLCAoKF9hID0gc2VsZi5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xpZW50SW5mb1RhZylcbiAgICAgICAgICAgICAgICA/IGBpb3JlZGlzKCR7c2VsZi5vcHRpb25zLmNsaWVudEluZm9UYWd9KWBcbiAgICAgICAgICAgICAgICA6IFwiaW9yZWRpc1wiKVxuICAgICAgICAgICAgICAgIC5jYXRjaCh1dGlsc18xLm5vb3ApKTtcbiAgICAgICAgfVxuICAgICAgICBQcm9taXNlLmFsbChjbGllbnRDb21tYW5kUHJvbWlzZXMpXG4gICAgICAgICAgICAuY2F0Y2godXRpbHNfMS5ub29wKVxuICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZWxmLm9wdGlvbnMuZW5hYmxlUmVhZHlDaGVjaykge1xuICAgICAgICAgICAgICAgIGV4cG9ydHMucmVhZHlIYW5kbGVyKHNlbGYpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmVuYWJsZVJlYWR5Q2hlY2spIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9yZWFkeUNoZWNrKGZ1bmN0aW9uIChlcnIsIGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25FcG9jaCAhPT0gc2VsZi5jb25uZWN0aW9uRXBvY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZsdXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlY292ZXJGcm9tRmF0YWxFcnJvcihuZXcgRXJyb3IoXCJSZWFkeSBjaGVjayBmYWlsZWQ6IFwiICsgZXJyLm1lc3NhZ2UpLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY29ubmVjdG9yLmNoZWNrKGluZm8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5yZWFkeUhhbmRsZXIoc2VsZikoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzY29ubmVjdCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5jb25uZWN0SGFuZGxlciA9IGNvbm5lY3RIYW5kbGVyO1xuZnVuY3Rpb24gYWJvcnRFcnJvcihjb21tYW5kKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IHJlZGlzX2Vycm9yc18xLkFib3J0RXJyb3IoXCJDb21tYW5kIGFib3J0ZWQgZHVlIHRvIGNvbm5lY3Rpb24gY2xvc2VcIik7XG4gICAgZXJyLmNvbW1hbmQgPSB7XG4gICAgICAgIG5hbWU6IGNvbW1hbmQubmFtZSxcbiAgICAgICAgYXJnczogY29tbWFuZC5hcmdzLFxuICAgIH07XG4gICAgcmV0dXJuIGVycjtcbn1cbi8vIElmIGEgY29udGlndW91cyBzZXQgb2YgcGlwZWxpbmUgY29tbWFuZHMgc3RhcnRzIGZyb20gaW5kZXggemVybyB0aGVuIHRoZXlcbi8vIGNhbiBiZSBzYWZlbHkgcmVhdHRlbXB0ZWQuIElmIGhvd2V2ZXIgd2UgaGF2ZSBhIGNoYWluIG9mIHBpcGVsaW5lZCBjb21tYW5kc1xuLy8gc3RhcnRpbmcgYXQgaW5kZXggMSBvciBtb3JlIGl0IG1lYW5zIHdlIHJlY2VpdmVkIGEgcGFydGlhbCByZXNwb25zZSBiZWZvcmVcbi8vIHRoZSBjb25uZWN0aW9uIGNsb3NlIGFuZCB0aG9zZSBwaXBlbGluZWQgY29tbWFuZHMgbXVzdCBiZSBhYm9ydGVkLiBGb3Jcbi8vIGV4YW1wbGUsIGlmIHRoZSBxdWV1ZSBsb29rcyBsaWtlIHRoaXM6IFsyLCAzLCA0LCAwLCAxLCAyXSB0aGVuIGFmdGVyXG4vLyBhYm9ydGluZyBhbmQgcHVyZ2luZyB3ZSdsbCBoYXZlIGEgcXVldWUgdGhhdCBsb29rcyBsaWtlIHRoaXM6IFswLCAxLCAyXVxuZnVuY3Rpb24gYWJvcnRJbmNvbXBsZXRlUGlwZWxpbmVzKGNvbW1hbmRRdWV1ZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgZXhwZWN0ZWRJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kUXVldWUubGVuZ3RoOykge1xuICAgICAgICBjb25zdCBjb21tYW5kID0gKF9hID0gY29tbWFuZFF1ZXVlLnBlZWtBdChpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbW1hbmQ7XG4gICAgICAgIGNvbnN0IHBpcGVsaW5lSW5kZXggPSBjb21tYW5kLnBpcGVsaW5lSW5kZXg7XG4gICAgICAgIGlmIChwaXBlbGluZUluZGV4ID09PSB1bmRlZmluZWQgfHwgcGlwZWxpbmVJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgZXhwZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBpcGVsaW5lSW5kZXggIT09IHVuZGVmaW5lZCAmJiBwaXBlbGluZUluZGV4ICE9PSBleHBlY3RlZEluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbW1hbmRRdWV1ZS5yZW1vdmUoaSwgMSk7XG4gICAgICAgICAgICBjb21tYW5kLnJlamVjdChhYm9ydEVycm9yKGNvbW1hbmQpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG59XG4vLyBJZiBvbmx5IGEgcGFydGlhbCB0cmFuc2FjdGlvbiByZXN1bHQgd2FzIHJlY2VpdmVkIGJlZm9yZSBjb25uZWN0aW9uIGNsb3NlLFxuLy8gd2UgaGF2ZSB0byBhYm9ydCBhbnkgdHJhbnNhY3Rpb24gZnJhZ21lbnRzIHRoYXQgbWF5IGhhdmUgZW5kZWQgdXAgaW4gdGhlXG4vLyBvZmZsaW5lIHF1ZXVlXG5mdW5jdGlvbiBhYm9ydFRyYW5zYWN0aW9uRnJhZ21lbnRzKGNvbW1hbmRRdWV1ZSkge1xuICAgIHZhciBfYTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRRdWV1ZS5sZW5ndGg7KSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSAoX2EgPSBjb21tYW5kUXVldWUucGVla0F0KGkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29tbWFuZDtcbiAgICAgICAgaWYgKGNvbW1hbmQubmFtZSA9PT0gXCJtdWx0aVwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC5uYW1lID09PSBcImV4ZWNcIikge1xuICAgICAgICAgICAgY29tbWFuZFF1ZXVlLnJlbW92ZShpLCAxKTtcbiAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KGFib3J0RXJyb3IoY29tbWFuZCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQuaW5UcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgY29tbWFuZFF1ZXVlLnJlbW92ZShpLCAxKTtcbiAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KGFib3J0RXJyb3IoY29tbWFuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvc2VIYW5kbGVyKHNlbGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBwcmV2U3RhdHVzID0gc2VsZi5zdGF0dXM7XG4gICAgICAgIHNlbGYuc2V0U3RhdHVzKFwiY2xvc2VcIik7XG4gICAgICAgIGlmIChzZWxmLmNvbW1hbmRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFib3J0SW5jb21wbGV0ZVBpcGVsaW5lcyhzZWxmLmNvbW1hbmRRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYub2ZmbGluZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbkZyYWdtZW50cyhzZWxmLm9mZmxpbmVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZTdGF0dXMgPT09IFwicmVhZHlcIikge1xuICAgICAgICAgICAgaWYgKCFzZWxmLnByZXZDb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLnByZXZDb25kaXRpb24gPSBzZWxmLmNvbmRpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbW1hbmRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnByZXZDb21tYW5kUXVldWUgPSBzZWxmLmNvbW1hbmRRdWV1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5tYW51YWxseUNsb3NpbmcpIHtcbiAgICAgICAgICAgIHNlbGYubWFudWFsbHlDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBkZWJ1ZyhcInNraXAgcmVjb25uZWN0aW5nIHNpbmNlIHRoZSBjb25uZWN0aW9uIGlzIG1hbnVhbGx5IGNsb3NlZC5cIik7XG4gICAgICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGYub3B0aW9ucy5yZXRyeVN0cmF0ZWd5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2tpcCByZWNvbm5lY3RpbmcgYmVjYXVzZSBgcmV0cnlTdHJhdGVneWAgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXRyeURlbGF5ID0gc2VsZi5vcHRpb25zLnJldHJ5U3RyYXRlZ3koKytzZWxmLnJldHJ5QXR0ZW1wdHMpO1xuICAgICAgICBpZiAodHlwZW9mIHJldHJ5RGVsYXkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2tpcCByZWNvbm5lY3RpbmcgYmVjYXVzZSBgcmV0cnlTdHJhdGVneWAgZG9lc24ndCByZXR1cm4gYSBudW1iZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInJlY29ubmVjdCBpbiAlc21zXCIsIHJldHJ5RGVsYXkpO1xuICAgICAgICBzZWxmLnNldFN0YXR1cyhcInJlY29ubmVjdGluZ1wiLCByZXRyeURlbGF5KTtcbiAgICAgICAgc2VsZi5yZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLnJlY29ubmVjdFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5jb25uZWN0KCkuY2F0Y2godXRpbHNfMS5ub29wKTtcbiAgICAgICAgfSwgcmV0cnlEZWxheSk7XG4gICAgICAgIGNvbnN0IHsgbWF4UmV0cmllc1BlclJlcXVlc3QgfSA9IHNlbGYub3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBtYXhSZXRyaWVzUGVyUmVxdWVzdCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKG1heFJldHJpZXNQZXJSZXF1ZXN0IDwgMCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwibWF4UmV0cmllc1BlclJlcXVlc3QgaXMgbmVnYXRpdmUsIGlnbm9yaW5nLi4uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluZGVyID0gc2VsZi5yZXRyeUF0dGVtcHRzICUgKG1heFJldHJpZXNQZXJSZXF1ZXN0ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmRlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInJlYWNoIG1heFJldHJpZXNQZXJSZXF1ZXN0IGxpbWl0YXRpb24sIGZsdXNoaW5nIGNvbW1hbmQgcXVldWUuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmx1c2hRdWV1ZShuZXcgZXJyb3JzXzEuTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvcihtYXhSZXRyaWVzUGVyUmVxdWVzdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHNlbGYuc2V0U3RhdHVzKFwiZW5kXCIpO1xuICAgICAgICBzZWxmLmZsdXNoUXVldWUobmV3IEVycm9yKHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKSk7XG4gICAgfVxufVxuZXhwb3J0cy5jbG9zZUhhbmRsZXIgPSBjbG9zZUhhbmRsZXI7XG5mdW5jdGlvbiBlcnJvckhhbmRsZXIoc2VsZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgZGVidWcoXCJlcnJvcjogJXNcIiwgZXJyb3IpO1xuICAgICAgICBzZWxmLnNpbGVudEVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgfTtcbn1cbmV4cG9ydHMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuZnVuY3Rpb24gcmVhZHlIYW5kbGVyKHNlbGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnNldFN0YXR1cyhcInJlYWR5XCIpO1xuICAgICAgICBzZWxmLnJldHJ5QXR0ZW1wdHMgPSAwO1xuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLm1vbml0b3IpIHtcbiAgICAgICAgICAgIHNlbGYuY2FsbChcIm1vbml0b3JcIikudGhlbigoKSA9PiBzZWxmLnNldFN0YXR1cyhcIm1vbml0b3JpbmdcIiksIChlcnJvcikgPT4gc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VuZENvbW1hbmQgfSA9IHNlbGY7XG4gICAgICAgICAgICBzZWxmLnNlbmRDb21tYW5kID0gZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoQ29tbWFuZF8xLmRlZmF1bHQuY2hlY2tGbGFnKFwiVkFMSURfSU5fTU9OSVRPUl9NT0RFXCIsIGNvbW1hbmQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRDb21tYW5kLmNhbGwoc2VsZiwgY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gaXMgaW4gbW9uaXRvcmluZyBtb2RlLCBjYW4ndCBwcm9jZXNzIGNvbW1hbmRzLlwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQucHJvbWlzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLm9uY2UoXCJjbG9zZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuc2VuZENvbW1hbmQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaW5hbFNlbGVjdCA9IHNlbGYucHJldkNvbmRpdGlvblxuICAgICAgICAgICAgPyBzZWxmLnByZXZDb25kaXRpb24uc2VsZWN0XG4gICAgICAgICAgICA6IHNlbGYuY29uZGl0aW9uLnNlbGVjdDtcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5yZWFkT25seSkge1xuICAgICAgICAgICAgZGVidWcoXCJzZXQgdGhlIGNvbm5lY3Rpb24gdG8gcmVhZG9ubHkgbW9kZVwiKTtcbiAgICAgICAgICAgIHNlbGYucmVhZG9ubHkoKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnByZXZDb25kaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHNlbGYucHJldkNvbmRpdGlvbjtcbiAgICAgICAgICAgIHNlbGYucHJldkNvbmRpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uLnN1YnNjcmliZXIgJiYgc2VsZi5vcHRpb25zLmF1dG9SZXN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlLXNlbGVjdCB0aGUgcHJldmlvdXMgZGIgZmlyc3Qgc2luY2VcbiAgICAgICAgICAgICAgICAvLyBgU0VMRUNUYCBjb21tYW5kIGlzIG5vdCB2YWxpZCBpbiBzdWIgbW9kZS5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24uc2VsZWN0ICE9PSBmaW5hbFNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3QgdG8gZGIgWyVkXVwiLCBmaW5hbFNlbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0KGZpbmFsU2VsZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlQ2hhbm5lbHMgPSBjb25kaXRpb24uc3Vic2NyaWJlci5jaGFubmVscyhcInN1YnNjcmliZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlQ2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwic3Vic2NyaWJlICVkIGNoYW5uZWxzXCIsIHN1YnNjcmliZUNoYW5uZWxzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc3Vic2NyaWJlKHN1YnNjcmliZUNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHN1YnNjcmliZUNoYW5uZWxzID0gY29uZGl0aW9uLnN1YnNjcmliZXIuY2hhbm5lbHMoXCJwc3Vic2NyaWJlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwc3Vic2NyaWJlQ2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicHN1YnNjcmliZSAlZCBjaGFubmVsc1wiLCBwc3Vic2NyaWJlQ2hhbm5lbHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wc3Vic2NyaWJlKHBzdWJzY3JpYmVDaGFubmVscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNzdWJzY3JpYmVDaGFubmVscyA9IGNvbmRpdGlvbi5zdWJzY3JpYmVyLmNoYW5uZWxzKFwic3N1YnNjcmliZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3N1YnNjcmliZUNoYW5uZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInNzdWJzY3JpYmUgJXNcIiwgc3N1YnNjcmliZUNoYW5uZWxzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hhbm5lbCBvZiBzc3Vic2NyaWJlQ2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc3N1YnNjcmliZShjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5wcmV2Q29tbWFuZFF1ZXVlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmF1dG9SZXNlbmRVbmZ1bGZpbGxlZENvbW1hbmRzKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJyZXNlbmQgJWQgdW5mdWxmaWxsZWQgY29tbWFuZHNcIiwgc2VsZi5wcmV2Q29tbWFuZFF1ZXVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNlbGYucHJldkNvbW1hbmRRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzZWxmLnByZXZDb21tYW5kUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ICE9PSBzZWxmLmNvbmRpdGlvbi5zZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5uYW1lICE9PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdChpdGVtLnNlbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZW5kQ29tbWFuZChpdGVtLmNvbW1hbmQsIGl0ZW0uc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnByZXZDb21tYW5kUXVldWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm9mZmxpbmVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2VuZCAlZCBjb21tYW5kcyBpbiBvZmZsaW5lIHF1ZXVlXCIsIHNlbGYub2ZmbGluZVF1ZXVlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBvZmZsaW5lUXVldWUgPSBzZWxmLm9mZmxpbmVRdWV1ZTtcbiAgICAgICAgICAgIHNlbGYucmVzZXRPZmZsaW5lUXVldWUoKTtcbiAgICAgICAgICAgIHdoaWxlIChvZmZsaW5lUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBvZmZsaW5lUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3QgIT09IHNlbGYuY29uZGl0aW9uLnNlbGVjdCAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbW1hbmQubmFtZSAhPT0gXCJzZWxlY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdChpdGVtLnNlbGVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuc2VuZENvbW1hbmQoaXRlbS5jb21tYW5kLCBpdGVtLnN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uLnNlbGVjdCAhPT0gZmluYWxTZWxlY3QpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdCB0byBkYiBbJWRdXCIsIGZpbmFsU2VsZWN0KTtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0KGZpbmFsU2VsZWN0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLnJlYWR5SGFuZGxlciA9IHJlYWR5SGFuZGxlcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlYWR5SGFuZGxlciIsImVycm9ySGFuZGxlciIsImNsb3NlSGFuZGxlciIsImNvbm5lY3RIYW5kbGVyIiwicmVkaXNfZXJyb3JzXzEiLCJyZXF1aXJlIiwiQ29tbWFuZF8xIiwiZXJyb3JzXzEiLCJ1dGlsc18xIiwiRGF0YUhhbmRsZXJfMSIsImRlYnVnIiwiRGVidWciLCJzZWxmIiwiX2EiLCJzZXRTdGF0dXMiLCJyZXNldENvbW1hbmRRdWV1ZSIsImZsdXNoZWQiLCJjb25uZWN0aW9uRXBvY2giLCJjb25kaXRpb24iLCJhdXRoIiwiZXJyIiwibWVzc2FnZSIsImluZGV4T2YiLCJjb25zb2xlIiwid2FybiIsInJlY292ZXJGcm9tRmF0YWxFcnJvciIsInNlbGVjdCIsImNhdGNoIiwic2lsZW50RW1pdCIsImRlZmF1bHQiLCJzdHJpbmdOdW1iZXJzIiwib3B0aW9ucyIsImNsaWVudENvbW1hbmRQcm9taXNlcyIsImNvbm5lY3Rpb25OYW1lIiwicHVzaCIsImNsaWVudCIsIm5vb3AiLCJkaXNhYmxlQ2xpZW50SW5mbyIsImdldFBhY2thZ2VNZXRhIiwidGhlbiIsInBhY2thZ2VNZXRhIiwidmVyc2lvbiIsImNsaWVudEluZm9UYWciLCJQcm9taXNlIiwiYWxsIiwiZmluYWxseSIsImVuYWJsZVJlYWR5Q2hlY2siLCJfcmVhZHlDaGVjayIsImluZm8iLCJFcnJvciIsImNvbm5lY3RvciIsImNoZWNrIiwiZGlzY29ubmVjdCIsImFib3J0RXJyb3IiLCJjb21tYW5kIiwiQWJvcnRFcnJvciIsIm5hbWUiLCJhcmdzIiwiYWJvcnRJbmNvbXBsZXRlUGlwZWxpbmVzIiwiY29tbWFuZFF1ZXVlIiwiZXhwZWN0ZWRJbmRleCIsImkiLCJsZW5ndGgiLCJwZWVrQXQiLCJwaXBlbGluZUluZGV4IiwidW5kZWZpbmVkIiwicmVtb3ZlIiwicmVqZWN0IiwiYWJvcnRUcmFuc2FjdGlvbkZyYWdtZW50cyIsImluVHJhbnNhY3Rpb24iLCJwcmV2U3RhdHVzIiwic3RhdHVzIiwib2ZmbGluZVF1ZXVlIiwicHJldkNvbmRpdGlvbiIsInByZXZDb21tYW5kUXVldWUiLCJtYW51YWxseUNsb3NpbmciLCJjbG9zZSIsInJldHJ5U3RyYXRlZ3kiLCJyZXRyeURlbGF5IiwicmV0cnlBdHRlbXB0cyIsInJlY29ubmVjdFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY29ubmVjdCIsIm1heFJldHJpZXNQZXJSZXF1ZXN0IiwicmVtYWluZGVyIiwiZmx1c2hRdWV1ZSIsIk1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IiLCJDT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0ciLCJlcnJvciIsIm1vbml0b3IiLCJjYWxsIiwiZW1pdCIsInNlbmRDb21tYW5kIiwiY2hlY2tGbGFnIiwicHJvbWlzZSIsIm9uY2UiLCJmaW5hbFNlbGVjdCIsInJlYWRPbmx5IiwicmVhZG9ubHkiLCJzdWJzY3JpYmVyIiwiYXV0b1Jlc3Vic2NyaWJlIiwic3Vic2NyaWJlQ2hhbm5lbHMiLCJjaGFubmVscyIsInN1YnNjcmliZSIsInBzdWJzY3JpYmVDaGFubmVscyIsInBzdWJzY3JpYmUiLCJzc3Vic2NyaWJlQ2hhbm5lbHMiLCJjaGFubmVsIiwic3N1YnNjcmliZSIsImF1dG9SZXNlbmRVbmZ1bGZpbGxlZENvbW1hbmRzIiwiaXRlbSIsInNoaWZ0Iiwic3RyZWFtIiwicmVzZXRPZmZsaW5lUXVldWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/redis/event_handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/transaction.js":
/*!***************************************************!*\
  !*** ./node_modules/ioredis/built/transaction.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addTransactionSupport = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ioredis/built/utils/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/./node_modules/standard-as-callback/built/index.js\");\nconst Pipeline_1 = __webpack_require__(/*! ./Pipeline */ \"(rsc)/./node_modules/ioredis/built/Pipeline.js\");\nfunction addTransactionSupport(redis) {\n    redis.pipeline = function(commands) {\n        const pipeline = new Pipeline_1.default(this);\n        if (Array.isArray(commands)) {\n            pipeline.addBatch(commands);\n        }\n        return pipeline;\n    };\n    const { multi } = redis;\n    redis.multi = function(commands, options) {\n        if (typeof options === \"undefined\" && !Array.isArray(commands)) {\n            options = commands;\n            commands = null;\n        }\n        if (options && options.pipeline === false) {\n            return multi.call(this);\n        }\n        const pipeline = new Pipeline_1.default(this);\n        // @ts-expect-error\n        pipeline.multi();\n        if (Array.isArray(commands)) {\n            pipeline.addBatch(commands);\n        }\n        const exec = pipeline.exec;\n        pipeline.exec = function(callback) {\n            // Wait for the cluster to be connected, since we need nodes information before continuing\n            if (this.isCluster && !this.redis.slots.length) {\n                if (this.redis.status === \"wait\") this.redis.connect().catch(utils_1.noop);\n                return (0, standard_as_callback_1.default)(new Promise((resolve, reject)=>{\n                    this.redis.delayUntilReady((err)=>{\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        this.exec(pipeline).then(resolve, reject);\n                    });\n                }), callback);\n            }\n            if (this._transactions > 0) {\n                exec.call(pipeline);\n            }\n            // Returns directly when the pipeline\n            // has been called multiple times (retries).\n            if (this.nodeifiedPromise) {\n                return exec.call(pipeline);\n            }\n            const promise = exec.call(pipeline);\n            return (0, standard_as_callback_1.default)(promise.then(function(result) {\n                const execResult = result[result.length - 1];\n                if (typeof execResult === \"undefined\") {\n                    throw new Error(\"Pipeline cannot be used to send any commands when the `exec()` has been called on it.\");\n                }\n                if (execResult[0]) {\n                    execResult[0].previousErrors = [];\n                    for(let i = 0; i < result.length - 1; ++i){\n                        if (result[i][0]) {\n                            execResult[0].previousErrors.push(result[i][0]);\n                        }\n                    }\n                    throw execResult[0];\n                }\n                return (0, utils_1.wrapMultiResult)(execResult[1]);\n            }), callback);\n        };\n        // @ts-expect-error\n        const { execBuffer } = pipeline;\n        // @ts-expect-error\n        pipeline.execBuffer = function(callback) {\n            if (this._transactions > 0) {\n                execBuffer.call(pipeline);\n            }\n            return pipeline.exec(callback);\n        };\n        return pipeline;\n    };\n    const { exec } = redis;\n    redis.exec = function(callback) {\n        return (0, standard_as_callback_1.default)(exec.call(this).then(function(results) {\n            if (Array.isArray(results)) {\n                results = (0, utils_1.wrapMultiResult)(results);\n            }\n            return results;\n        }), callback);\n    };\n}\nexports.addTransactionSupport = addTransactionSupport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxNQUFNRyxVQUFVQyxtQkFBT0EsQ0FBQyxrRUFBUztBQUNqQyxNQUFNQyx5QkFBeUJELG1CQUFPQSxDQUFDLHNGQUFzQjtBQUM3RCxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyxrRUFBWTtBQUN2QyxTQUFTRixzQkFBc0JLLEtBQUs7SUFDaENBLE1BQU1DLFFBQVEsR0FBRyxTQUFVQyxRQUFRO1FBQy9CLE1BQU1ELFdBQVcsSUFBSUYsV0FBV0ksT0FBTyxDQUFDLElBQUk7UUFDNUMsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxXQUFXO1lBQ3pCRCxTQUFTSyxRQUFRLENBQUNKO1FBQ3RCO1FBQ0EsT0FBT0Q7SUFDWDtJQUNBLE1BQU0sRUFBRU0sS0FBSyxFQUFFLEdBQUdQO0lBQ2xCQSxNQUFNTyxLQUFLLEdBQUcsU0FBVUwsUUFBUSxFQUFFTSxPQUFPO1FBQ3JDLElBQUksT0FBT0EsWUFBWSxlQUFlLENBQUNKLE1BQU1DLE9BQU8sQ0FBQ0gsV0FBVztZQUM1RE0sVUFBVU47WUFDVkEsV0FBVztRQUNmO1FBQ0EsSUFBSU0sV0FBV0EsUUFBUVAsUUFBUSxLQUFLLE9BQU87WUFDdkMsT0FBT00sTUFBTUUsSUFBSSxDQUFDLElBQUk7UUFDMUI7UUFDQSxNQUFNUixXQUFXLElBQUlGLFdBQVdJLE9BQU8sQ0FBQyxJQUFJO1FBQzVDLG1CQUFtQjtRQUNuQkYsU0FBU00sS0FBSztRQUNkLElBQUlILE1BQU1DLE9BQU8sQ0FBQ0gsV0FBVztZQUN6QkQsU0FBU0ssUUFBUSxDQUFDSjtRQUN0QjtRQUNBLE1BQU1RLE9BQU9ULFNBQVNTLElBQUk7UUFDMUJULFNBQVNTLElBQUksR0FBRyxTQUFVQyxRQUFRO1lBQzlCLDBGQUEwRjtZQUMxRixJQUFJLElBQUksQ0FBQ0MsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDWixLQUFLLENBQUNhLEtBQUssQ0FBQ0MsTUFBTSxFQUFFO2dCQUM1QyxJQUFJLElBQUksQ0FBQ2QsS0FBSyxDQUFDZSxNQUFNLEtBQUssUUFDdEIsSUFBSSxDQUFDZixLQUFLLENBQUNnQixPQUFPLEdBQUdDLEtBQUssQ0FBQ3JCLFFBQVFzQixJQUFJO2dCQUMzQyxPQUFPLENBQUMsR0FBR3BCLHVCQUF1QkssT0FBTyxFQUFFLElBQUlnQixRQUFRLENBQUNDLFNBQVNDO29CQUM3RCxJQUFJLENBQUNyQixLQUFLLENBQUNzQixlQUFlLENBQUMsQ0FBQ0M7d0JBQ3hCLElBQUlBLEtBQUs7NEJBQ0xGLE9BQU9FOzRCQUNQO3dCQUNKO3dCQUNBLElBQUksQ0FBQ2IsSUFBSSxDQUFDVCxVQUFVdUIsSUFBSSxDQUFDSixTQUFTQztvQkFDdEM7Z0JBQ0osSUFBSVY7WUFDUjtZQUNBLElBQUksSUFBSSxDQUFDYyxhQUFhLEdBQUcsR0FBRztnQkFDeEJmLEtBQUtELElBQUksQ0FBQ1I7WUFDZDtZQUNBLHFDQUFxQztZQUNyQyw0Q0FBNEM7WUFDNUMsSUFBSSxJQUFJLENBQUN5QixnQkFBZ0IsRUFBRTtnQkFDdkIsT0FBT2hCLEtBQUtELElBQUksQ0FBQ1I7WUFDckI7WUFDQSxNQUFNMEIsVUFBVWpCLEtBQUtELElBQUksQ0FBQ1I7WUFDMUIsT0FBTyxDQUFDLEdBQUdILHVCQUF1QkssT0FBTyxFQUFFd0IsUUFBUUgsSUFBSSxDQUFDLFNBQVVJLE1BQU07Z0JBQ3BFLE1BQU1DLGFBQWFELE1BQU0sQ0FBQ0EsT0FBT2QsTUFBTSxHQUFHLEVBQUU7Z0JBQzVDLElBQUksT0FBT2UsZUFBZSxhQUFhO29CQUNuQyxNQUFNLElBQUlDLE1BQU07Z0JBQ3BCO2dCQUNBLElBQUlELFVBQVUsQ0FBQyxFQUFFLEVBQUU7b0JBQ2ZBLFVBQVUsQ0FBQyxFQUFFLENBQUNFLGNBQWMsR0FBRyxFQUFFO29CQUNqQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosT0FBT2QsTUFBTSxHQUFHLEdBQUcsRUFBRWtCLEVBQUc7d0JBQ3hDLElBQUlKLE1BQU0sQ0FBQ0ksRUFBRSxDQUFDLEVBQUUsRUFBRTs0QkFDZEgsVUFBVSxDQUFDLEVBQUUsQ0FBQ0UsY0FBYyxDQUFDRSxJQUFJLENBQUNMLE1BQU0sQ0FBQ0ksRUFBRSxDQUFDLEVBQUU7d0JBQ2xEO29CQUNKO29CQUNBLE1BQU1ILFVBQVUsQ0FBQyxFQUFFO2dCQUN2QjtnQkFDQSxPQUFPLENBQUMsR0FBR2pDLFFBQVFzQyxlQUFlLEVBQUVMLFVBQVUsQ0FBQyxFQUFFO1lBQ3JELElBQUlsQjtRQUNSO1FBQ0EsbUJBQW1CO1FBQ25CLE1BQU0sRUFBRXdCLFVBQVUsRUFBRSxHQUFHbEM7UUFDdkIsbUJBQW1CO1FBQ25CQSxTQUFTa0MsVUFBVSxHQUFHLFNBQVV4QixRQUFRO1lBQ3BDLElBQUksSUFBSSxDQUFDYyxhQUFhLEdBQUcsR0FBRztnQkFDeEJVLFdBQVcxQixJQUFJLENBQUNSO1lBQ3BCO1lBQ0EsT0FBT0EsU0FBU1MsSUFBSSxDQUFDQztRQUN6QjtRQUNBLE9BQU9WO0lBQ1g7SUFDQSxNQUFNLEVBQUVTLElBQUksRUFBRSxHQUFHVjtJQUNqQkEsTUFBTVUsSUFBSSxHQUFHLFNBQVVDLFFBQVE7UUFDM0IsT0FBTyxDQUFDLEdBQUdiLHVCQUF1QkssT0FBTyxFQUFFTyxLQUFLRCxJQUFJLENBQUMsSUFBSSxFQUFFZSxJQUFJLENBQUMsU0FBVVksT0FBTztZQUM3RSxJQUFJaEMsTUFBTUMsT0FBTyxDQUFDK0IsVUFBVTtnQkFDeEJBLFVBQVUsQ0FBQyxHQUFHeEMsUUFBUXNDLGVBQWUsRUFBRUU7WUFDM0M7WUFDQSxPQUFPQTtRQUNYLElBQUl6QjtJQUNSO0FBQ0o7QUFDQWxCLDZCQUE2QixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdHJhbnNhY3Rpb24uanM/ZjgxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkVHJhbnNhY3Rpb25TdXBwb3J0ID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3Qgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMSA9IHJlcXVpcmUoXCJzdGFuZGFyZC1hcy1jYWxsYmFja1wiKTtcbmNvbnN0IFBpcGVsaW5lXzEgPSByZXF1aXJlKFwiLi9QaXBlbGluZVwiKTtcbmZ1bmN0aW9uIGFkZFRyYW5zYWN0aW9uU3VwcG9ydChyZWRpcykge1xuICAgIHJlZGlzLnBpcGVsaW5lID0gZnVuY3Rpb24gKGNvbW1hbmRzKSB7XG4gICAgICAgIGNvbnN0IHBpcGVsaW5lID0gbmV3IFBpcGVsaW5lXzEuZGVmYXVsdCh0aGlzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29tbWFuZHMpKSB7XG4gICAgICAgICAgICBwaXBlbGluZS5hZGRCYXRjaChjb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGVsaW5lO1xuICAgIH07XG4gICAgY29uc3QgeyBtdWx0aSB9ID0gcmVkaXM7XG4gICAgcmVkaXMubXVsdGkgPSBmdW5jdGlvbiAoY29tbWFuZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiICYmICFBcnJheS5pc0FycmF5KGNvbW1hbmRzKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbW1hbmRzO1xuICAgICAgICAgICAgY29tbWFuZHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGlwZWxpbmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbXVsdGkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaXBlbGluZSA9IG5ldyBQaXBlbGluZV8xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcGlwZWxpbmUubXVsdGkoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29tbWFuZHMpKSB7XG4gICAgICAgICAgICBwaXBlbGluZS5hZGRCYXRjaChjb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhlYyA9IHBpcGVsaW5lLmV4ZWM7XG4gICAgICAgIHBpcGVsaW5lLmV4ZWMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBjbHVzdGVyIHRvIGJlIGNvbm5lY3RlZCwgc2luY2Ugd2UgbmVlZCBub2RlcyBpbmZvcm1hdGlvbiBiZWZvcmUgY29udGludWluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDbHVzdGVyICYmICF0aGlzLnJlZGlzLnNsb3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZGlzLnN0YXR1cyA9PT0gXCJ3YWl0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuY29ubmVjdCgpLmNhdGNoKHV0aWxzXzEubm9vcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5kZWxheVVudGlsUmVhZHkoKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhlYyhwaXBlbGluZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9ucyA+IDApIHtcbiAgICAgICAgICAgICAgICBleGVjLmNhbGwocGlwZWxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJucyBkaXJlY3RseSB3aGVuIHRoZSBwaXBlbGluZVxuICAgICAgICAgICAgLy8gaGFzIGJlZW4gY2FsbGVkIG11bHRpcGxlIHRpbWVzIChyZXRyaWVzKS5cbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVpZmllZFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhlYy5jYWxsKHBpcGVsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBleGVjLmNhbGwocGlwZWxpbmUpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhlY1Jlc3VsdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleGVjUmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBpcGVsaW5lIGNhbm5vdCBiZSB1c2VkIHRvIHNlbmQgYW55IGNvbW1hbmRzIHdoZW4gdGhlIGBleGVjKClgIGhhcyBiZWVuIGNhbGxlZCBvbiBpdC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleGVjUmVzdWx0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbMF0ucHJldmlvdXNFcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0W2ldWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY1Jlc3VsdFswXS5wcmV2aW91c0Vycm9ycy5wdXNoKHJlc3VsdFtpXVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXhlY1Jlc3VsdFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLndyYXBNdWx0aVJlc3VsdCkoZXhlY1Jlc3VsdFsxXSk7XG4gICAgICAgICAgICB9KSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHsgZXhlY0J1ZmZlciB9ID0gcGlwZWxpbmU7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcGlwZWxpbmUuZXhlY0J1ZmZlciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9ucyA+IDApIHtcbiAgICAgICAgICAgICAgICBleGVjQnVmZmVyLmNhbGwocGlwZWxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBpcGVsaW5lLmV4ZWMoY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGlwZWxpbmU7XG4gICAgfTtcbiAgICBjb25zdCB7IGV4ZWMgfSA9IHJlZGlzO1xuICAgIHJlZGlzLmV4ZWMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKGV4ZWMuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSAoMCwgdXRpbHNfMS53cmFwTXVsdGlSZXN1bHQpKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cbmV4cG9ydHMuYWRkVHJhbnNhY3Rpb25TdXBwb3J0ID0gYWRkVHJhbnNhY3Rpb25TdXBwb3J0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWRkVHJhbnNhY3Rpb25TdXBwb3J0IiwidXRpbHNfMSIsInJlcXVpcmUiLCJzdGFuZGFyZF9hc19jYWxsYmFja18xIiwiUGlwZWxpbmVfMSIsInJlZGlzIiwicGlwZWxpbmUiLCJjb21tYW5kcyIsImRlZmF1bHQiLCJBcnJheSIsImlzQXJyYXkiLCJhZGRCYXRjaCIsIm11bHRpIiwib3B0aW9ucyIsImNhbGwiLCJleGVjIiwiY2FsbGJhY2siLCJpc0NsdXN0ZXIiLCJzbG90cyIsImxlbmd0aCIsInN0YXR1cyIsImNvbm5lY3QiLCJjYXRjaCIsIm5vb3AiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImRlbGF5VW50aWxSZWFkeSIsImVyciIsInRoZW4iLCJfdHJhbnNhY3Rpb25zIiwibm9kZWlmaWVkUHJvbWlzZSIsInByb21pc2UiLCJyZXN1bHQiLCJleGVjUmVzdWx0IiwiRXJyb3IiLCJwcmV2aW91c0Vycm9ycyIsImkiLCJwdXNoIiwid3JhcE11bHRpUmVzdWx0IiwiZXhlY0J1ZmZlciIsInJlc3VsdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/transaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/Commander.js":
/*!*******************************************************!*\
  !*** ./node_modules/ioredis/built/utils/Commander.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/./node_modules/@ioredis/commands/built/index.js\");\nconst autoPipelining_1 = __webpack_require__(/*! ../autoPipelining */ \"(rsc)/./node_modules/ioredis/built/autoPipelining.js\");\nconst Command_1 = __webpack_require__(/*! ../Command */ \"(rsc)/./node_modules/ioredis/built/Command.js\");\nconst Script_1 = __webpack_require__(/*! ../Script */ \"(rsc)/./node_modules/ioredis/built/Script.js\");\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nclass Commander {\n    constructor(){\n        this.options = {};\n        /**\n         * @ignore\n         */ this.scriptsSet = {};\n        /**\n         * @ignore\n         */ this.addedBuiltinSet = new Set();\n    }\n    /**\n     * Return supported builtin commands\n     */ getBuiltinCommands() {\n        return commands.slice(0);\n    }\n    /**\n     * Create a builtin command\n     */ createBuiltinCommand(commandName) {\n        return {\n            string: generateFunction(null, commandName, \"utf8\"),\n            buffer: generateFunction(null, commandName, null)\n        };\n    }\n    /**\n     * Create add builtin command\n     */ addBuiltinCommand(commandName) {\n        this.addedBuiltinSet.add(commandName);\n        this[commandName] = generateFunction(commandName, commandName, \"utf8\");\n        this[commandName + \"Buffer\"] = generateFunction(commandName + \"Buffer\", commandName, null);\n    }\n    /**\n     * Define a custom command using lua script\n     */ defineCommand(name, definition) {\n        const script = new Script_1.default(definition.lua, definition.numberOfKeys, this.options.keyPrefix, definition.readOnly);\n        this.scriptsSet[name] = script;\n        this[name] = generateScriptingFunction(name, name, script, \"utf8\");\n        this[name + \"Buffer\"] = generateScriptingFunction(name + \"Buffer\", name, script, null);\n    }\n    /**\n     * @ignore\n     */ sendCommand(command, stream, node) {\n        throw new Error('\"sendCommand\" is not implemented');\n    }\n}\nconst commands = commands_1.list.filter((command)=>command !== \"monitor\");\ncommands.push(\"sentinel\");\ncommands.forEach(function(commandName) {\n    Commander.prototype[commandName] = generateFunction(commandName, commandName, \"utf8\");\n    Commander.prototype[commandName + \"Buffer\"] = generateFunction(commandName + \"Buffer\", commandName, null);\n});\nCommander.prototype.call = generateFunction(\"call\", \"utf8\");\nCommander.prototype.callBuffer = generateFunction(\"callBuffer\", null);\n// @ts-expect-error\nCommander.prototype.send_command = Commander.prototype.call;\nfunction generateFunction(functionName, _commandName, _encoding) {\n    if (typeof _encoding === \"undefined\") {\n        _encoding = _commandName;\n        _commandName = null;\n    }\n    return function(...args) {\n        const commandName = _commandName || args.shift();\n        let callback = args[args.length - 1];\n        if (typeof callback === \"function\") {\n            args.pop();\n        } else {\n            callback = undefined;\n        }\n        const options = {\n            errorStack: this.options.showFriendlyErrorStack ? new Error() : undefined,\n            keyPrefix: this.options.keyPrefix,\n            replyEncoding: _encoding\n        };\n        // No auto pipeline, use regular command sending\n        if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {\n            return this.sendCommand(// @ts-expect-error\n            new Command_1.default(commandName, args, options, callback));\n        }\n        // Create a new pipeline and make sure it's scheduled\n        return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, // @ts-expect-error\n        args, callback);\n    };\n}\nfunction generateScriptingFunction(functionName, commandName, script, encoding) {\n    return function(...args) {\n        const callback = typeof args[args.length - 1] === \"function\" ? args.pop() : undefined;\n        const options = {\n            replyEncoding: encoding\n        };\n        if (this.options.showFriendlyErrorStack) {\n            options.errorStack = new Error();\n        }\n        // No auto pipeline, use regular command sending\n        if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {\n            return script.execute(this, args, options, callback);\n        }\n        // Create a new pipeline and make sure it's scheduled\n        return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, args, callback);\n    };\n}\nexports[\"default\"] = Commander;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9Db21tYW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsYUFBYUMsbUJBQU9BLENBQUMsZ0ZBQW1CO0FBQzlDLE1BQU1DLG1CQUFtQkQsbUJBQU9BLENBQUMsK0VBQW1CO0FBQ3BELE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDLGlFQUFZO0FBQ3RDLE1BQU1HLFdBQVdILG1CQUFPQSxDQUFDLCtEQUFXO0FBQ3BDLDZEQUE2RDtBQUM3RCxNQUFNSTtJQUNGQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxPQUFPLEdBQUcsQ0FBQztRQUNoQjs7U0FFQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUM7UUFDbkI7O1NBRUMsR0FDRCxJQUFJLENBQUNDLGVBQWUsR0FBRyxJQUFJQztJQUMvQjtJQUNBOztLQUVDLEdBQ0RDLHFCQUFxQjtRQUNqQixPQUFPQyxTQUFTQyxLQUFLLENBQUM7SUFDMUI7SUFDQTs7S0FFQyxHQUNEQyxxQkFBcUJDLFdBQVcsRUFBRTtRQUM5QixPQUFPO1lBQ0hDLFFBQVFDLGlCQUFpQixNQUFNRixhQUFhO1lBQzVDRyxRQUFRRCxpQkFBaUIsTUFBTUYsYUFBYTtRQUNoRDtJQUNKO0lBQ0E7O0tBRUMsR0FDREksa0JBQWtCSixXQUFXLEVBQUU7UUFDM0IsSUFBSSxDQUFDTixlQUFlLENBQUNXLEdBQUcsQ0FBQ0w7UUFDekIsSUFBSSxDQUFDQSxZQUFZLEdBQUdFLGlCQUFpQkYsYUFBYUEsYUFBYTtRQUMvRCxJQUFJLENBQUNBLGNBQWMsU0FBUyxHQUFHRSxpQkFBaUJGLGNBQWMsVUFBVUEsYUFBYTtJQUN6RjtJQUNBOztLQUVDLEdBQ0RNLGNBQWNDLElBQUksRUFBRUMsVUFBVSxFQUFFO1FBQzVCLE1BQU1DLFNBQVMsSUFBSXBCLFNBQVNxQixPQUFPLENBQUNGLFdBQVdHLEdBQUcsRUFB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aUJzRCx1QkFBdUIsRUFBRSxJQUFJLEVBQUVaLGNBQWM3QixjQUFjO1lBQ2pGLE9BQU9TLE9BQU9tQyxPQUFPLENBQUMsSUFBSSxFQUFFWixNQUFNeEMsU0FBUzBDO1FBQy9DO1FBQ0EscURBQXFEO1FBQ3JELE9BQU8sQ0FBQyxHQUFHL0MsaUJBQWlCdUQseUJBQXlCLEVBQUUsSUFBSSxFQUFFYixjQUFjN0IsYUFBYWdDLE1BQU1FO0lBQ2xHO0FBQ0o7QUFDQW5ELGtCQUFlLEdBQUdPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvZHVjdC1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9Db21tYW5kZXIuanM/OWM5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiQGlvcmVkaXMvY29tbWFuZHNcIik7XG5jb25zdCBhdXRvUGlwZWxpbmluZ18xID0gcmVxdWlyZShcIi4uL2F1dG9QaXBlbGluaW5nXCIpO1xuY29uc3QgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4uL0NvbW1hbmRcIik7XG5jb25zdCBTY3JpcHRfMSA9IHJlcXVpcmUoXCIuLi9TY3JpcHRcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5jbGFzcyBDb21tYW5kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NyaXB0c1NldCA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZGRlZEJ1aWx0aW5TZXQgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBzdXBwb3J0ZWQgYnVpbHRpbiBjb21tYW5kc1xuICAgICAqL1xuICAgIGdldEJ1aWx0aW5Db21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNsaWNlKDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBidWlsdGluIGNvbW1hbmRcbiAgICAgKi9cbiAgICBjcmVhdGVCdWlsdGluQ29tbWFuZChjb21tYW5kTmFtZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RyaW5nOiBnZW5lcmF0ZUZ1bmN0aW9uKG51bGwsIGNvbW1hbmROYW1lLCBcInV0ZjhcIiksXG4gICAgICAgICAgICBidWZmZXI6IGdlbmVyYXRlRnVuY3Rpb24obnVsbCwgY29tbWFuZE5hbWUsIG51bGwpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYWRkIGJ1aWx0aW4gY29tbWFuZFxuICAgICAqL1xuICAgIGFkZEJ1aWx0aW5Db21tYW5kKGNvbW1hbmROYW1lKSB7XG4gICAgICAgIHRoaXMuYWRkZWRCdWlsdGluU2V0LmFkZChjb21tYW5kTmFtZSk7XG4gICAgICAgIHRoaXNbY29tbWFuZE5hbWVdID0gZ2VuZXJhdGVGdW5jdGlvbihjb21tYW5kTmFtZSwgY29tbWFuZE5hbWUsIFwidXRmOFwiKTtcbiAgICAgICAgdGhpc1tjb21tYW5kTmFtZSArIFwiQnVmZmVyXCJdID0gZ2VuZXJhdGVGdW5jdGlvbihjb21tYW5kTmFtZSArIFwiQnVmZmVyXCIsIGNvbW1hbmROYW1lLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lIGEgY3VzdG9tIGNvbW1hbmQgdXNpbmcgbHVhIHNjcmlwdFxuICAgICAqL1xuICAgIGRlZmluZUNvbW1hbmQobmFtZSwgZGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBzY3JpcHQgPSBuZXcgU2NyaXB0XzEuZGVmYXVsdChkZWZpbml0aW9uLmx1YSwgZGVmaW5pdGlvbi5udW1iZXJPZktleXMsIHRoaXMub3B0aW9ucy5rZXlQcmVmaXgsIGRlZmluaXRpb24ucmVhZE9ubHkpO1xuICAgICAgICB0aGlzLnNjcmlwdHNTZXRbbmFtZV0gPSBzY3JpcHQ7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBnZW5lcmF0ZVNjcmlwdGluZ0Z1bmN0aW9uKG5hbWUsIG5hbWUsIHNjcmlwdCwgXCJ1dGY4XCIpO1xuICAgICAgICB0aGlzW25hbWUgKyBcIkJ1ZmZlclwiXSA9IGdlbmVyYXRlU2NyaXB0aW5nRnVuY3Rpb24obmFtZSArIFwiQnVmZmVyXCIsIG5hbWUsIHNjcmlwdCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBzZW5kQ29tbWFuZChjb21tYW5kLCBzdHJlYW0sIG5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNlbmRDb21tYW5kXCIgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxufVxuY29uc3QgY29tbWFuZHMgPSBjb21tYW5kc18xLmxpc3QuZmlsdGVyKChjb21tYW5kKSA9PiBjb21tYW5kICE9PSBcIm1vbml0b3JcIik7XG5jb21tYW5kcy5wdXNoKFwic2VudGluZWxcIik7XG5jb21tYW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21tYW5kTmFtZSkge1xuICAgIENvbW1hbmRlci5wcm90b3R5cGVbY29tbWFuZE5hbWVdID0gZ2VuZXJhdGVGdW5jdGlvbihjb21tYW5kTmFtZSwgY29tbWFuZE5hbWUsIFwidXRmOFwiKTtcbiAgICBDb21tYW5kZXIucHJvdG90eXBlW2NvbW1hbmROYW1lICsgXCJCdWZmZXJcIl0gPSBnZW5lcmF0ZUZ1bmN0aW9uKGNvbW1hbmROYW1lICsgXCJCdWZmZXJcIiwgY29tbWFuZE5hbWUsIG51bGwpO1xufSk7XG5Db21tYW5kZXIucHJvdG90eXBlLmNhbGwgPSBnZW5lcmF0ZUZ1bmN0aW9uKFwiY2FsbFwiLCBcInV0ZjhcIik7XG5Db21tYW5kZXIucHJvdG90eXBlLmNhbGxCdWZmZXIgPSBnZW5lcmF0ZUZ1bmN0aW9uKFwiY2FsbEJ1ZmZlclwiLCBudWxsKTtcbi8vIEB0cy1leHBlY3QtZXJyb3JcbkNvbW1hbmRlci5wcm90b3R5cGUuc2VuZF9jb21tYW5kID0gQ29tbWFuZGVyLnByb3RvdHlwZS5jYWxsO1xuZnVuY3Rpb24gZ2VuZXJhdGVGdW5jdGlvbihmdW5jdGlvbk5hbWUsIF9jb21tYW5kTmFtZSwgX2VuY29kaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBfZW5jb2RpbmcgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgX2VuY29kaW5nID0gX2NvbW1hbmROYW1lO1xuICAgICAgICBfY29tbWFuZE5hbWUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgY29tbWFuZE5hbWUgPSAoX2NvbW1hbmROYW1lIHx8IGFyZ3Muc2hpZnQoKSk7XG4gICAgICAgIGxldCBjYWxsYmFjayA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGVycm9yU3RhY2s6IHRoaXMub3B0aW9ucy5zaG93RnJpZW5kbHlFcnJvclN0YWNrID8gbmV3IEVycm9yKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBrZXlQcmVmaXg6IHRoaXMub3B0aW9ucy5rZXlQcmVmaXgsXG4gICAgICAgICAgICByZXBseUVuY29kaW5nOiBfZW5jb2RpbmcsXG4gICAgICAgIH07XG4gICAgICAgIC8vIE5vIGF1dG8gcGlwZWxpbmUsIHVzZSByZWd1bGFyIGNvbW1hbmQgc2VuZGluZ1xuICAgICAgICBpZiAoISgwLCBhdXRvUGlwZWxpbmluZ18xLnNob3VsZFVzZUF1dG9QaXBlbGluaW5nKSh0aGlzLCBmdW5jdGlvbk5hbWUsIGNvbW1hbmROYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZENvbW1hbmQoXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBuZXcgQ29tbWFuZF8xLmRlZmF1bHQoY29tbWFuZE5hbWUsIGFyZ3MsIG9wdGlvbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBpcGVsaW5lIGFuZCBtYWtlIHN1cmUgaXQncyBzY2hlZHVsZWRcbiAgICAgICAgcmV0dXJuICgwLCBhdXRvUGlwZWxpbmluZ18xLmV4ZWN1dGVXaXRoQXV0b1BpcGVsaW5pbmcpKHRoaXMsIGZ1bmN0aW9uTmFtZSwgY29tbWFuZE5hbWUsIFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGFyZ3MsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVTY3JpcHRpbmdGdW5jdGlvbihmdW5jdGlvbk5hbWUsIGNvbW1hbmROYW1lLCBzY3JpcHQsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiID8gYXJncy5wb3AoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlcGx5RW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dGcmllbmRseUVycm9yU3RhY2spIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JTdGFjayA9IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIGF1dG8gcGlwZWxpbmUsIHVzZSByZWd1bGFyIGNvbW1hbmQgc2VuZGluZ1xuICAgICAgICBpZiAoISgwLCBhdXRvUGlwZWxpbmluZ18xLnNob3VsZFVzZUF1dG9QaXBlbGluaW5nKSh0aGlzLCBmdW5jdGlvbk5hbWUsIGNvbW1hbmROYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdC5leGVjdXRlKHRoaXMsIGFyZ3MsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGlwZWxpbmUgYW5kIG1ha2Ugc3VyZSBpdCdzIHNjaGVkdWxlZFxuICAgICAgICByZXR1cm4gKDAsIGF1dG9QaXBlbGluaW5nXzEuZXhlY3V0ZVdpdGhBdXRvUGlwZWxpbmluZykodGhpcywgZnVuY3Rpb25OYW1lLCBjb21tYW5kTmFtZSwgYXJncywgY2FsbGJhY2spO1xuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb21tYW5kZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjb21tYW5kc18xIiwicmVxdWlyZSIsImF1dG9QaXBlbGluaW5nXzEiLCJDb21tYW5kXzEiLCJTY3JpcHRfMSIsIkNvbW1hbmRlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsInNjcmlwdHNTZXQiLCJhZGRlZEJ1aWx0aW5TZXQiLCJTZXQiLCJnZXRCdWlsdGluQ29tbWFuZHMiLCJjb21tYW5kcyIsInNsaWNlIiwiY3JlYXRlQnVpbHRpbkNvbW1hbmQiLCJjb21tYW5kTmFtZSIsInN0cmluZyIsImdlbmVyYXRlRnVuY3Rpb24iLCJidWZmZXIiLCJhZGRCdWlsdGluQ29tbWFuZCIsImFkZCIsImRlZmluZUNvbW1hbmQiLCJuYW1lIiwiZGVmaW5pdGlvbiIsInNjcmlwdCIsImRlZmF1bHQiLCJsdWEiLCJudW1iZXJPZktleXMiLCJrZXlQcmVmaXgiLCJyZWFkT25seSIsImdlbmVyYXRlU2NyaXB0aW5nRnVuY3Rpb24iLCJzZW5kQ29tbWFuZCIsImNvbW1hbmQiLCJzdHJlYW0iLCJub2RlIiwiRXJyb3IiLCJsaXN0IiwiZmlsdGVyIiwicHVzaCIsImZvckVhY2giLCJwcm90b3R5cGUiLCJjYWxsIiwiY2FsbEJ1ZmZlciIsInNlbmRfY29tbWFuZCIsImZ1bmN0aW9uTmFtZSIsIl9jb21tYW5kTmFtZSIsIl9lbmNvZGluZyIsImFyZ3MiLCJzaGlmdCIsImNhbGxiYWNrIiwibGVuZ3RoIiwicG9wIiwidW5kZWZpbmVkIiwiZXJyb3JTdGFjayIsInNob3dGcmllbmRseUVycm9yU3RhY2siLCJyZXBseUVuY29kaW5nIiwic2hvdWxkVXNlQXV0b1BpcGVsaW5pbmciLCJleGVjdXRlV2l0aEF1dG9QaXBlbGluaW5nIiwiZW5jb2RpbmciLCJleGVjdXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/Commander.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/applyMixin.js":
/*!********************************************************!*\
  !*** ./node_modules/ioredis/built/utils/applyMixin.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction applyMixin(derivedConstructor, mixinConstructor) {\n    Object.getOwnPropertyNames(mixinConstructor.prototype).forEach((name)=>{\n        Object.defineProperty(derivedConstructor.prototype, name, Object.getOwnPropertyDescriptor(mixinConstructor.prototype, name));\n    });\n}\nexports[\"default\"] = applyMixin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9hcHBseU1peGluLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELFNBQVNDLFdBQVdDLGtCQUFrQixFQUFFQyxnQkFBZ0I7SUFDcEROLE9BQU9PLG1CQUFtQixDQUFDRCxpQkFBaUJFLFNBQVMsRUFBRUMsT0FBTyxDQUFDLENBQUNDO1FBQzVEVixPQUFPQyxjQUFjLENBQUNJLG1CQUFtQkcsU0FBUyxFQUFFRSxNQUFNVixPQUFPVyx3QkFBd0IsQ0FBQ0wsaUJBQWlCRSxTQUFTLEVBQUVFO0lBQzFIO0FBQ0o7QUFDQVIsa0JBQWUsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0LWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L3V0aWxzL2FwcGx5TWl4aW4uanM/ODdjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGFwcGx5TWl4aW4oZGVyaXZlZENvbnN0cnVjdG9yLCBtaXhpbkNvbnN0cnVjdG9yKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobWl4aW5Db25zdHJ1Y3Rvci5wcm90b3R5cGUpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWRDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIG5hbWUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobWl4aW5Db25zdHJ1Y3Rvci5wcm90b3R5cGUsIG5hbWUpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGFwcGx5TWl4aW47XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhcHBseU1peGluIiwiZGVyaXZlZENvbnN0cnVjdG9yIiwibWl4aW5Db25zdHJ1Y3RvciIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwibmFtZSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/applyMixin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/argumentParsers.js":
/*!*************************************************************!*\
  !*** ./node_modules/ioredis/built/utils/argumentParsers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseBlockOption = exports.parseSecondsArgument = void 0;\n/**\n * Parses a command parameter to a number.\n * @param arg - The command parameter to parse (number, string, or Buffer)\n * @returns The parsed number, or undefined if parsing fails or arg is undefined\n */ const parseNumberArgument = (arg)=>{\n    if (typeof arg === \"number\") {\n        return arg;\n    }\n    if (Buffer.isBuffer(arg)) {\n        return parseNumberArgument(arg.toString());\n    }\n    if (typeof arg === \"string\") {\n        const value = Number(arg);\n        return Number.isFinite(value) ? value : undefined;\n    }\n    return undefined;\n};\n/**\n * Parses a command parameter to a string.\n * @param arg - The command parameter to parse (string or Buffer)\n * @returns The parsed string, or undefined if arg is not a string/Buffer or is undefined\n */ const parseStringArgument = (arg)=>{\n    if (typeof arg === \"string\") {\n        return arg;\n    }\n    if (Buffer.isBuffer(arg)) {\n        return arg.toString();\n    }\n    return undefined;\n};\n/**\n * Parses a command parameter as seconds and converts to milliseconds.\n * @param arg - The command parameter representing seconds\n * @returns The value in milliseconds, 0 if value is <= 0, or undefined if parsing fails\n */ const parseSecondsArgument = (arg)=>{\n    const value = parseNumberArgument(arg);\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value <= 0) {\n        return 0;\n    }\n    return value * 1000;\n};\nexports.parseSecondsArgument = parseSecondsArgument;\n/**\n * Parses the BLOCK option from Redis command arguments (e.g., XREAD, XREADGROUP).\n * @param args - Array of command parameters to search for the BLOCK option\n * @returns The block duration in milliseconds, 0 if duration is <= 0,\n *          null if BLOCK option is not found, or undefined if BLOCK is found but duration is invalid\n */ const parseBlockOption = (args)=>{\n    for(let i = 0; i < args.length; i++){\n        const token = parseStringArgument(args[i]);\n        if (token && token.toLowerCase() === \"block\") {\n            const duration = parseNumberArgument(args[i + 1]);\n            if (duration === undefined) {\n                return undefined;\n            }\n            if (duration <= 0) {\n                return 0;\n            }\n            return duration;\n        }\n    }\n    return null;\n};\nexports.parseBlockOption = parseBlockOption;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9hcmd1bWVudFBhcnNlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHQSw0QkFBNEIsR0FBRyxLQUFLO0FBQy9EOzs7O0NBSUMsR0FDRCxNQUFNSSxzQkFBc0IsQ0FBQ0M7SUFDekIsSUFBSSxPQUFPQSxRQUFRLFVBQVU7UUFDekIsT0FBT0E7SUFDWDtJQUNBLElBQUlDLE9BQU9DLFFBQVEsQ0FBQ0YsTUFBTTtRQUN0QixPQUFPRCxvQkFBb0JDLElBQUlHLFFBQVE7SUFDM0M7SUFDQSxJQUFJLE9BQU9ILFFBQVEsVUFBVTtRQUN6QixNQUFNSixRQUFRUSxPQUFPSjtRQUNyQixPQUFPSSxPQUFPQyxRQUFRLENBQUNULFNBQVNBLFFBQVFVO0lBQzVDO0lBQ0EsT0FBT0E7QUFDWDtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNQyxzQkFBc0IsQ0FBQ1A7SUFDekIsSUFBSSxPQUFPQSxRQUFRLFVBQVU7UUFDekIsT0FBT0E7SUFDWDtJQUNBLElBQUlDLE9BQU9DLFFBQVEsQ0FBQ0YsTUFBTTtRQUN0QixPQUFPQSxJQUFJRyxRQUFRO0lBQ3ZCO0lBQ0EsT0FBT0c7QUFDWDtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNUix1QkFBdUIsQ0FBQ0U7SUFDMUIsTUFBTUosUUFBUUcsb0JBQW9CQztJQUNsQyxJQUFJSixVQUFVVSxXQUFXO1FBQ3JCLE9BQU9BO0lBQ1g7SUFDQSxJQUFJVixTQUFTLEdBQUc7UUFDWixPQUFPO0lBQ1g7SUFDQSxPQUFPQSxRQUFRO0FBQ25CO0FBQ0FELDRCQUE0QixHQUFHRztBQUMvQjs7Ozs7Q0FLQyxHQUNELE1BQU1ELG1CQUFtQixDQUFDVztJQUN0QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsS0FBS0UsTUFBTSxFQUFFRCxJQUFLO1FBQ2xDLE1BQU1FLFFBQVFKLG9CQUFvQkMsSUFBSSxDQUFDQyxFQUFFO1FBQ3pDLElBQUlFLFNBQVNBLE1BQU1DLFdBQVcsT0FBTyxTQUFTO1lBQzFDLE1BQU1DLFdBQVdkLG9CQUFvQlMsSUFBSSxDQUFDQyxJQUFJLEVBQUU7WUFDaEQsSUFBSUksYUFBYVAsV0FBVztnQkFDeEIsT0FBT0E7WUFDWDtZQUNBLElBQUlPLFlBQVksR0FBRztnQkFDZixPQUFPO1lBQ1g7WUFDQSxPQUFPQTtRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQWxCLHdCQUF3QixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvYXJndW1lbnRQYXJzZXJzLmpzP2FhYzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlQmxvY2tPcHRpb24gPSBleHBvcnRzLnBhcnNlU2Vjb25kc0FyZ3VtZW50ID0gdm9pZCAwO1xuLyoqXG4gKiBQYXJzZXMgYSBjb21tYW5kIHBhcmFtZXRlciB0byBhIG51bWJlci5cbiAqIEBwYXJhbSBhcmcgLSBUaGUgY29tbWFuZCBwYXJhbWV0ZXIgdG8gcGFyc2UgKG51bWJlciwgc3RyaW5nLCBvciBCdWZmZXIpXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIG51bWJlciwgb3IgdW5kZWZpbmVkIGlmIHBhcnNpbmcgZmFpbHMgb3IgYXJnIGlzIHVuZGVmaW5lZFxuICovXG5jb25zdCBwYXJzZU51bWJlckFyZ3VtZW50ID0gKGFyZykgPT4ge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYXJnKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VOdW1iZXJBcmd1bWVudChhcmcudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gTnVtYmVyKGFyZyk7XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuLyoqXG4gKiBQYXJzZXMgYSBjb21tYW5kIHBhcmFtZXRlciB0byBhIHN0cmluZy5cbiAqIEBwYXJhbSBhcmcgLSBUaGUgY29tbWFuZCBwYXJhbWV0ZXIgdG8gcGFyc2UgKHN0cmluZyBvciBCdWZmZXIpXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHN0cmluZywgb3IgdW5kZWZpbmVkIGlmIGFyZyBpcyBub3QgYSBzdHJpbmcvQnVmZmVyIG9yIGlzIHVuZGVmaW5lZFxuICovXG5jb25zdCBwYXJzZVN0cmluZ0FyZ3VtZW50ID0gKGFyZykgPT4ge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYXJnKSkge1xuICAgICAgICByZXR1cm4gYXJnLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuLyoqXG4gKiBQYXJzZXMgYSBjb21tYW5kIHBhcmFtZXRlciBhcyBzZWNvbmRzIGFuZCBjb252ZXJ0cyB0byBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0gYXJnIC0gVGhlIGNvbW1hbmQgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBzZWNvbmRzXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgaW4gbWlsbGlzZWNvbmRzLCAwIGlmIHZhbHVlIGlzIDw9IDAsIG9yIHVuZGVmaW5lZCBpZiBwYXJzaW5nIGZhaWxzXG4gKi9cbmNvbnN0IHBhcnNlU2Vjb25kc0FyZ3VtZW50ID0gKGFyZykgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VOdW1iZXJBcmd1bWVudChhcmcpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgKiAxMDAwO1xufTtcbmV4cG9ydHMucGFyc2VTZWNvbmRzQXJndW1lbnQgPSBwYXJzZVNlY29uZHNBcmd1bWVudDtcbi8qKlxuICogUGFyc2VzIHRoZSBCTE9DSyBvcHRpb24gZnJvbSBSZWRpcyBjb21tYW5kIGFyZ3VtZW50cyAoZS5nLiwgWFJFQUQsIFhSRUFER1JPVVApLlxuICogQHBhcmFtIGFyZ3MgLSBBcnJheSBvZiBjb21tYW5kIHBhcmFtZXRlcnMgdG8gc2VhcmNoIGZvciB0aGUgQkxPQ0sgb3B0aW9uXG4gKiBAcmV0dXJucyBUaGUgYmxvY2sgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLCAwIGlmIGR1cmF0aW9uIGlzIDw9IDAsXG4gKiAgICAgICAgICBudWxsIGlmIEJMT0NLIG9wdGlvbiBpcyBub3QgZm91bmQsIG9yIHVuZGVmaW5lZCBpZiBCTE9DSyBpcyBmb3VuZCBidXQgZHVyYXRpb24gaXMgaW52YWxpZFxuICovXG5jb25zdCBwYXJzZUJsb2NrT3B0aW9uID0gKGFyZ3MpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBwYXJzZVN0cmluZ0FyZ3VtZW50KGFyZ3NbaV0pO1xuICAgICAgICBpZiAodG9rZW4gJiYgdG9rZW4udG9Mb3dlckNhc2UoKSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnNlTnVtYmVyQXJndW1lbnQoYXJnc1tpICsgMV0pO1xuICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnRzLnBhcnNlQmxvY2tPcHRpb24gPSBwYXJzZUJsb2NrT3B0aW9uO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicGFyc2VCbG9ja09wdGlvbiIsInBhcnNlU2Vjb25kc0FyZ3VtZW50IiwicGFyc2VOdW1iZXJBcmd1bWVudCIsImFyZyIsIkJ1ZmZlciIsImlzQnVmZmVyIiwidG9TdHJpbmciLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInVuZGVmaW5lZCIsInBhcnNlU3RyaW5nQXJndW1lbnQiLCJhcmdzIiwiaSIsImxlbmd0aCIsInRva2VuIiwidG9Mb3dlckNhc2UiLCJkdXJhdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/argumentParsers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/debug.js":
/*!***************************************************!*\
  !*** ./node_modules/ioredis/built/utils/debug.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.genRedactedString = exports.getStringValue = exports.MAX_ARGUMENT_LENGTH = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\nconst MAX_ARGUMENT_LENGTH = 200;\nexports.MAX_ARGUMENT_LENGTH = MAX_ARGUMENT_LENGTH;\nconst NAMESPACE_PREFIX = \"ioredis\";\n/**\n * helper function that tried to get a string value for\n * arbitrary \"debug\" arg\n */ function getStringValue(v) {\n    if (v === null) {\n        return;\n    }\n    switch(typeof v){\n        case \"boolean\":\n            return;\n        case \"number\":\n            return;\n        case \"object\":\n            if (Buffer.isBuffer(v)) {\n                return v.toString(\"hex\");\n            }\n            if (Array.isArray(v)) {\n                return v.join(\",\");\n            }\n            try {\n                return JSON.stringify(v);\n            } catch (e) {\n                return;\n            }\n        case \"string\":\n            return v;\n    }\n}\nexports.getStringValue = getStringValue;\n/**\n * helper function that redacts a string representation of a \"debug\" arg\n */ function genRedactedString(str, maxLen) {\n    const { length } = str;\n    return length <= maxLen ? str : str.slice(0, maxLen) + ' ... <REDACTED full-length=\"' + length + '\">';\n}\nexports.genRedactedString = genRedactedString;\n/**\n * a wrapper for the `debug` module, used to generate\n * \"debug functions\" that trim the values in their output\n */ function genDebugFunction(namespace) {\n    const fn = (0, debug_1.default)(`${NAMESPACE_PREFIX}:${namespace}`);\n    function wrappedDebug(...args) {\n        if (!fn.enabled) {\n            return; // no-op\n        }\n        // we skip the first arg because that is the message\n        for(let i = 1; i < args.length; i++){\n            const str = getStringValue(args[i]);\n            if (typeof str === \"string\" && str.length > MAX_ARGUMENT_LENGTH) {\n                args[i] = genRedactedString(str, MAX_ARGUMENT_LENGTH);\n            }\n        }\n        return fn.apply(null, args);\n    }\n    Object.defineProperties(wrappedDebug, {\n        namespace: {\n            get () {\n                return fn.namespace;\n            }\n        },\n        enabled: {\n            get () {\n                return fn.enabled;\n            }\n        },\n        destroy: {\n            get () {\n                return fn.destroy;\n            }\n        },\n        log: {\n            get () {\n                return fn.log;\n            },\n            set (l) {\n                fn.log = l;\n            }\n        }\n    });\n    return wrappedDebug;\n}\nexports[\"default\"] = genDebugFunction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUdBLHNCQUFzQixHQUFHQSwyQkFBMkIsR0FBRyxLQUFLO0FBQ3hGLE1BQU1LLFVBQVVDLG1CQUFPQSxDQUFDLHNEQUFPO0FBQy9CLE1BQU1GLHNCQUFzQjtBQUM1QkosMkJBQTJCLEdBQUdJO0FBQzlCLE1BQU1HLG1CQUFtQjtBQUN6Qjs7O0NBR0MsR0FDRCxTQUFTSixlQUFlSyxDQUFDO0lBQ3JCLElBQUlBLE1BQU0sTUFBTTtRQUNaO0lBQ0o7SUFDQSxPQUFRLE9BQU9BO1FBQ1gsS0FBSztZQUNEO1FBQ0osS0FBSztZQUNEO1FBQ0osS0FBSztZQUNELElBQUlDLE9BQU9DLFFBQVEsQ0FBQ0YsSUFBSTtnQkFDcEIsT0FBT0EsRUFBRUcsUUFBUSxDQUFDO1lBQ3RCO1lBQ0EsSUFBSUMsTUFBTUMsT0FBTyxDQUFDTCxJQUFJO2dCQUNsQixPQUFPQSxFQUFFTSxJQUFJLENBQUM7WUFDbEI7WUFDQSxJQUFJO2dCQUNBLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ1I7WUFDMUIsRUFDQSxPQUFPUyxHQUFHO2dCQUNOO1lBQ0o7UUFDSixLQUFLO1lBQ0QsT0FBT1Q7SUFDZjtBQUNKO0FBQ0FSLHNCQUFzQixHQUFHRztBQUN6Qjs7Q0FFQyxHQUNELFNBQVNELGtCQUFrQmdCLEdBQUcsRUFBRUMsTUFBTTtJQUNsQyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHRjtJQUNuQixPQUFPRSxVQUFVRCxTQUNYRCxNQUNBQSxJQUFJRyxLQUFLLENBQUMsR0FBR0YsVUFBVSxpQ0FBaUNDLFNBQVM7QUFDM0U7QUFDQXBCLHlCQUF5QixHQUFHRTtBQUM1Qjs7O0NBR0MsR0FDRCxTQUFTb0IsaUJBQWlCQyxTQUFTO0lBQy9CLE1BQU1DLEtBQUssQ0FBQyxHQUFHbkIsUUFBUW9CLE9BQU8sRUFBRSxDQUFDLEVBQUVsQixpQkFBaUIsQ0FBQyxFQUFFZ0IsVUFBVSxDQUFDO0lBQ2xFLFNBQVNHLGFBQWEsR0FBR0MsSUFBSTtRQUN6QixJQUFJLENBQUNILEdBQUdJLE9BQU8sRUFBRTtZQUNiLFFBQVEsUUFBUTtRQUNwQjtRQUNBLG9EQUFvRDtRQUNwRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsS0FBS1AsTUFBTSxFQUFFUyxJQUFLO1lBQ2xDLE1BQU1YLE1BQU1mLGVBQWV3QixJQUFJLENBQUNFLEVBQUU7WUFDbEMsSUFBSSxPQUFPWCxRQUFRLFlBQVlBLElBQUlFLE1BQU0sR0FBR2hCLHFCQUFxQjtnQkFDN0R1QixJQUFJLENBQUNFLEVBQUUsR0FBRzNCLGtCQUFrQmdCLEtBQUtkO1lBQ3JDO1FBQ0o7UUFDQSxPQUFPb0IsR0FBR00sS0FBSyxDQUFDLE1BQU1IO0lBQzFCO0lBQ0E3QixPQUFPaUMsZ0JBQWdCLENBQUNMLGNBQWM7UUFDbENILFdBQVc7WUFDUFM7Z0JBQ0ksT0FBT1IsR0FBR0QsU0FBUztZQUN2QjtRQUNKO1FBQ0FLLFNBQVM7WUFDTEk7Z0JBQ0ksT0FBT1IsR0FBR0ksT0FBTztZQUNyQjtRQUNKO1FBQ0FLLFNBQVM7WUFDTEQ7Z0JBQ0ksT0FBT1IsR0FBR1MsT0FBTztZQUNyQjtRQUNKO1FBQ0FDLEtBQUs7WUFDREY7Z0JBQ0ksT0FBT1IsR0FBR1UsR0FBRztZQUNqQjtZQUNBQyxLQUFJQyxDQUFDO2dCQUNEWixHQUFHVSxHQUFHLEdBQUdFO1lBQ2I7UUFDSjtJQUNKO0lBQ0EsT0FBT1Y7QUFDWDtBQUNBMUIsa0JBQWUsR0FBR3NCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvZHVjdC1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9kZWJ1Zy5qcz8wNDc1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZW5SZWRhY3RlZFN0cmluZyA9IGV4cG9ydHMuZ2V0U3RyaW5nVmFsdWUgPSBleHBvcnRzLk1BWF9BUkdVTUVOVF9MRU5HVEggPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgTUFYX0FSR1VNRU5UX0xFTkdUSCA9IDIwMDtcbmV4cG9ydHMuTUFYX0FSR1VNRU5UX0xFTkdUSCA9IE1BWF9BUkdVTUVOVF9MRU5HVEg7XG5jb25zdCBOQU1FU1BBQ0VfUFJFRklYID0gXCJpb3JlZGlzXCI7XG4vKipcbiAqIGhlbHBlciBmdW5jdGlvbiB0aGF0IHRyaWVkIHRvIGdldCBhIHN0cmluZyB2YWx1ZSBmb3JcbiAqIGFyYml0cmFyeSBcImRlYnVnXCIgYXJnXG4gKi9cbmZ1bmN0aW9uIGdldFN0cmluZ1ZhbHVlKHYpIHtcbiAgICBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2LmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTdHJpbmdWYWx1ZSA9IGdldFN0cmluZ1ZhbHVlO1xuLyoqXG4gKiBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZWRhY3RzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgXCJkZWJ1Z1wiIGFyZ1xuICovXG5mdW5jdGlvbiBnZW5SZWRhY3RlZFN0cmluZyhzdHIsIG1heExlbikge1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBzdHI7XG4gICAgcmV0dXJuIGxlbmd0aCA8PSBtYXhMZW5cbiAgICAgICAgPyBzdHJcbiAgICAgICAgOiBzdHIuc2xpY2UoMCwgbWF4TGVuKSArICcgLi4uIDxSRURBQ1RFRCBmdWxsLWxlbmd0aD1cIicgKyBsZW5ndGggKyAnXCI+Jztcbn1cbmV4cG9ydHMuZ2VuUmVkYWN0ZWRTdHJpbmcgPSBnZW5SZWRhY3RlZFN0cmluZztcbi8qKlxuICogYSB3cmFwcGVyIGZvciB0aGUgYGRlYnVnYCBtb2R1bGUsIHVzZWQgdG8gZ2VuZXJhdGVcbiAqIFwiZGVidWcgZnVuY3Rpb25zXCIgdGhhdCB0cmltIHRoZSB2YWx1ZXMgaW4gdGhlaXIgb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdlbkRlYnVnRnVuY3Rpb24obmFtZXNwYWNlKSB7XG4gICAgY29uc3QgZm4gPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtOQU1FU1BBQ0VfUFJFRklYfToke25hbWVzcGFjZX1gKTtcbiAgICBmdW5jdGlvbiB3cmFwcGVkRGVidWcoLi4uYXJncykge1xuICAgICAgICBpZiAoIWZuLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gbm8tb3BcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBza2lwIHRoZSBmaXJzdCBhcmcgYmVjYXVzZSB0aGF0IGlzIHRoZSBtZXNzYWdlXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3RyID0gZ2V0U3RyaW5nVmFsdWUoYXJnc1tpXSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIiAmJiBzdHIubGVuZ3RoID4gTUFYX0FSR1VNRU5UX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBnZW5SZWRhY3RlZFN0cmluZyhzdHIsIE1BWF9BUkdVTUVOVF9MRU5HVEgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcHBlZERlYnVnLCB7XG4gICAgICAgIG5hbWVzcGFjZToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5uYW1lc3BhY2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmVuYWJsZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmRlc3Ryb3k7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBsb2c6IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubG9nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldChsKSB7XG4gICAgICAgICAgICAgICAgZm4ubG9nID0gbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHdyYXBwZWREZWJ1Zztcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdlbkRlYnVnRnVuY3Rpb247XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZW5SZWRhY3RlZFN0cmluZyIsImdldFN0cmluZ1ZhbHVlIiwiTUFYX0FSR1VNRU5UX0xFTkdUSCIsImRlYnVnXzEiLCJyZXF1aXJlIiwiTkFNRVNQQUNFX1BSRUZJWCIsInYiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInRvU3RyaW5nIiwiQXJyYXkiLCJpc0FycmF5Iiwiam9pbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwic3RyIiwibWF4TGVuIiwibGVuZ3RoIiwic2xpY2UiLCJnZW5EZWJ1Z0Z1bmN0aW9uIiwibmFtZXNwYWNlIiwiZm4iLCJkZWZhdWx0Iiwid3JhcHBlZERlYnVnIiwiYXJncyIsImVuYWJsZWQiLCJpIiwiYXBwbHkiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0IiwiZGVzdHJveSIsImxvZyIsInNldCIsImwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/debug.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ioredis/built/utils/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.noop = exports.defaults = exports.Debug = exports.getPackageMeta = exports.zipMap = exports.CONNECTION_CLOSED_ERROR_MSG = exports.shuffle = exports.sample = exports.resolveTLSProfile = exports.parseURL = exports.optimizeErrorStack = exports.toArg = exports.convertMapToArray = exports.convertObjectToArray = exports.timeout = exports.packObject = exports.isInt = exports.wrapMultiResult = exports.convertBufferToString = void 0;\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst lodash_1 = __webpack_require__(/*! ./lodash */ \"(rsc)/./node_modules/ioredis/built/utils/lodash.js\");\nObject.defineProperty(exports, \"defaults\", ({\n    enumerable: true,\n    get: function() {\n        return lodash_1.defaults;\n    }\n}));\nObject.defineProperty(exports, \"noop\", ({\n    enumerable: true,\n    get: function() {\n        return lodash_1.noop;\n    }\n}));\nconst debug_1 = __webpack_require__(/*! ./debug */ \"(rsc)/./node_modules/ioredis/built/utils/debug.js\");\nexports.Debug = debug_1.default;\nconst TLSProfiles_1 = __webpack_require__(/*! ../constants/TLSProfiles */ \"(rsc)/./node_modules/ioredis/built/constants/TLSProfiles.js\");\n/**\n * Convert a buffer to string, supports buffer array\n *\n * @example\n * ```js\n * const input = [Buffer.from('foo'), [Buffer.from('bar')]]\n * const res = convertBufferToString(input, 'utf8')\n * expect(res).to.eql(['foo', ['bar']])\n * ```\n */ function convertBufferToString(value, encoding) {\n    if (value instanceof Buffer) {\n        return value.toString(encoding);\n    }\n    if (Array.isArray(value)) {\n        const length = value.length;\n        const res = Array(length);\n        for(let i = 0; i < length; ++i){\n            res[i] = value[i] instanceof Buffer && encoding === \"utf8\" ? value[i].toString() : convertBufferToString(value[i], encoding);\n        }\n        return res;\n    }\n    return value;\n}\nexports.convertBufferToString = convertBufferToString;\n/**\n * Convert a list of results to node-style\n *\n * @example\n * ```js\n * const input = ['a', 'b', new Error('c'), 'd']\n * const output = exports.wrapMultiResult(input)\n * expect(output).to.eql([[null, 'a'], [null, 'b'], [new Error('c')], [null, 'd'])\n * ```\n */ function wrapMultiResult(arr) {\n    // When using WATCH/EXEC transactions, the EXEC will return\n    // a null instead of an array\n    if (!arr) {\n        return null;\n    }\n    const result = [];\n    const length = arr.length;\n    for(let i = 0; i < length; ++i){\n        const item = arr[i];\n        if (item instanceof Error) {\n            result.push([\n                item\n            ]);\n        } else {\n            result.push([\n                null,\n                item\n            ]);\n        }\n    }\n    return result;\n}\nexports.wrapMultiResult = wrapMultiResult;\n/**\n * Detect if the argument is a int\n * @example\n * ```js\n * > isInt('123')\n * true\n * > isInt('123.3')\n * false\n * > isInt('1x')\n * false\n * > isInt(123)\n * true\n * > isInt(true)\n * false\n * ```\n */ function isInt(value) {\n    const x = parseFloat(value);\n    return !isNaN(value) && (x | 0) === x;\n}\nexports.isInt = isInt;\n/**\n * Pack an array to an Object\n *\n * @example\n * ```js\n * > packObject(['a', 'b', 'c', 'd'])\n * { a: 'b', c: 'd' }\n * ```\n */ function packObject(array) {\n    const result = {};\n    const length = array.length;\n    for(let i = 1; i < length; i += 2){\n        result[array[i - 1]] = array[i];\n    }\n    return result;\n}\nexports.packObject = packObject;\n/**\n * Return a callback with timeout\n */ function timeout(callback, timeout) {\n    let timer = null;\n    const run = function() {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n            callback.apply(this, arguments);\n        }\n    };\n    timer = setTimeout(run, timeout, new Error(\"timeout\"));\n    return run;\n}\nexports.timeout = timeout;\n/**\n * Convert an object to an array\n * @example\n * ```js\n * > convertObjectToArray({ a: '1' })\n * ['a', '1']\n * ```\n */ function convertObjectToArray(obj) {\n    const result = [];\n    const keys = Object.keys(obj); // Object.entries requires node 7+\n    for(let i = 0, l = keys.length; i < l; i++){\n        result.push(keys[i], obj[keys[i]]);\n    }\n    return result;\n}\nexports.convertObjectToArray = convertObjectToArray;\n/**\n * Convert a map to an array\n * @example\n * ```js\n * > convertMapToArray(new Map([[1, '2']]))\n * [1, '2']\n * ```\n */ function convertMapToArray(map) {\n    const result = [];\n    let pos = 0;\n    map.forEach(function(value, key) {\n        result[pos] = key;\n        result[pos + 1] = value;\n        pos += 2;\n    });\n    return result;\n}\nexports.convertMapToArray = convertMapToArray;\n/**\n * Convert a non-string arg to a string\n */ function toArg(arg) {\n    if (arg === null || typeof arg === \"undefined\") {\n        return \"\";\n    }\n    return String(arg);\n}\nexports.toArg = toArg;\n/**\n * Optimize error stack\n *\n * @param error actually error\n * @param friendlyStack the stack that more meaningful\n * @param filterPath only show stacks with the specified path\n */ function optimizeErrorStack(error, friendlyStack, filterPath) {\n    const stacks = friendlyStack.split(\"\\n\");\n    let lines = \"\";\n    let i;\n    for(i = 1; i < stacks.length; ++i){\n        if (stacks[i].indexOf(filterPath) === -1) {\n            break;\n        }\n    }\n    for(let j = i; j < stacks.length; ++j){\n        lines += \"\\n\" + stacks[j];\n    }\n    if (error.stack) {\n        const pos = error.stack.indexOf(\"\\n\");\n        error.stack = error.stack.slice(0, pos) + lines;\n    }\n    return error;\n}\nexports.optimizeErrorStack = optimizeErrorStack;\n/**\n * Parse the redis protocol url\n */ function parseURL(url) {\n    if (isInt(url)) {\n        return {\n            port: url\n        };\n    }\n    let parsed = (0, url_1.parse)(url, true, true);\n    if (!parsed.slashes && url[0] !== \"/\") {\n        url = \"//\" + url;\n        parsed = (0, url_1.parse)(url, true, true);\n    }\n    const options = parsed.query || {};\n    const result = {};\n    if (parsed.auth) {\n        const index = parsed.auth.indexOf(\":\");\n        result.username = index === -1 ? parsed.auth : parsed.auth.slice(0, index);\n        result.password = index === -1 ? \"\" : parsed.auth.slice(index + 1);\n    }\n    if (parsed.pathname) {\n        if (parsed.protocol === \"redis:\" || parsed.protocol === \"rediss:\") {\n            if (parsed.pathname.length > 1) {\n                result.db = parsed.pathname.slice(1);\n            }\n        } else {\n            result.path = parsed.pathname;\n        }\n    }\n    if (parsed.host) {\n        result.host = parsed.hostname;\n    }\n    if (parsed.port) {\n        result.port = parsed.port;\n    }\n    if (typeof options.family === \"string\") {\n        const intFamily = Number.parseInt(options.family, 10);\n        if (!Number.isNaN(intFamily)) {\n            result.family = intFamily;\n        }\n    }\n    (0, lodash_1.defaults)(result, options);\n    return result;\n}\nexports.parseURL = parseURL;\n/**\n * Resolve TLS profile shortcut in connection options\n */ function resolveTLSProfile(options) {\n    let tls = options === null || options === void 0 ? void 0 : options.tls;\n    if (typeof tls === \"string\") tls = {\n        profile: tls\n    };\n    const profile = TLSProfiles_1.default[tls === null || tls === void 0 ? void 0 : tls.profile];\n    if (profile) {\n        tls = Object.assign({}, profile, tls);\n        delete tls.profile;\n        options = Object.assign({}, options, {\n            tls\n        });\n    }\n    return options;\n}\nexports.resolveTLSProfile = resolveTLSProfile;\n/**\n * Get a random element from `array`\n */ function sample(array, from = 0) {\n    const length = array.length;\n    if (from >= length) {\n        return null;\n    }\n    return array[from + Math.floor(Math.random() * (length - from))];\n}\nexports.sample = sample;\n/**\n * Shuffle the array using the Fisher-Yates Shuffle.\n * This method will mutate the original array.\n */ function shuffle(array) {\n    let counter = array.length;\n    // While there are elements in the array\n    while(counter > 0){\n        // Pick a random index\n        const index = Math.floor(Math.random() * counter);\n        // Decrease counter by 1\n        counter--;\n        // And swap the last element with it\n        [array[counter], array[index]] = [\n            array[index],\n            array[counter]\n        ];\n    }\n    return array;\n}\nexports.shuffle = shuffle;\n/**\n * Error message for connection being disconnected\n */ exports.CONNECTION_CLOSED_ERROR_MSG = \"Connection is closed.\";\nfunction zipMap(keys, values) {\n    const map = new Map();\n    keys.forEach((key, index)=>{\n        map.set(key, values[index]);\n    });\n    return map;\n}\nexports.zipMap = zipMap;\n/**\n * Memoized package metadata to avoid repeated file system reads.\n *\n * @internal\n */ let cachedPackageMeta = null;\n/**\n * Retrieves cached package metadata from package.json.\n *\n * @internal\n * @returns {Promise<{version: string} | null>} Package metadata or null if unavailable\n */ async function getPackageMeta() {\n    if (cachedPackageMeta) {\n        return cachedPackageMeta;\n    }\n    try {\n        const filePath = (0, path_1.resolve)(__dirname, \"..\", \"..\", \"package.json\");\n        const data = await fs_1.promises.readFile(filePath, \"utf8\");\n        const parsed = JSON.parse(data);\n        cachedPackageMeta = {\n            version: parsed.version\n        };\n        return cachedPackageMeta;\n    } catch (err) {\n        cachedPackageMeta = {\n            version: \"error-fetching-version\"\n        };\n        return cachedPackageMeta;\n    }\n}\nexports.getPackageMeta = getPackageMeta;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsWUFBWSxHQUFHQSxnQkFBZ0IsR0FBR0EsYUFBYSxHQUFHQSxzQkFBc0IsR0FBR0EsY0FBYyxHQUFHQSxtQ0FBbUMsR0FBR0EsZUFBZSxHQUFHQSxjQUFjLEdBQUdBLHlCQUF5QixHQUFHQSxnQkFBZ0IsR0FBR0EsMEJBQTBCLEdBQUdBLGFBQWEsR0FBR0EseUJBQXlCLEdBQUdBLDRCQUE0QixHQUFHQSxlQUFlLEdBQUdBLGtCQUFrQixHQUFHQSxhQUFhLEdBQUdBLHVCQUF1QixHQUFHQSw2QkFBNkIsR0FBRyxLQUFLO0FBQ2xiLE1BQU1xQixPQUFPQyxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3pCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLGtCQUFNO0FBQzdCLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1HLFdBQVdILG1CQUFPQSxDQUFDLG9FQUFVO0FBQ25DeEIsNENBQTJDO0lBQUU0QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixTQUFTdEIsUUFBUTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2hITCx3Q0FBdUM7SUFBRTRCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLFNBQVN2QixJQUFJO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDeEcsTUFBTTBCLFVBQVVOLG1CQUFPQSxDQUFDLGtFQUFTO0FBQ2pDdEIsYUFBYSxHQUFHNEIsUUFBUUMsT0FBTztBQUMvQixNQUFNQyxnQkFBZ0JSLG1CQUFPQSxDQUFDLDZGQUEwQjtBQUN4RDs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTRixzQkFBc0JuQixLQUFLLEVBQUU4QixRQUFRO0lBQzFDLElBQUk5QixpQkFBaUIrQixRQUFRO1FBQ3pCLE9BQU8vQixNQUFNZ0MsUUFBUSxDQUFDRjtJQUMx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QU9SO0lBQ1gsRUFDQSxPQUFPUyxLQUFLO1FBQ1JULG9CQUFvQjtZQUNoQlEsU0FBUztRQUNiO1FBQ0EsT0FBT1I7SUFDWDtBQUNKO0FBQ0ExRyxzQkFBc0IsR0FBR0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0LWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L3V0aWxzL2luZGV4LmpzPzk1MmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vb3AgPSBleHBvcnRzLmRlZmF1bHRzID0gZXhwb3J0cy5EZWJ1ZyA9IGV4cG9ydHMuZ2V0UGFja2FnZU1ldGEgPSBleHBvcnRzLnppcE1hcCA9IGV4cG9ydHMuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHID0gZXhwb3J0cy5zaHVmZmxlID0gZXhwb3J0cy5zYW1wbGUgPSBleHBvcnRzLnJlc29sdmVUTFNQcm9maWxlID0gZXhwb3J0cy5wYXJzZVVSTCA9IGV4cG9ydHMub3B0aW1pemVFcnJvclN0YWNrID0gZXhwb3J0cy50b0FyZyA9IGV4cG9ydHMuY29udmVydE1hcFRvQXJyYXkgPSBleHBvcnRzLmNvbnZlcnRPYmplY3RUb0FycmF5ID0gZXhwb3J0cy50aW1lb3V0ID0gZXhwb3J0cy5wYWNrT2JqZWN0ID0gZXhwb3J0cy5pc0ludCA9IGV4cG9ydHMud3JhcE11bHRpUmVzdWx0ID0gZXhwb3J0cy5jb252ZXJ0QnVmZmVyVG9TdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aF8xID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBsb2Rhc2hfMSA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2Rhc2hfMS5kZWZhdWx0czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vb3BcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZGFzaF8xLm5vb3A7IH0gfSk7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcIi4vZGVidWdcIik7XG5leHBvcnRzLkRlYnVnID0gZGVidWdfMS5kZWZhdWx0O1xuY29uc3QgVExTUHJvZmlsZXNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvVExTUHJvZmlsZXNcIik7XG4vKipcbiAqIENvbnZlcnQgYSBidWZmZXIgdG8gc3RyaW5nLCBzdXBwb3J0cyBidWZmZXIgYXJyYXlcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IGlucHV0ID0gW0J1ZmZlci5mcm9tKCdmb28nKSwgW0J1ZmZlci5mcm9tKCdiYXInKV1dXG4gKiBjb25zdCByZXMgPSBjb252ZXJ0QnVmZmVyVG9TdHJpbmcoaW5wdXQsICd1dGY4JylcbiAqIGV4cGVjdChyZXMpLnRvLmVxbChbJ2ZvbycsIFsnYmFyJ11dKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRCdWZmZXJUb1N0cmluZyh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzW2ldID1cbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSBpbnN0YW5jZW9mIEJ1ZmZlciAmJiBlbmNvZGluZyA9PT0gXCJ1dGY4XCJcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVtpXS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIDogY29udmVydEJ1ZmZlclRvU3RyaW5nKHZhbHVlW2ldLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy5jb252ZXJ0QnVmZmVyVG9TdHJpbmcgPSBjb252ZXJ0QnVmZmVyVG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnQgYSBsaXN0IG9mIHJlc3VsdHMgdG8gbm9kZS1zdHlsZVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgaW5wdXQgPSBbJ2EnLCAnYicsIG5ldyBFcnJvcignYycpLCAnZCddXG4gKiBjb25zdCBvdXRwdXQgPSBleHBvcnRzLndyYXBNdWx0aVJlc3VsdChpbnB1dClcbiAqIGV4cGVjdChvdXRwdXQpLnRvLmVxbChbW251bGwsICdhJ10sIFtudWxsLCAnYiddLCBbbmV3IEVycm9yKCdjJyldLCBbbnVsbCwgJ2QnXSlcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB3cmFwTXVsdGlSZXN1bHQoYXJyKSB7XG4gICAgLy8gV2hlbiB1c2luZyBXQVRDSC9FWEVDIHRyYW5zYWN0aW9ucywgdGhlIEVYRUMgd2lsbCByZXR1cm5cbiAgICAvLyBhIG51bGwgaW5zdGVhZCBvZiBhbiBhcnJheVxuICAgIGlmICghYXJyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGFycltpXTtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW2l0ZW1dKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtudWxsLCBpdGVtXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMud3JhcE11bHRpUmVzdWx0ID0gd3JhcE11bHRpUmVzdWx0O1xuLyoqXG4gKiBEZXRlY3QgaWYgdGhlIGFyZ3VtZW50IGlzIGEgaW50XG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqID4gaXNJbnQoJzEyMycpXG4gKiB0cnVlXG4gKiA+IGlzSW50KCcxMjMuMycpXG4gKiBmYWxzZVxuICogPiBpc0ludCgnMXgnKVxuICogZmFsc2VcbiAqID4gaXNJbnQoMTIzKVxuICogdHJ1ZVxuICogPiBpc0ludCh0cnVlKVxuICogZmFsc2VcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBpc0ludCh2YWx1ZSkge1xuICAgIGNvbnN0IHggPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiAoeCB8IDApID09PSB4O1xufVxuZXhwb3J0cy5pc0ludCA9IGlzSW50O1xuLyoqXG4gKiBQYWNrIGFuIGFycmF5IHRvIGFuIE9iamVjdFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogPiBwYWNrT2JqZWN0KFsnYScsICdiJywgJ2MnLCAnZCddKVxuICogeyBhOiAnYicsIGM6ICdkJyB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gcGFja09iamVjdChhcnJheSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHJlc3VsdFthcnJheVtpIC0gMV1dID0gYXJyYXlbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhY2tPYmplY3QgPSBwYWNrT2JqZWN0O1xuLyoqXG4gKiBSZXR1cm4gYSBjYWxsYmFjayB3aXRoIHRpbWVvdXRcbiAqL1xuZnVuY3Rpb24gdGltZW91dChjYWxsYmFjaywgdGltZW91dCkge1xuICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgY29uc3QgcnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQocnVuLCB0aW1lb3V0LCBuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKTtcbiAgICByZXR1cm4gcnVuO1xufVxuZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dDtcbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgdG8gYW4gYXJyYXlcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogPiBjb252ZXJ0T2JqZWN0VG9BcnJheSh7IGE6ICcxJyB9KVxuICogWydhJywgJzEnXVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3RUb0FycmF5KG9iaikge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopOyAvLyBPYmplY3QuZW50cmllcyByZXF1aXJlcyBub2RlIDcrXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jb252ZXJ0T2JqZWN0VG9BcnJheSA9IGNvbnZlcnRPYmplY3RUb0FycmF5O1xuLyoqXG4gKiBDb252ZXJ0IGEgbWFwIHRvIGFuIGFycmF5XG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqID4gY29udmVydE1hcFRvQXJyYXkobmV3IE1hcChbWzEsICcyJ11dKSlcbiAqIFsxLCAnMiddXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY29udmVydE1hcFRvQXJyYXkobWFwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0W3Bvc10gPSBrZXk7XG4gICAgICAgIHJlc3VsdFtwb3MgKyAxXSA9IHZhbHVlO1xuICAgICAgICBwb3MgKz0gMjtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jb252ZXJ0TWFwVG9BcnJheSA9IGNvbnZlcnRNYXBUb0FycmF5O1xuLyoqXG4gKiBDb252ZXJ0IGEgbm9uLXN0cmluZyBhcmcgdG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gdG9BcmcoYXJnKSB7XG4gICAgaWYgKGFyZyA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGFyZyk7XG59XG5leHBvcnRzLnRvQXJnID0gdG9Bcmc7XG4vKipcbiAqIE9wdGltaXplIGVycm9yIHN0YWNrXG4gKlxuICogQHBhcmFtIGVycm9yIGFjdHVhbGx5IGVycm9yXG4gKiBAcGFyYW0gZnJpZW5kbHlTdGFjayB0aGUgc3RhY2sgdGhhdCBtb3JlIG1lYW5pbmdmdWxcbiAqIEBwYXJhbSBmaWx0ZXJQYXRoIG9ubHkgc2hvdyBzdGFja3Mgd2l0aCB0aGUgc3BlY2lmaWVkIHBhdGhcbiAqL1xuZnVuY3Rpb24gb3B0aW1pemVFcnJvclN0YWNrKGVycm9yLCBmcmllbmRseVN0YWNrLCBmaWx0ZXJQYXRoKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gZnJpZW5kbHlTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICBsZXQgbGluZXMgPSBcIlwiO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBzdGFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHN0YWNrc1tpXS5pbmRleE9mKGZpbHRlclBhdGgpID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPCBzdGFja3MubGVuZ3RoOyArK2opIHtcbiAgICAgICAgbGluZXMgKz0gXCJcXG5cIiArIHN0YWNrc1tqXTtcbiAgICB9XG4gICAgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGVycm9yLnN0YWNrLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgIGVycm9yLnN0YWNrID0gZXJyb3Iuc3RhY2suc2xpY2UoMCwgcG9zKSArIGxpbmVzO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnRzLm9wdGltaXplRXJyb3JTdGFjayA9IG9wdGltaXplRXJyb3JTdGFjaztcbi8qKlxuICogUGFyc2UgdGhlIHJlZGlzIHByb3RvY29sIHVybFxuICovXG5mdW5jdGlvbiBwYXJzZVVSTCh1cmwpIHtcbiAgICBpZiAoaXNJbnQodXJsKSkge1xuICAgICAgICByZXR1cm4geyBwb3J0OiB1cmwgfTtcbiAgICB9XG4gICAgbGV0IHBhcnNlZCA9ICgwLCB1cmxfMS5wYXJzZSkodXJsLCB0cnVlLCB0cnVlKTtcbiAgICBpZiAoIXBhcnNlZC5zbGFzaGVzICYmIHVybFswXSAhPT0gXCIvXCIpIHtcbiAgICAgICAgdXJsID0gXCIvL1wiICsgdXJsO1xuICAgICAgICBwYXJzZWQgPSAoMCwgdXJsXzEucGFyc2UpKHVybCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBwYXJzZWQucXVlcnkgfHwge307XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKHBhcnNlZC5hdXRoKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VkLmF1dGguaW5kZXhPZihcIjpcIik7XG4gICAgICAgIHJlc3VsdC51c2VybmFtZSA9IGluZGV4ID09PSAtMSA/IHBhcnNlZC5hdXRoIDogcGFyc2VkLmF1dGguc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICByZXN1bHQucGFzc3dvcmQgPSBpbmRleCA9PT0gLTEgPyBcIlwiIDogcGFyc2VkLmF1dGguc2xpY2UoaW5kZXggKyAxKTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZC5wYXRobmFtZSkge1xuICAgICAgICBpZiAocGFyc2VkLnByb3RvY29sID09PSBcInJlZGlzOlwiIHx8IHBhcnNlZC5wcm90b2NvbCA9PT0gXCJyZWRpc3M6XCIpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kYiA9IHBhcnNlZC5wYXRobmFtZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJzZWQuaG9zdCkge1xuICAgICAgICByZXN1bHQuaG9zdCA9IHBhcnNlZC5ob3N0bmFtZTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZC5wb3J0KSB7XG4gICAgICAgIHJlc3VsdC5wb3J0ID0gcGFyc2VkLnBvcnQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mYW1pbHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW50RmFtaWx5ID0gTnVtYmVyLnBhcnNlSW50KG9wdGlvbnMuZmFtaWx5LCAxMCk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGludEZhbWlseSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5mYW1pbHkgPSBpbnRGYW1pbHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGxvZGFzaF8xLmRlZmF1bHRzKShyZXN1bHQsIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhcnNlVVJMID0gcGFyc2VVUkw7XG4vKipcbiAqIFJlc29sdmUgVExTIHByb2ZpbGUgc2hvcnRjdXQgaW4gY29ubmVjdGlvbiBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVUTFNQcm9maWxlKG9wdGlvbnMpIHtcbiAgICBsZXQgdGxzID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRscztcbiAgICBpZiAodHlwZW9mIHRscyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGxzID0geyBwcm9maWxlOiB0bHMgfTtcbiAgICBjb25zdCBwcm9maWxlID0gVExTUHJvZmlsZXNfMS5kZWZhdWx0W3RscyA9PT0gbnVsbCB8fCB0bHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRscy5wcm9maWxlXTtcbiAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICB0bHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9maWxlLCB0bHMpO1xuICAgICAgICBkZWxldGUgdGxzLnByb2ZpbGU7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHRscyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLnJlc29sdmVUTFNQcm9maWxlID0gcmVzb2x2ZVRMU1Byb2ZpbGU7XG4vKipcbiAqIEdldCBhIHJhbmRvbSBlbGVtZW50IGZyb20gYGFycmF5YFxuICovXG5mdW5jdGlvbiBzYW1wbGUoYXJyYXksIGZyb20gPSAwKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChmcm9tID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W2Zyb20gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobGVuZ3RoIC0gZnJvbSkpXTtcbn1cbmV4cG9ydHMuc2FtcGxlID0gc2FtcGxlO1xuLyoqXG4gKiBTaHVmZmxlIHRoZSBhcnJheSB1c2luZyB0aGUgRmlzaGVyLVlhdGVzIFNodWZmbGUuXG4gKiBUaGlzIG1ldGhvZCB3aWxsIG11dGF0ZSB0aGUgb3JpZ2luYWwgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpIHtcbiAgICBsZXQgY291bnRlciA9IGFycmF5Lmxlbmd0aDtcbiAgICAvLyBXaGlsZSB0aGVyZSBhcmUgZWxlbWVudHMgaW4gdGhlIGFycmF5XG4gICAgd2hpbGUgKGNvdW50ZXIgPiAwKSB7XG4gICAgICAgIC8vIFBpY2sgYSByYW5kb20gaW5kZXhcbiAgICAgICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb3VudGVyKTtcbiAgICAgICAgLy8gRGVjcmVhc2UgY291bnRlciBieSAxXG4gICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgLy8gQW5kIHN3YXAgdGhlIGxhc3QgZWxlbWVudCB3aXRoIGl0XG4gICAgICAgIFthcnJheVtjb3VudGVyXSwgYXJyYXlbaW5kZXhdXSA9IFthcnJheVtpbmRleF0sIGFycmF5W2NvdW50ZXJdXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy5zaHVmZmxlID0gc2h1ZmZsZTtcbi8qKlxuICogRXJyb3IgbWVzc2FnZSBmb3IgY29ubmVjdGlvbiBiZWluZyBkaXNjb25uZWN0ZWRcbiAqL1xuZXhwb3J0cy5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cgPSBcIkNvbm5lY3Rpb24gaXMgY2xvc2VkLlwiO1xuZnVuY3Rpb24gemlwTWFwKGtleXMsIHZhbHVlcykge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICBrZXlzLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlc1tpbmRleF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXA7XG59XG5leHBvcnRzLnppcE1hcCA9IHppcE1hcDtcbi8qKlxuICogTWVtb2l6ZWQgcGFja2FnZSBtZXRhZGF0YSB0byBhdm9pZCByZXBlYXRlZCBmaWxlIHN5c3RlbSByZWFkcy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IGNhY2hlZFBhY2thZ2VNZXRhID0gbnVsbDtcbi8qKlxuICogUmV0cmlldmVzIGNhY2hlZCBwYWNrYWdlIG1ldGFkYXRhIGZyb20gcGFja2FnZS5qc29uLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMge1Byb21pc2U8e3ZlcnNpb246IHN0cmluZ30gfCBudWxsPn0gUGFja2FnZSBtZXRhZGF0YSBvciBudWxsIGlmIHVuYXZhaWxhYmxlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFBhY2thZ2VNZXRhKCkge1xuICAgIGlmIChjYWNoZWRQYWNrYWdlTWV0YSkge1xuICAgICAgICByZXR1cm4gY2FjaGVkUGFja2FnZU1ldGE7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gKDAsIHBhdGhfMS5yZXNvbHZlKShfX2Rpcm5hbWUsIFwiLi5cIiwgXCIuLlwiLCBcInBhY2thZ2UuanNvblwiKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGZzXzEucHJvbWlzZXMucmVhZEZpbGUoZmlsZVBhdGgsIFwidXRmOFwiKTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgY2FjaGVkUGFja2FnZU1ldGEgPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiBwYXJzZWQudmVyc2lvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFBhY2thZ2VNZXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNhY2hlZFBhY2thZ2VNZXRhID0ge1xuICAgICAgICAgICAgdmVyc2lvbjogXCJlcnJvci1mZXRjaGluZy12ZXJzaW9uXCIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYWNoZWRQYWNrYWdlTWV0YTtcbiAgICB9XG59XG5leHBvcnRzLmdldFBhY2thZ2VNZXRhID0gZ2V0UGFja2FnZU1ldGE7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJub29wIiwiZGVmYXVsdHMiLCJEZWJ1ZyIsImdldFBhY2thZ2VNZXRhIiwiemlwTWFwIiwiQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHIiwic2h1ZmZsZSIsInNhbXBsZSIsInJlc29sdmVUTFNQcm9maWxlIiwicGFyc2VVUkwiLCJvcHRpbWl6ZUVycm9yU3RhY2siLCJ0b0FyZyIsImNvbnZlcnRNYXBUb0FycmF5IiwiY29udmVydE9iamVjdFRvQXJyYXkiLCJ0aW1lb3V0IiwicGFja09iamVjdCIsImlzSW50Iiwid3JhcE11bHRpUmVzdWx0IiwiY29udmVydEJ1ZmZlclRvU3RyaW5nIiwiZnNfMSIsInJlcXVpcmUiLCJwYXRoXzEiLCJ1cmxfMSIsImxvZGFzaF8xIiwiZW51bWVyYWJsZSIsImdldCIsImRlYnVnXzEiLCJkZWZhdWx0IiwiVExTUHJvZmlsZXNfMSIsImVuY29kaW5nIiwiQnVmZmVyIiwidG9TdHJpbmciLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJyZXMiLCJpIiwiYXJyIiwicmVzdWx0IiwiaXRlbSIsIkVycm9yIiwicHVzaCIsIngiLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJhcnJheSIsImNhbGxiYWNrIiwidGltZXIiLCJydW4iLCJjbGVhclRpbWVvdXQiLCJhcHBseSIsImFyZ3VtZW50cyIsInNldFRpbWVvdXQiLCJvYmoiLCJrZXlzIiwibCIsIm1hcCIsInBvcyIsImZvckVhY2giLCJrZXkiLCJhcmciLCJTdHJpbmciLCJlcnJvciIsImZyaWVuZGx5U3RhY2siLCJmaWx0ZXJQYXRoIiwic3RhY2tzIiwic3BsaXQiLCJsaW5lcyIsImluZGV4T2YiLCJqIiwic3RhY2siLCJzbGljZSIsInVybCIsInBvcnQiLCJwYXJzZWQiLCJwYXJzZSIsInNsYXNoZXMiLCJvcHRpb25zIiwicXVlcnkiLCJhdXRoIiwiaW5kZXgiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwicGF0aG5hbWUiLCJwcm90b2NvbCIsImRiIiwicGF0aCIsImhvc3QiLCJob3N0bmFtZSIsImZhbWlseSIsImludEZhbWlseSIsIk51bWJlciIsInBhcnNlSW50IiwidGxzIiwicHJvZmlsZSIsImFzc2lnbiIsImZyb20iLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJjb3VudGVyIiwidmFsdWVzIiwiTWFwIiwic2V0IiwiY2FjaGVkUGFja2FnZU1ldGEiLCJmaWxlUGF0aCIsInJlc29sdmUiLCJfX2Rpcm5hbWUiLCJkYXRhIiwicHJvbWlzZXMiLCJyZWFkRmlsZSIsIkpTT04iLCJ2ZXJzaW9uIiwiZXJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ioredis/built/utils/lodash.js":
/*!****************************************************!*\
  !*** ./node_modules/ioredis/built/utils/lodash.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isArguments = exports.defaults = exports.noop = void 0;\nconst defaults = __webpack_require__(/*! lodash.defaults */ \"(rsc)/./node_modules/lodash.defaults/index.js\");\nexports.defaults = defaults;\nconst isArguments = __webpack_require__(/*! lodash.isarguments */ \"(rsc)/./node_modules/lodash.isarguments/index.js\");\nexports.isArguments = isArguments;\nfunction noop() {}\nexports.noop = noop;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC91dGlscy9sb2Rhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxnQkFBZ0IsR0FBR0EsWUFBWSxHQUFHLEtBQUs7QUFDN0QsTUFBTUcsV0FBV0UsbUJBQU9BLENBQUMsc0VBQWlCO0FBQzFDTCxnQkFBZ0IsR0FBR0c7QUFDbkIsTUFBTUQsY0FBY0csbUJBQU9BLENBQUMsNEVBQW9CO0FBQ2hETCxtQkFBbUIsR0FBR0U7QUFDdEIsU0FBU0UsUUFBUztBQUNsQkosWUFBWSxHQUFHSSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvbG9kYXNoLmpzP2I2YTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQXJndW1lbnRzID0gZXhwb3J0cy5kZWZhdWx0cyA9IGV4cG9ydHMubm9vcCA9IHZvaWQgMDtcbmNvbnN0IGRlZmF1bHRzID0gcmVxdWlyZShcImxvZGFzaC5kZWZhdWx0c1wiKTtcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmNvbnN0IGlzQXJndW1lbnRzID0gcmVxdWlyZShcImxvZGFzaC5pc2FyZ3VtZW50c1wiKTtcbmV4cG9ydHMuaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmV4cG9ydHMubm9vcCA9IG5vb3A7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc0FyZ3VtZW50cyIsImRlZmF1bHRzIiwibm9vcCIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ioredis/built/utils/lodash.js\n");

/***/ })

};
;